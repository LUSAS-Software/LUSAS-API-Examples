' LUSAS API (LPI) PYTHON EXAMPLES
' (https://github.com/LUSAS-Software/LUSAS-API-Examples/)
'
' Example:      06a_Getting_Results.lvb
' Description:  Extract nodal and element results.
'               This example does the extraction in different approaches. It is recommended to use the results component set approach for most cases.
'               To compare the different approaches, it is recommended that the Jupyter Notebook example is used instead.
' Author:       Finite Element Analysis Ltd
' Date:         2025-04-28
' 
' Libraries: Load the Helpers.vbs which contains useful functions
$INCLUDE %RunningScriptPath%\shared\Helpers.vbs
$ENGINE=VBScript

' Check if a model is open
If not existsDatabase() Then
    Call Err.Raise(vbObjectError + 10, "Example Script", vbCrLf & "A model must be open before running this code" & vbCrLf)
End If

' To successfully run the code below you must have a model solved.

' Get selected nodes
selectedNodes = selection().getObjects("Node")

If Ubound(selectedNodes) + 1 = 0 Then
    Call Err.Raise(vbObjectError + 10, "Example Script", vbCrLf & "No nodes selected. Please select some nodes to get results from." & vbCrLf)
End If

'#####################################################
'# Nodal Results
' All nodes have displacement results. Here we simply loop through the nodes contained in the current selection and ask for the results of displacement and printing them

' Print displacements (model units)
For Each n in selectedNodes
    dx = n.getResults("Displacement", "DX")(0)
    dy = n.getResults("Displacement", "DY")(0)
    dz = n.getResults("Displacement", "DZ")(0)
    Call textWin.writeLine(dx, dy, dz)
Next

' Print reactions and calculate total reactions (model units)
total_fx = 0.0
total_fy = 0.0
total_fz = 0.0
For Each n in selectedNodes
    ' Non supported nodes will return a value of 2.2250738585072014e-308. This is the smallest possible value represented by a 64bit double precision variable.
    ' We can avoid this small value by asking if a result is available
    If n.hasResults("Reaction", "FX") Then
        fx = n.getResults("Reaction", "FX")(0)
    Else
        fx = 0.0
    End If
    If n.hasResults("Reaction", "FY") Then
        fy = n.getResults("Reaction", "FY")(0)
    Else
        fy = 0.0
    End If
    If n.hasResults("Reaction", "FZ") Then
        fz = n.getResults("Reaction", "FZ")(0)
    Else
        fz = 0.0
    End If
    Call textWin.writeLine(fx & ", " & fy & ", " & fz)

    total_fx = total_fx + fx
    total_fy = total_fy + fy
    total_fz = total_fz + fz
Next

' Print total reactions (model units)
Call textWin.writeLine("Total reactions of selected nodes : " & fx & ", " & fy & ", " & fz)

' NOTE:
' The getResults function has 3 additional optional arguments as shown in the LPI Reference manual
' `getResults(entity, component, [units], [loadcase], [context])`
' 
' The results we have been getting so far have been in model units and for the active loadset. 
' The first additional argument allows us to ask for results in a different unit set.
' The second additional argument is actually a return value that is used when the active loadset is an envelope. In this case the loadcase causing the requested results is returned through this argument.
' The third argument allows us to specify other settings for the results such as a different loadset. We will return to resultsets later.


'#####################################################
'# Element Results

' Elements do not have a getResults() function like nodes because elements have many different types of results. Shells beams, solids and joint elements all have different results and result locations.
' 
' A beam element for example has results at each node, it also has a series of intermediate or "internal" results.
' A shell element also nodal results at each node but it does not have internal results, instead it has additional results at the gauss/integration points 
' 
' The element interface therefore has several functions to deal with these differences and its up to you to call the correct one for the element you are looking at.
' 
' If we ask the database for all elements, that's exactly what we'll get and we'd have to write a lot of code to handle the various element types as follows:

allElements = database.getObjects("Element")
For Each e in allElements
    stressType = e.getStressType()
    if e.getDomainDimension() = 1 Then ' Beam Element
        if stressType = "Thick 3D Beam" Then
            ' Get bending moment My for each internal point
            For i = 0 To e.countInternalPoints() - 1
                my = e.getInternalResults(i, "Force/Moment - Thick 3D Beam", "My")(0)
                Call textWin.writeLine(my)
            Next
            ' Or get the internal results as an array
            my = e.getInternalResultsArray("Force/Moment - Thick 3D Beam", "My")
        End If
    ElseIf e.getDomainDimension() = 2 Then ' Shell Element
        ' Do nothing
    ElseIf e.getDomainDimension() = 3 Then ' Solid Element
        ' Do nothing
    End If
Next

' The above can be repeated for all element types but you may have noticed that this approach is very slow and not recommended.
' A much better approach is to use results component sets.


'#####################################################
'# Results Component Sets
' A results component set is a container for a particular set of results. It is much more efficient than asking for results all at once.


' Get the internal point results for all thick beam elements
Set results_my = database().getResultsComponentSet("Force/Moment - Thick 3D Beam", "My", "Internal")
Set i_my = results_my.getComponentNumber("My")

For Each e in allElements
    stressType = e.getStressType()
    if e.getDomainDimension() = 1 Then ' Beam Element
        if stressType = "Thick 3D Beam" Then
            ' Note the unitset is not optional but providing Nothing uses the current database units
            my = results_my.getInternalResultsArray(i_my, e, Nothing)
            Call textWin.writeLine(my)
        End If
    End If
Next


'# Instead of checking all elements and their type, we can filter them using an Object Set.
' Depending on what your model contains the following code should run much quicker than previous methods. This is because we filtered out only the elements of interest and removed any subsequent type checking.

' Create an object set containing only the thick 3d beam elements.
Set beams = newObjectSet().add("Thick 3D Beam")

' Get the internal point results for all thick beam elements
For Each e in beams.getObjects("Element")
    ' Note the unitset is not optional but providing Nothing uses the current database units
    my = results_my.getInternalResultsArray(i_my, e, Nothing)
    Call textWin.writeLine(my)
Next

' Remember clear the results component set if not used again to free up memory (commented in this case since we are using it again)
'results_my = Nothing 


'# The final piece of the puzzle is to provide a results context.
' Results context can be set to any loadcase and set of elements so we are no longer relying on the active settings of the user interface.

' Create a results context for the beam elements
Set context = newResultsContext(Nothing)
' Set target elements
Call context.getCalcResultsSet().add(beams)
' Set loadset 1 as the active loadset of the context
Call context.setActiveLoadset(1)

For Each e in beams.getObjects("Element")
    ' Note the unitset is not optional but providing None uses the current database units
    my = results_my.getInternalResultsArray(i_my, e, Nothing)
    Call textWin.writeLine(my)
Next

' Free up memory if the script will continue to run (not required in this case
results_my = Nothing
context = Nothing
beams = Nothing


' The general principle laid out above can be used for all elements, nodes and inspection location results.
