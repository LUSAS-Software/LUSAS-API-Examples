#########################################
# Copyright Finite Element Analysis Ltd #
#########################################

# This file provides LPI documentation for LUSAS Modeller v21.1 in a form that editors can use to
# generate intellisense style code completion and documentation


from __future__ import annotations
class IDispatch:pass
class IFDispatch:pass


class IFModellerDlg(IFDispatch):
	"""
	Base class of all external dialogs wishing to be part of the modeller interface 
	"""

	def onClose(self) -> None:
		r"""
		called when Modeller closes 
		Returns:
			None: 
		"""
		pass


	def getMainWndHandle(self) -> float:
		r"""
		Returns the dialog's main window handle 
		Returns:
			float: handle to the main window
		"""
		pass


class IFUnit(IFDispatch):
	"""
	Representation of a single unit, such as 'kilometres'. At present the only purpose of such units is during the creation of an IFUnitSet. 
	"""

	pass


class IFUnitSet(IFDispatch):
	"""
	Represents a set of units, with reference to the default SI units "N m kg C s". This is represented as a conversion factor for each of the five physical quantities: force, length, mass, time and temperature. The factor is a multiplier to convert from one default SI unit to the required units. For example, if the required units are kiloNewtons, there are 0.001 kiloNewtons to one Newton and so the conversion factor is 0.001. Similarly, if the required units are feet, there are 3.281 feet to one metre, and so the conversion factor is 3.281 Unit sets are created using the function IFModeller.createUnitSet 
	"""

	def getName(self) -> str:
		r"""
		Return the name with which these units were created 
		Returns:
			str: the returned name
		"""
		pass


	def convertToSI(self, value, energyDim, forceDim, lengthDim, massDim, timeDim, temperatureDim, perLengthDim=None) -> None:
		r"""
		Modify the first argument (which is assumed to be given in the same units as this object) such that its value is given in SI (J,N,m,kg,s,C) The other arguments indicate the dimensionality of the value. For example, an acceleration has exponent 1 of length, and exponent -2 of time. In combination with IFUnitSet.convertFromSI, this function can be used to convert any value from any unit system to any other unit system. Whilst energy and force can be derived from the other four dimensions, they are included for convenience. 
		Params:
			value (object): value to modify
			energyDim (int): exponent of energy
			forceDim (int): exponent of force
			lengthDim (int): exponent of length
			massDim (int): exponent of mass
			timeDim (int): exponent of time
			temperatureDim (int): exponent of temperature
			perLengthDim (int, optional): 0 (the default) for most quantities. 1 for quantities that are 'per unit length', such as "mm�/m". Similarly 2 and 3 for quantities that are per unit area or volume.
		Returns:
			None: 
		"""
		pass


	def convertFromSI(self, value, energyDim, forceDim, lengthDim, massDim, timeDim, temperatureDim, perLengthDim=None) -> None:
		r"""
		Modify the first argument (which is assumed to be given in SI (J,N,m,kg,s,C) ) such that its value is given in the same units as this object For futher details see IFUnitSet.convertToSI 
		Params:
			value (object): value to modify
			energyDim (int): exponent of energy
			forceDim (int): exponent of force
			lengthDim (int): exponent of length
			massDim (int): exponent of mass
			timeDim (int): exponent of time
			temperatureDim (int): exponent of temperature
			perLengthDim (int, optional): 0 (the default) for most quantities. 1 for quantities that are 'per unit length', such as "mm�/m". Similarly 2 and 3 for quantities that are per unit area or volume.
		Returns:
			None: 
		"""
		pass


	def convertToUnitSet(self, convertToSet, value, energyDim, forceDim, lengthDim, massDim, timeDim, temperatureDim, perLengthDim=None) -> None:
		r"""
		Modify the second argument (which is assumed to be given in this object units) and convert it to the first argument, which is assumed to be an IFUnitSet object (or the name thereof). For futher details see IFUnitSet.convertToSI 
		Params:
			convertToSet (str or IFUnitSet): Unit set to modify the value to
			value (object): value to modify
			energyDim (int): exponent of energy
			forceDim (int): exponent of force
			lengthDim (int): exponent of length
			massDim (int): exponent of mass
			timeDim (int): exponent of time
			temperatureDim (int): exponent of temperature
			perLengthDim (int, optional): 0 (the default) for most quantities. 1 for quantities that are 'per unit length', such as "mm�/m". Similarly 2 and 3 for quantities that are per unit area or volume.
		Returns:
			None: 
		"""
		pass


	def convertToUnitSetPackedDim(self, convertToSet, value, packedDim) -> None:
		r"""
		Modify the second argument (which is assumed to be given in this object's units) and convert it to the first argument, which is assumed to be an IFUnitSet object (or the name thereof). For further details see IFUnitSet.convertToSI This is an overload function of convertToUnitSet that instead of taking all dimensions as arguments, needs just the packed long. 
		Params:
			convertToSet (str or IFUnitSet): Unit set to convert the value to
			value (object): value to convert
			packedDim (unsigned int): exponent of the packed dimension
		Returns:
			None: 
		"""
		pass


	def getEnergyShortName(self) -> str:
		r"""
		return the short energy unit name (e.g. 'm') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getEnergyLongName(self) -> str:
		r"""
		return the long energy unit name (e.g. 'meters') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getEnergyFactor(self) -> float:
		r"""
		return the energy factor - calculated from the factors given via energy = force * distance 
		Returns:
			float: the returned factor
		"""
		pass


	def getForceShortName(self) -> str:
		r"""
		return the short force unit name (e.g. 'm') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getForceLongName(self) -> str:
		r"""
		return the long force unit name (e.g. 'meters') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getForceFactor(self) -> float:
		r"""
		return the force factor - calculated from the factors given via force = mass * acceleration 
		Returns:
			float: the returned factor
		"""
		pass


	def getLengthShortName(self) -> str:
		r"""
		return the short length unit name (e.g. 'm') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getLengthLongName(self) -> str:
		r"""
		return the long length unit name (e.g. 'meters') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getLengthFactor(self) -> float:
		r"""
		return the length factor with which this object was created 
		Returns:
			float: the returned factor
		"""
		pass


	def getMassShortName(self) -> str:
		r"""
		return the short mass unit name (e.g. 'm') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getMassLongName(self) -> str:
		r"""
		return the long mass unit name (e.g. 'meters') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getMassFactor(self) -> float:
		r"""
		return the mass factor with which this object was created 
		Returns:
			float: the returned factor
		"""
		pass


	def getTimeShortName(self) -> str:
		r"""
		return the short time unit name (e.g. 'm') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getTimeLongName(self) -> str:
		r"""
		return the long time unit name (e.g. 'meters') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getTimeFactor(self) -> float:
		r"""
		return the time factor with which this object was created 
		Returns:
			float: the returned factor
		"""
		pass


	def getTemperatureShortName(self) -> str:
		r"""
		return the short temperature unit name (e.g. 'm') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getTemperatureLongName(self) -> str:
		r"""
		return the long temperature unit name (e.g. 'meters') with which this object was created 
		Returns:
			str: the returned name
		"""
		pass


	def getTemperatureFactor(self) -> float:
		r"""
		return the temperature factor with which this object was created 
		Returns:
			float: the returned factor
		"""
		pass


	def getTemperatureOffset(self) -> float:
		r"""
		return the temperature offset with which this object was created 
		Returns:
			float: the returned offset
		"""
		pass


	def describeAsString(self, dim, lengthUnitSet=None, timescaleUnitSet=None) -> str:
		r"""
		Return a description of the given dimensionality, using the definition of this 
		Params:
			dim (unsigned int): the packed dimensionality of the quantity to be described
			lengthUnitSet (IFUnitSet, optional): The name or ID of a unitset, or a pointer to a IFUnitSet object. Only used by dimensions that have a non-zero value for 'perLength'. This allows the return of values such as "mm�/m"
			timescaleUnitSet (str, optional): "Seconds", "Minutes", "Hours" or "Days". Only used by dimensions that are in terms of solution time (like age)
		Returns:
			str: the returned description
		"""
		pass


	def splitFeetInches(self, val, feet, inches) -> bool:
		r"""
		Separates the given numeric value into feet and inches. Note that the current model units determine whether the input value is assumed to be given in feet or inches. (e.g. 15.125 feet -> 15'1.5") (e.g. 15.125 inches -> 1'3.125") 
		Params:
			val (float): The input value
			feet (float): The value in feet
			inches (float): The value in inches
		Returns:
			bool: false if the operation was successful. The function will return true if the current unit set is in neither feet nor inches
		"""
		pass


	def isUnset(self) -> bool:
		r"""
		Returns true any of the unit names is not set 
		Returns:
			bool: 
		"""
		pass


	def isLengthImperial(self) -> bool:
		r"""
		Returns true if the length is in imperial unit system (inches, feet, miles) 
		Returns:
			bool: 
		"""
		pass


	def hide(self) -> None:
		r"""
		Hide this unit set from Modeller user interface. The user will not be able to select it 
		Returns:
			None: 
		"""
		pass


class IFCellBitmapDC(IFDispatch):
	"""
	A rectangle object in a view that holds a bitmap 
	"""

	def width(self) -> int:
		r"""
		Returns the width of the cell 
		Returns:
			int: 
		"""
		pass


	def height(self) -> int:
		r"""
		Returns the height of the cell 
		Returns:
			int: 
		"""
		pass


	def getDatabaseObject(self) -> IFDatabaseMember:
		r"""
		Returns the database object that this cell is related to 
		Returns:
			IFDatabaseMember: 
		"""
		pass


	def setTitle(self, text, fontName=None, fontSize=None, align=None, bold=None, italic=None) -> None:
		r"""
		Sets the title to the cell and its format 
		Params:
			text (str): Title text
			fontName (str, optional): Font family name to be used. If empty the default will be used
			fontSize (int, optional): Font size to be used. If <= 0 the default will be used
			align (int, optional): 0: Left align, 1: Centre align, 2: Right align
			bold (bool, optional): if True title will be bold
			italic (bool, optional): if False title will be italic
		Returns:
			None: 
		"""
		pass


	def setPaddings(self, left, top, right, bottom) -> None:
		r"""
		Sets the cell paddings 
		Params:
			left (int): left padding
			top (int): top padding
			right (int): right padding
			bottom (int): bottom padding
		Returns:
			None: 
		"""
		pass


	def setBitmapFile(self, filePath) -> None:
		r"""
		Sets the bitmap of this cell from a file 
		Params:
			filePath (str): the path of the bitmap file
		Returns:
			None: 
		"""
		pass


class IFCellTextDC(IFDispatch):
	"""
	a rectangle object in a view that draws text 
	"""

	def width(self) -> int:
		r"""
		Returns the width of the cell 
		Returns:
			int: 
		"""
		pass


	def height(self) -> int:
		r"""
		Returns the height of the cell 
		Returns:
			int: 
		"""
		pass


	def getDatabaseObject(self) -> IFDatabaseMember:
		r"""
		Returns the database object that this cell is related to 
		Returns:
			IFDatabaseMember: 
		"""
		pass


	def setTitle(self, text, fontName=None, fontSize=None, align=None, bold=None, italic=None) -> None:
		r"""
		Sets the title to the cell and its format 
		Params:
			text (str): Title text
			fontName (str, optional): Font family name to be used. If empty the default will be used
			fontSize (int, optional): Font size to be used. If <= 0 the default will be used
			align (int, optional): 0: Left align, 1: Centre align, 2: Right align
			bold (bool, optional): if True title will be bold
			italic (bool, optional): if False title will be italic
		Returns:
			None: 
		"""
		pass


	def setPaddings(self, left, top, right, bottom) -> None:
		r"""
		Sets the cell paddings 
		Params:
			left (int): left padding
			top (int): top padding
			right (int): right padding
			bottom (int): bottom padding
		Returns:
			None: 
		"""
		pass


	def setFont(self, name, size) -> None:
		r"""
		Sets the font in the cell for the text that follows 
		Params:
			name (str): the font-family name
			size (int): the font size
		Returns:
			None: 
		"""
		pass


	def setAlign(self, align) -> None:
		r"""
		Sets the alignment in the cell for the text that follows 0: Left align 1: Centre align 2: Right align 
		Params:
			align (int): the text alignment
		Returns:
			None: 
		"""
		pass


	def setWordWrap(self, wordWrap) -> None:
		r"""
		Sets the word wrapping to true or false for the text that follows 
		Params:
			wordWrap (bool): True/False for word wrapping
		Returns:
			None: 
		"""
		pass


	def setTabStop(self, tabStop) -> None:
		r"""
		Sets the tab stop in pixels. Depending on the font size, a logical number should be set in order for the tabs from the addTab command to appear normally. e.g for an Arial 12 a tab stop = 30 is an acceptable number. 
		Params:
			tabStop (int): the tab stop
		Returns:
			None: 
		"""
		pass


	def addText(self, text) -> None:
		r"""
		Adds text to the cell 
		Params:
			text (str): the text to be added
		Returns:
			None: 
		"""
		pass


	def clear(self) -> None:
		r"""
		Removes all text from the cell 
		Returns:
			None: 
		"""
		pass


	def newLine(self, lines=None) -> None:
		r"""
		Goes to the next line(s) (like pressing the enter key) in an editor 
		Params:
			lines (int, optional): the number of new lines. Default 1
		Returns:
			None: 
		"""
		pass


	def addTab(self, tabs=None) -> None:
		r"""
		Adds tab(s) to the text in the cell 
		Params:
			tabs (int, optional): the number of tabs to be added. Default 1
		Returns:
			None: 
		"""
		pass


	def beginBold(self) -> None:
		r"""
		Starts a block with bold format. All text between this command and endBold will be bold 
		Returns:
			None: 
		"""
		pass


	def endBold(self) -> None:
		r"""
		Ends a block of bold format (see beginBold). 
		Returns:
			None: 
		"""
		pass


	def beginItalic(self) -> None:
		r"""
		Starts a block with italic format. All text between this command and endItalic will be italic 
		Returns:
			None: 
		"""
		pass


	def endItalic(self) -> None:
		r"""
		Ends a block of italic format (see beginItalic). 
		Returns:
			None: 
		"""
		pass


class IFTextWindow(IFDispatch):
	"""
	This object allows access to the text output window. This window can be used for displaying messages from a script or control. Messages can also be retrieved by a script or control for processing. The text window object is accessed as a sub-object of the LUSAS Modeller application, using the function IFModeller.getTextWindow or the variable IFModeller.textWin. 
	"""

	def writeLine(self, text, type=None) -> None:
		r"""
		Write a line of text to the text output window of LUSAS Modeller 
		Params:
			text (str): The line of text to be written to the output window. A new line character will automatically be appended.
			type (str or int, optional): 0 = "error", 1 = "warning", 2 = "progress", 3 = "information", 4 = "unknown", 5 = "debug", 6 = "blank", or 7 = "impossible"
		Returns:
			None: 
		"""
		pass


	def clear(self) -> None:
		r"""
		Clear all text from the text output window of LUSAS Modeller 
		Returns:
			None: 
		"""
		pass


	def readLine(self, i) -> str:
		r"""
		Read the i'th line of text from the text output window of LUSAS Modeller 
		Params:
			i (int): The index of the desired line of text. The first (oldest) line is 0
		Returns:
			str: The line of text from the output window. The new line character is automatically removed.
		"""
		pass


	def countLines(self) -> int:
		r"""
		Count the number of lines of text in the text output window of Modeller 
		Returns:
			int: The number of lines in the window
		"""
		pass


	def attachLogFile(self, filename, captureExisting=None) -> None:
		r"""
		Attach the named file to the text window, such that all text added to the window is also added to the file 
		Params:
			filename (str): absolute or relative pathname of the file
			captureExisting (bool, optional): Copy the existing contents of the window to the file? If not specified, assumed to be true
		Returns:
			None: 
		"""
		pass


	def closeLogFile(self) -> None:
		r"""
		Close the file previously opened with attachLogFile 
		Returns:
			None: 
		"""
		pass


	def getLogFile(self) -> str:
		r"""
		return the filename previously attached using IFTextWindow.attachLogFile If no log file is attached, an empty string is returned 
		Returns:
			str: 
		"""
		pass


	def update(self) -> None:
		r"""
		Perform a paint of this window. The repainting of the window takes considerable time. Therefore when processing a script, by default LUSAS Modeller only repaints the window when new text comes along and when no redraw has taken place for at least half a second (approximately). Therefore in a script or customisable dialog which shows infrequent messages it is possible for the most recent message(s) to be shown later than required. Calling this function causes an immediate repaint and therefore avoids this problem 
		Returns:
			None: 
		"""
		pass


class IFAnimationManager(IFDispatch):
	"""
	This object gathers together all of the functionality needed to capture images and convert them into animation. It is equivalent to the animation toolbar in the Modeller user interface. 
	"""

	def create(self) -> None:
		r"""
		Convert the frames added using IFAnimationManager.addFrame into an animation Also clears the frames ready to start building up the next animation 
		Returns:
			None: 
		"""
		pass


	def clearFrames(self) -> None:
		r"""
		Remove all frames added using IFAnimationManager.addFrame 
		Returns:
			None: 
		"""
		pass


	def deleteFrame(self, frameNo) -> None:
		r"""
		Remove the numbered frame 
		Params:
			frameNo (int): Frame to remove. 0 is the first (oldest) frame
		Returns:
			None: 
		"""
		pass


	def overwriteFrame(self, frameNo) -> None:
		r"""
		As IFAnimationManager.addFrame, but replaces an existing numbered frame 
		Params:
			frameNo (int): Frame to overwrite. 0 is the first (oldest) frame
		Returns:
			None: 
		"""
		pass


	def addFrame(self) -> None:
		r"""
		Captures the image in the current window, ready for later conversion to animation, using IFAnimationManager.create 
		Returns:
			None: 
		"""
		pass


class IFAnimationView(IFDispatch):
	"""
	Represents the playback of just one animation, shown in the Modeller user interface as an animation window. Changes to this animation will not affect other animations that may be currently playing, or played in the future. It is only possible to control the active, or current animation (the window that is 'nearest') and this is obtained using IFModeller.getCurrentAnimation 
	"""

	def play(self, isBackward=None) -> None:
		r"""
		Starts playback of this animation. If IFAnimationView.repeat is called, the playback can be endlessly repeated, or played once per call to IFAnimationView.play 
		Params:
			isBackward (bool, optional): true to play backward, false (the default) to play forward
		Returns:
			None: 
		"""
		pass


	def step(self, isBackward=None) -> None:
		r"""
		Steps this animation forward or backward one frame 
		Params:
			isBackward (bool, optional): true to step backward, false (the default) to step forward
		Returns:
			None: 
		"""
		pass


	def stop(self) -> None:
		r"""
		Stops playback of this animation 
		Returns:
			None: 
		"""
		pass


	def pause(self, isPause=None) -> None:
		r"""
		Pauses, or continues, playback of this animation 
		Params:
			isPause (bool, optional): true to pause, false to continue after a previous pause
		Returns:
			None: 
		"""
		pass


	def setSpeed(self, speed) -> None:
		r"""
		Sets the speed of playback in frames/second 
		Params:
			speed (int): number of frames per second
		Returns:
			None: 
		"""
		pass


	def repeat(self, isRepeat) -> None:
		r"""
		Puts this animation into or out of repeat mode - endlessly repeating until stopped 
		Params:
			isRepeat (bool): true to repeat, false for 'play once' mode
		Returns:
			None: 
		"""
		pass


	def close(self) -> None:
		r"""
		Closes this animation 
		Returns:
			None: 
		"""
		pass


	def saveAs(self, filename) -> None:
		r"""
		Saves this animation as an AVI file to the given path name. If the filename given is not a fully qualified absolute path name (i.e. it does not begin with a network path or drive letter), LUSAS Modeller will assume that it is a relative path name with respect to the current working directory 
		Params:
			filename (str): Absolute or relative pathname of the script
		Returns:
			None: 
		"""
		pass


class IFToolbarManager(IFDispatch):
	"""
	Allows control from a script of LUSAS Modeller's command toolbar buttons. Note that LUSAS Modeller will remember the previous state of toolbar buttons from one session to another, so some care must be taken to check the current state before adding buttons (or a new button will be added each time the script is run) Toolbars are named, but buttons are numbered. Toolbar names can be any arbitrary string that is not already used as a toolbar name. Button numbering starts at 1, and refers to the index in the customise toolbar dialog 
	"""

	def createToolbar(self, name) -> None:
		r"""
		Create a new named toolbar in Modeller. 
		Params:
			name (str): name of new toolbar
		Returns:
			None: 
		"""
		pass


	def removeButton(self, buttonNo) -> None:
		r"""
		Remove a button from all toolbars 
		Params:
			buttonNo (int): type of button
		Returns:
			None: 
		"""
		pass


	def addButton(self, toolbarName, buttonNo) -> None:
		r"""
		Add a button at the end of a particular named toolbar 
		Params:
			toolbarName (str): named toolbar to modify
			buttonNo (int): type of button
		Returns:
			None: 
		"""
		pass


	def showToolbar(self, toolbarName, isShow) -> None:
		r"""
		Call to show and hide a toolbar 
		Params:
			toolbarName (str): named toolbar to modify
			isShow (bool): whether or not to show
		Returns:
			None: 
		"""
		pass


	def insertSeparator(self, toolbarName, position) -> None:
		r"""
		Insert a separator on toolbar 
		Params:
			toolbarName (str): named toolbar to modify
			position (int): 0=start,1=after first etc.
		Returns:
			None: 
		"""
		pass


	def enableButton(self, buttonNo, isEnable) -> None:
		r"""
		Enable button on toolbar 
		Params:
			buttonNo (int): type of button
			isEnable (bool): 0 for disabled (greyed out), 1 for enabled (default)
		Returns:
			None: 
		"""
		pass


	def useSession(self, buttonNo, isSession) -> None:
		r"""
		Determines whether or not commands from the given button are sent to session file. Generally this will be true, but if the command launches customisable functionality such as a dialog, it may be appropriate to issues session file commands only when the dialog is OK'd 
		Params:
			buttonNo (int): type of button
			isSession (bool): 1 (default) to send commands to session file. 0 to bypass session file
		Returns:
			None: 
		"""
		pass


	def setCommand(self, buttonNo, command) -> None:
		r"""
		Sets the text that is actioned (and optionally written to session file) when button is clicked 
		Params:
			buttonNo (int): type of button
			command (str): command to action when button pressed
		Returns:
			None: 
		"""
		pass


	def setTooltip(self, buttonNo, tooltip) -> None:
		r"""
		Sets the text that is displayed in the tooltip when the mouse hovers over button 
		Params:
			buttonNo (int): type of button
			tooltip (str): tooltip to show
		Returns:
			None: 
		"""
		pass


	def setHelpStr(self, buttonNo, help) -> None:
		r"""
		Sets the text that is displayed in the status bar when the mouse hovers over button 
		Params:
			buttonNo (int): type of button
			help (str): message to show in status bar
		Returns:
			None: 
		"""
		pass


	def toolbarExists(self, toolbarName) -> bool:
		r"""
		Only present for v13 compatibility - use existsToolbar 
		Params:
			toolbarName (str): named toolbar to modify
		Returns:
			bool: true if present
		"""
		pass


	def existsToolbar(self, toolbarName) -> bool:
		r"""
		Return true if the named toolbar exists 
		Params:
			toolbarName (str): named toolbar to modify
		Returns:
			bool: true if present
		"""
		pass


	def buttonPresent(self, buttonNo) -> bool:
		r"""
		Return true if the numbered button exists 
		Params:
			buttonNo (int): type of button
		Returns:
			bool: true if present
		"""
		pass


class IFMenu(IFDispatch):
	"""
	Allows commands to be activated from the drop down menus along the top of the Modeller application. Note the vital difference between a sub menu and a menu item. A sub menu can contain menu items and/or other sub menus. Menu items can be clicked on to invoke functionality. Take care when removing Modeller's default sub menus and menu items - they are difficult to reintroduce. Menu items, once added, can subsequently be added removed and recreated at will. Adding your own menu items allows you to conveniently invoke Modeller LPI functionality 
	"""

	def insertItem(self, beforeItem, itemText, command, helpString=None, sessionFile=None) -> int:
		r"""
		Inserts a new menu item before the specified item in this menu The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item Note that menu IDs are considered temporary  and are only valid for a given interactive session, and thus should not be stored in model files or similar. 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
			itemText (str): text of new item
			command (str): command to execute when menu item selected
			helpString (str, optional): help string to be displayed in status bar when cursor hovers over menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			int: The automatically generated (and temporary) ID of the newly created menu item
		"""
		pass


	def appendItem(self, itemText, command, helpString=None, sessionFile=None) -> int:
		r"""
		Appends a new menu item at the end of this menu Note that the returned menu ID is considered temporary  and is only valid for a given interactive session, and thus should not be stored in model files or similar. 
		Params:
			itemText (str): text of new item
			command (str): command to execute when menu item selected
			helpString (str, optional): help string to be displayed in status bar when cursor hovers over menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			int: The automatically generated (and temporary) ID of the newly created menu item
		"""
		pass


	def renameItem(self, itemText, newItemText) -> None:
		r"""
		Rename a specified sub menu or menu item 
		Params:
			itemText (str or int): item to be renamed
			newItemText (str): new text
		Returns:
			None: 
		"""
		pass


	def enableItem(self, itemText, isEnable) -> None:
		r"""
		Enable or disable (grey out) the specified menu item Note that it is not possible to grey out sub menus 
		Params:
			itemText (str or int): item to be enabled/disabled
			isEnable (bool): true to enable
		Returns:
			None: 
		"""
		pass


	def getSubMenu(self, menuText) -> IFMenu:
		r"""
		Return the sub menu with the given name 
		Params:
			menuText (str): text
		Returns:
			IFMenu: returned sub menu
		"""
		pass


	def insertMenu(self, beforeItem, menuText) -> IFMenu:
		r"""
		Insert new sub menu before the specified item in this menu The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
			menuText (str): new sub menu name
		Returns:
			IFMenu: returned new sub menu object
		"""
		pass


	def remove(self, menuText) -> None:
		r"""
		Remove specified sub menu or menu item 
		Params:
			menuText (str or int): Menu item to be removed
		Returns:
			None: 
		"""
		pass


	def appendMenu(self, menuText) -> IFMenu:
		r"""
		Add sub menu to existing menu 
		Params:
			menuText (str): menu item
		Returns:
			IFMenu: menu object
		"""
		pass


	def appendSeparator(self) -> None:
		r"""
		Append a horizontal line separator after the last sub menu or menu item 
		Returns:
			None: 
		"""
		pass


	def insertSeparator(self, beforeItem) -> None:
		r"""
		Insert a horizontal line separator before the specified item in this menu 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
		Returns:
			None: 
		"""
		pass


	def removeSeparator(self, beforeItem) -> None:
		r"""
		Remove separator located before the specified item in this menu 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
		Returns:
			None: 
		"""
		pass


	def removeAllSeparators(self) -> None:
		r"""
		Remove all separators 
		Returns:
			None: 
		"""
		pass


	def count(self) -> int:
		r"""
		Return total number of menu items, sub menus, and separators in menu 
		Returns:
			int: number
		"""
		pass


	def exists(self, menuText) -> bool:
		r"""
		Check if specified sub menu or menu item exists 
		Params:
			menuText (str): text to check
		Returns:
			bool: exists flag
		"""
		pass


	def isMenu(self, menuText) -> bool:
		r"""
		Check whether the specified name refers to a sub menu False will be returned if the specified name is not present, or is a menu item 
		Params:
			menuText (str): text to check
		Returns:
			bool: true if a sub menu, false otherwise
		"""
		pass


	def findMenuItem(self, item, menu, index) -> bool:
		r"""
		Given the label or ID of an existing menu item, this function returns whether or not the item was found. If the item was found, the menu and index arguments are modified to suit. If the item was not found, these arguments are left unmodified. If more than one menu item exists with the given label/ID, it is arbitrary which one will returned. 
		Params:
			item (str or int): menu item to be found
			menu (IFMenu): returned menu if found
			index (int): returned index within menu if found
		Returns:
			bool: true if found, false otherwise
		"""
		pass


class IFResultsCache(IFDispatch):
	"""
	results cache retired as of P584 Encapsulates the functionality of results that are cached for enhanced interactive performance. Specifically the caching of combination and envelope results. 
	"""

	def enableDefaultCache(self) -> None:
		r"""
		Call to switch results caching on with all default settings 
		Returns:
			None: 
		"""
		pass


	def enableCache(self, isEnable, nElements=None, nLoadacses=None) -> None:
		r"""
		Call to switch results caching on (with manually specified settings) or off. 
		Params:
			isEnable (bool): 
			nElements (int, optional): (default 100) percentage of elements that need to be viewed, for caching to occur
			nLoadacses (int, optional): (default 1) number of loadcases that need to be viewed, for caching to occur
		Returns:
			None: 
		"""
		pass


	def calculateNow(self) -> None:
		r"""
		Call to immediately loop, compute and cache all the PRW utilties that were previously specified via IFResultsCache.addPRWUtility 
		Returns:
			None: 
		"""
		pass


	def calculateOnSolve(self, isEnable) -> None:
		r"""
		Call with 'true' to automatically calculate and cache results immediately after solving the model, and before becoming interactive again. Call with 'false' to cache results only when they are calculated during normal interactive use 
		Params:
			isEnable (bool): 
		Returns:
			None: 
		"""
		pass


	def removePRWUtilities(self) -> None:
		r"""
		Call to remove all PRW utilities previously added with IFResultsCache.addPRWUtility 
		Returns:
			None: 
		"""
		pass


	def addPRWUtility(self, attr) -> None:
		r"""
		add a PRW utility to the list of utilities that will be used to create a cache just after solving the model. Note that only PRW utilities with the extent set to "all" may be used - others will yield an error message 
		Params:
			attr (IFPrintResultsWizard): The name or ID of a name, or a pointer to a IFPrintResultsWizard object.
		Returns:
			None: 
		"""
		pass


	def deleteAll(self) -> None:
		r"""
		Call to delete all files belonging by this cache, reducing disk usage to zero 
		Returns:
			None: 
		"""
		pass


	def deleteForLoadset(self, ID, resFile=None, eigen=None, harm=None) -> None:
		r"""
		Call to delete all files containing cached results that belong to the given loadset 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name. // -1 means 'all loadcases'
			resFile (int, optional): default = 0   //
			eigen (int, optional): default = -1  // -1 means 'not an eigenvalue'
			harm (int, optional): default = -1  // -1 means 'not a harmonic'
		Returns:
			None: 
		"""
		pass


	def deleteForEntity(self, entity) -> None:
		r"""
		Call to delete all files containing cached results of the given results entity 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
		Returns:
			None: 
		"""
		pass


	def deleteForLocalCoord(self, localCoord) -> None:
		r"""
		Call to delete all files containing cached results that are transformed by the given local coordinate 
		Params:
			localCoord (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
		Returns:
			None: 
		"""
		pass


	def deleteForPath(self, path) -> None:
		r"""
		Call to delete all files containing cached results that are transformed by the given path 
		Params:
			path (IFReferencePath): The name or ID of a path, or a pointer to a IFReferencePath object.
		Returns:
			None: 
		"""
		pass


	def deleteForAveraging(self) -> None:
		r"""
		Call to delete all files containing averaged results 
		Returns:
			None: 
		"""
		pass


	def deleteForUDR(self) -> None:
		r"""
		Call to delete all files containing results that refers to user defined results 
		Returns:
			None: 
		"""
		pass


	def deleteNamedFile(self, filename) -> None:
		r"""
		Call to delete all files associated with the named header (contents) file 
		Params:
			filename (str): Name of the header file
		Returns:
			None: 
		"""
		pass


class IFDatabaseMember(IFDispatch):
	"""
	Base class for all objects that can live in a database. Although this object has no functionality, it acts as a convenient placeholder. All objects that can be present in a IFDatabase are derived from this one. 
	"""

	pass


class IFFileUtils(IFDispatch):
	"""
	Some basic file management utility functions 
	"""

	def deletePath(self, path) -> bool:
		r"""
		Delete an entire path, regardless of whether it is a file or a folder. Returns zero for success, non-zero in case of failure (e.g. permission denied, file in use, etc) 
		Params:
			path (str): 
		Returns:
			bool: 
		"""
		pass


	def deletePattern(self, pattern, foldersToo=None) -> None:
		r"""
		As IFFileUtils.deletePath, but allows standard Windows wildcard characters like * and ? 
		Params:
			pattern (str): 
			foldersToo (bool, optional): Default false, If false, folders will not be deleted
		Returns:
			None: 
		"""
		pass


	def tidyPath(self, fileName) -> str:
		r"""
		removes any double slashes from path names e.g. converts "F:\\a\b\\c" to "F:\a\b\c" Allows lazy concatenation of paths, and then a tidy at the end Safe to use for network UNC paths of the form \\machine\folder\test" 
		Params:
			fileName (str): 
		Returns:
			str: 
		"""
		pass


	def makePath(self, folder, name, ext=None) -> str:
		r"""
		concatenates the folder, filename and (optionally) extension together 
		Params:
			folder (str): The location folder
			name (str): The filename, with or without extension
			ext (str, optional): The extension
		Returns:
			str: 
		"""
		pass


	def imposeMaxPathLimit(self, folder) -> str:
		r"""
		Modifies the given path such that it complies with the Microsoft Windows limit of 248 characters 
		Params:
			folder (str): The filename to change
		Returns:
			str: 
		"""
		pass


	def directoryExists(self, folder) -> bool:
		r"""
		returns true if the given folder already exists 
		Params:
			folder (str): The folder to try
		Returns:
			bool: 
		"""
		pass


	def createDirectory(self, fileName, wasCreated=None) -> bool:
		r"""
		Attempts to create the given folder. If the folder already exists, does nothing. If given "wasCreated" is set to true if the folder was actually created, false if it already existed. Returns zero for success, non-zero in case of failure (e.g. permission denied, file in use, etc) 
		Params:
			fileName (str): The folder to create
			wasCreated (bool, optional): Was the file created?
		Returns:
			bool: 
		"""
		pass


	def testCreateFile(self, fileName, reportErr=None) -> bool:
		r"""
		Attempts to create the given file. If the file already exists, and can be modified, does nothing. If given "reportErr" is true, any errors are reported as popups. Returns zero for success, non-zero in case of failure (e.g. permission denied, file in use, etc) 
		Params:
			fileName (str): The filename to try
			reportErr (bool, optional): Default true. Report errors?
		Returns:
			bool: 
		"""
		pass


	def logicalDriveExists(self, driveLetter) -> bool:
		r"""
		Called with a single letter, such as "C" or "D", returns true if a logical drive already exists with that name 
		Params:
			driveLetter (str): 
		Returns:
			bool: 
		"""
		pass


	def fileExtensionIndex(self, fileName) -> int:
		r"""
		 returns -1 if: - given filename does not have 4 letter (or less) extension - OR extension has only numerical characters Location of '.' character before extension in string otherwise  Specifically returns: abcdef.vwxyz-> -1 (>4 letter extension taken as part of name) abcdef.html -> 6 abcdef.xyz  -> 6 abcdef.xy   -> 6 abcdef.x    -> 6 abcdef      -> -1 abc.def.xyz -> 7  
		Params:
			fileName (str): The filename to examine
		Returns:
			int: 
		"""
		pass


	def removeFileExtension(self, fileName) -> str:
		r"""
		Determines the extension of the given file (using the rules of IFFileUtils.fileExtensionIndex), and removes it 
		Params:
			fileName (str): The filename to change
		Returns:
			str: 
		"""
		pass


	def addFileExtension(self, fileName, newExtension, removeExisting=None, forceAdd=None) -> str:
		r"""
		Adds the given extension to the given file (optionally, unless it already has one, using the rules of IFFileUtils.fileExtensionIndex) 
		Params:
			fileName (str): The filename to change
			newExtension (str): The extension to use
			removeExisting (bool, optional): Default false. If the filename already has an extension, should it first be removed?
			forceAdd (bool, optional): Default false. If the filename already has an extension, should this one be appended anyway?
		Returns:
			str: 
		"""
		pass


	def copyFileExtension(self, fileToChange, fileToCopy, removeExisting=None) -> str:
		r"""
		Makes the given file have the same extension as the other given file (optionally, unless it already has one, using the rules of IFFileUtils.fileExtensionIndex) 
		Params:
			fileToChange (str): The filename to change
			fileToCopy (str): The file whose extension to use
			removeExisting (bool, optional): Default false. If the filename already has an extension, should it first be removed?
		Returns:
			str: 
		"""
		pass


	def getFileExtension(self, fileToChange) -> str:
		r"""
		Return the extension if the given file (using the rules of IFFileUtils.fileExtensionIndex) 
		Params:
			fileToChange (str): The filename to change
		Returns:
			str: 
		"""
		pass


	def splitFilename(self, fileName, path, base, extension) -> None:
		r"""
		Breaks the given filename into separate parts - location, base name, and extension 
		Params:
			fileName (str): The filename to change
			path (str): location
			base (str): name without location or extension
			extension (str): extension
		Returns:
			None: 
		"""
		pass


	def getAnalysisDelimiter(self) -> str:
		r"""
		Returns the character used to separate the model name from the analysis (currently ~) 
		Returns:
			str: 
		"""
		pass


	def addAnalysisExtrasToFilename(self, fileName, extra) -> str:
		r"""
		Append extra text to an analysis filename 
		Params:
			fileName (str): The filename to change
			extra (str): The extras to add
		Returns:
			str: 
		"""
		pass


	def analysisExtrasSafeFilename(self, fileName) -> str:
		r"""
		Given any filename, returns a filename that is safe to use within LUSAS Modeller Basically this means removal of characters that are not permitted by Windows 
		Params:
			fileName (str): 
		Returns:
			str: 
		"""
		pass


	def solverSafeFilename(self, fileName) -> str:
		r"""
		Given any filename, returns a filename that is safe to use within LUSAS Solver Basically this means removal of characters that are not permitted by Windows, plus spaces and most punctuation 
		Params:
			fileName (str): 
		Returns:
			str: 
		"""
		pass


	def combineModelAnalysis(self, folder, modelName, analysisName, extras) -> str:
		r"""
		Combine together a location, model name, analysis name and any extras into a single Windows path 
		Params:
			folder (str): 
			modelName (str): 
			analysisName (str): 
			extras (str): 
		Returns:
			str: 
		"""
		pass


	def splitModelAnalysis(self, fileName, model, analysis, extras) -> bool:
		r"""
		Separate a filename into location, model name, analysis name and any extras 
		Params:
			fileName (str): 
			model (str): 
			analysis (str): 
			extras (str): 
		Returns:
			bool: 
		"""
		pass


	def isFullPathName(self, fileName) -> bool:
		r"""
		Return true if the given filename is a full path, starting with a drive letter or UNC //. Return false for local paths 
		Params:
			fileName (str): 
		Returns:
			bool: 
		"""
		pass


	def getFullPathName(self, fileName, cwd=None, extension=None) -> str:
		r"""
		Convert the given local path into a full path, start with a drive letter or UNC //. The current working folder can be passed in, or will be assumed from the current model if not given The extension can be passed in, or will be assumed from the given filename if not given 
		Params:
			fileName (str): 
			cwd (str, optional): Current working directory. If not given, will be assumed from model.
			extension (str, optional): Extension. If not given, will be left unchanged.
		Returns:
			str: 
		"""
		pass


	def getRelativePathName(self, fileName, cwd=None) -> str:
		r"""
		Convert the given full path into a local path, relative to the current working directory. The current working folder can be passed in, or will be assumed from the current model if not given 
		Params:
			fileName (str): 
			cwd (str, optional): Current working directory. If not given, will be assumed from model.
		Returns:
			str: 
		"""
		pass


	def preparePath(self, fileName, cwd=None) -> str:
		r"""
		Prepare the given filename so as to be ready to show to the user. Normally, this is equivalent to calling both IFFileUtils.tidyPath and IFFileUtils.getFullPathName. When running the QA, it is equivalent to calling IFFileUtils.tidyPath and getRelativePathName 
		Params:
			fileName (str): 
			cwd (str, optional): Current working directory. If not given, will be assumed from model.
		Returns:
			str: 
		"""
		pass


	def pathAttributes(self, fileName, isDirectory, isFile, isWriteable) -> None:
		r"""
		Retrieve basic information about the given filename 
		Params:
			fileName (str): 
			isDirectory (bool): is it a folder?
			isFile (bool): is it a file?
			isWriteable (bool): is it writeable (i.e. not read only)?
		Returns:
			None: 
		"""
		pass


	def pathChecks(self, fileName, errorString) -> bool:
		r"""
		Equivalent to calling IFFileUtils.splitFilename, IFFileUtils.filenameChecks and IFFileUtils.dirnameChecks 
		Params:
			fileName (str): 
			errorString (str): 
		Returns:
			bool: 
		"""
		pass


	def filenameChecks(self, fileName, errorString) -> bool:
		r"""
		Function which will check for invalid characters in the given filename. Returns TRUE for failure (and errorString will be set) Returns FALSE for acceptable (and errorString will be left unchanged) 
		Params:
			fileName (str): 
			errorString (str): 
		Returns:
			bool: 
		"""
		pass


	def dirnameChecks(self, fileName, errorString) -> bool:
		r"""
		Function which will check for invalid characters in the given folder. Returns TRUE for failure (and errorString will be set) Returns FALSE for acceptable (and errorString will be left unchanged) 
		Params:
			fileName (str): 
			errorString (str): 
		Returns:
			bool: 
		"""
		pass


	def createShortCut(self, targetFile, targetArgs, linkFile, description, showMode, workingDirectory, iconfile, iconIndex) -> None:
		r"""
		Creates the actual 'lnk' file needed to create a Windows shortcut 
		Params:
			targetFile (str): File name of the link's target.
			targetArgs (str): Command line arguments passed to link's target.
			linkFile (str): File name of the actual link file being created.
			description (str): Description of the linked item.
			showMode (int): ShowWindow() constant for the link's target.
			workingDirectory (str): Working directory of the active link.
			iconfile (str): File name of the icon file used for the link.
			iconIndex (int): Index of the icon in the icon file.
		Returns:
			None: 
		"""
		pass


	def makeFileWriteable(self, path) -> bool:
		r"""
		Remove the read-only property of the given file, if present 
		Params:
			path (str): 
		Returns:
			bool: 
		"""
		pass


	def makeDirWriteable(self, path, recurseFiles=None, recurseDirs=None) -> bool:
		r"""
		Remove the "read-only" property of the given folder, if present. Optionally recurses to child folders and child files. 
		Params:
			path (str): 
			recurseFiles (bool, optional): Default false. If given, recursively apply the change to all child files too
			recurseDirs (bool, optional): Default false. If given, recursively apply the change to all child folders too
		Returns:
			bool: 
		"""
		pass


	def copyDirectory(self, sourceFolder, destinationFolder) -> None:
		r"""
		Recursively copy an entire folder structure 
		Params:
			sourceFolder (str): 
			destinationFolder (str): 
		Returns:
			None: 
		"""
		pass


	def setFileHidden(self, path, setHidden=None) -> bool:
		r"""
		Set the "hidden" property of the given file to true or false 
		Params:
			path (str): 
			setHidden (bool, optional): Default true. Can be specified as false to make the file unhidden.
		Returns:
			bool: 
		"""
		pass


class IFPolylineDefn(IFDispatch):
	"""
	A line defined by any number of connected line definitions 
	"""

	def setFacetData(self, minTotalNumber, minNumberPerLine, maxSeparation, maxAngleDegrees, maxFacetLength) -> int:
		r"""
		Set up the tendon faceting data 
		Params:
			minTotalNumber (int): minimum total number of facets for the whole tendon
			minNumberPerLine (int): minimum number of facets for any defining line of the tendon
			maxSeparation (float): maximum allowable separation from any facet to the true tendon shape
			maxAngleDegrees (float): maximum allowable angular change between any adjacent facets
			maxFacetLength (float): maximum allowable facet length
		Returns:
			int: 0 for success, non-zero for failure. Specifically, -1 for 'min radius too big', -2 for 'adjacent coincident coords'
		"""
		pass


	def getFacetData(self, minTotalNumber, minNumberPerLine, maxSeparation, maxAngleDegrees, maxFacetLength) -> None:
		r"""
		Return the current tendon faceting data 
		Params:
			minTotalNumber (int): minimum total number of facets for the whole tendon
			minNumberPerLine (int): minimum number of facets for any defining line of the tendon
			maxSeparation (float): maximum allowable separation from any facet to the true tendon shape
			maxAngleDegrees (float): maximum allowable angular change between any adjacent facets
			maxFacetLength (float): maximum allowable facet length
		Returns:
			None: 
		"""
		pass


	def getSmoothingData(self, enabled, radius, filletType) -> None:
		r"""
		Return the current smoothing data 
		Params:
			enabled (bool): current on/off state as set by IFPolylineDefn.setSmoothing
			radius (float): radius as set by IFPolylineDefn.setFilletRadius
			filletType (int): fillet type as by IFPolylineDefn.setFilletType
		Returns:
			None: 
		"""
		pass


	def setSmoothing(self, enabled) -> None:
		r"""
		Switch corner smoothing on and off 
		Params:
			enabled (bool): 
		Returns:
			None: 
		"""
		pass


	def setFilletRadius(self, radius) -> None:
		r"""
		Set the minimum radius in current model length units 
		Params:
			radius (float): 
		Returns:
			None: 
		"""
		pass


	def setFilletType(self, filletType, pArcToSpline=None) -> None:
		r"""
		Set the type of smoothing - either 0 = 'inside fillet' = 'cut corner' or 1 = 'outside fillet' = 'adjust lines' 
		Params:
			filletType (int): smoothing type
			pArcToSpline (bool, optional): whether or not to convert arcs to spline pre-filleting, only valid for 'adjust lines'
		Returns:
			None: 
		"""
		pass


	def makeSymmetric(self, xPerp, yPerp, zPerp, atEnd) -> None:
		r"""
		Mirror the tendon profile given the perpendicular to the plane and flag indicating either the start to end of the profile 
		Params:
			xPerp (float): 
			yPerp (float): 
			zPerp (float): 
			atEnd (bool): 
		Returns:
			None: 
		"""
		pass


	def hasSplines(self) -> bool:
		r"""
		Return true if this polyline has at least one spline 
		Returns:
			bool: 
		"""
		pass


	def countLines(self) -> int:
		r"""
		Return the number of lines defining this polyline 
		Returns:
			int: Number of defining lines
		"""
		pass


	def addStraightV(self, xStart, yStart, zStart, xEnd, yEnd, zEnd) -> int:
		r"""
		Add straight line to tendon 
		Params:
			xStart (float): 
			yStart (float): 
			zStart (float): 
			xEnd (float): 
			yEnd (float): 
			zEnd (float): 
		Returns:
			int: 
		"""
		pass


	def copy(self, pToCopy) -> None:
		r"""
		Create a copy of this polyline 
		Params:
			pToCopy (IFPolylineDefn): 
		Returns:
			None: 
		"""
		pass


	def getStartCoord(self, xStart, yStart, zStart) -> None:
		r"""
		Returns the first coordinate in the polyline 
		Params:
			xStart (float): 
			yStart (float): 
			zStart (float): 
		Returns:
			None: 
		"""
		pass


	def getEndCoord(self, xEnd, yEnd, zEnd) -> None:
		r"""
		Returns the last coordinate in the polyline, "addArcCentreV" will adjust the last coordinate if the radius is different from the start coord 
		Params:
			xEnd (float): 
			yEnd (float): 
			zEnd (float): 
		Returns:
			None: 
		"""
		pass


	def start2Sets2dDefn(self, lineType, projectionAngleDegs, rotationAngleDegs, filletType) -> IFPolylineDefn:
		r"""
		Declare the start of a polyline defined by two sets of 2D coordinates 
		Params:
			lineType (str): Line type "straight" or "spline"
			projectionAngleDegs (float): Projection angle
			rotationAngleDegs (float): Rotation angle
			filletType (str): Fillet type, "none", "inside", or "outside"
		Returns:
			IFPolylineDefn: 
		"""
		pass


	def end2Sets2dDefn(self, errorCode=None) -> IFPolylineDefn:
		r"""
		Declare the end of a polyline defined by two sets of 2D coordinates 
		Params:
			errorCode (int, optional): Error code 0 = valid definition, 1 = no definition data defined 2 = error defining spline 3 = error defining straight lines 4 = error during filleting all other values = error
		Returns:
			IFPolylineDefn: 
		"""
		pass


	def add2dCrdsToSet(self, whichSet, type1, crd1, type2, crd2, radius) -> IFPolylineDefn:
		r"""
		Add coordinates to a polyline defined by two sets of 2D coordinates 
		Params:
			whichSet (int): 1 = first set of 2D coordinates, 2 = second set of 2D coordinates
			type1 (str): Coordinate type, "x", "y", "z"
			crd1 (float): Coordinate value corresponding to type1
			type2 (str): Coordinate type, "x", "y", "z"
			crd2 (float): Coordinate value corresponding to type2
			radius (float): Fillet radius
		Returns:
			IFPolylineDefn: 
		"""
		pass


	def is2sets2dCoords(self) -> bool:
		r"""
		Return true if this polyline was defined by two sets of 2D coordinates 
		Returns:
			bool: 
		"""
		pass


	def getSingleSet2dDlgCoords(self, whichSet, CrdIdx1, CrdIdx2, Coords) -> int:
		r"""
		Return one or other set of coordinates from a polyline defined by two sets of 2D coordinates 
		Params:
			whichSet (int): 1 = first set of 2D coordinates, 2 = second set of 2D coordinates
			CrdIdx1 (int): First coordinate type 1 = x, 2 = y, 3 = z
			CrdIdx2 (int): Second coordinate type 1 = x, 2 = y, 3 = z
			Coords (int): Coordinate data (first coord, second coord, fillet radius), repeat, ...
		Returns:
			int: Error code 0 = no error, -1 = no coordinates all other values = error
		"""
		pass


	def get2Sets2dAngle(self, projectionAngleDegs, rotationAngleDegs) -> None:
		r"""
		Return the projection and rotation angles for a polyline defined by 2 sets of 2d coords 
		Params:
			projectionAngleDegs (float): Projection angle in degrees
			rotationAngleDegs (float): Rotation angle in degrees
		Returns:
			None: 
		"""
		pass


	def set2Sets2dVertical(self, whichSet) -> IFPolylineDefn:
		r"""
		Function to define which of the 2 sets of 2d coords is the vertical set w.r.t the projection angle 
		Params:
			whichSet (int): 1 = first set of 2D coordinates, 2 = second set of 2D coordinates
		Returns:
			IFPolylineDefn: 
		"""
		pass


	def set2dMinimumRadius(self, minimumRadius) -> IFPolylineDefn:
		r"""
		set the 2d polyline minimum fillet radius 
		Params:
			minimumRadius (float): 
		Returns:
			IFPolylineDefn: 
		"""
		pass


	def getLength(self) -> float:
		r"""
		get the total length of the polyline 
		Returns:
			float: length of polyline
		"""
		pass


	def getInterpolatedPosition(self, nrmCoord) -> list[float]:
		r"""
		Return the coordinates at the given normalised coordinate, nrmCoord=0.0 at the polyline start nrmCoord=1.0 at the polyline end 
		Params:
			nrmCoord (float): normalised coord
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates location on polyline
		"""
		pass


	def getInterpolatedTangent(self, nrmCoord) -> list[float]:
		r"""
		Return the tangent at the given normalised coordinate, nrmCoord=0.0 at the polyline start nrmCoord=1.0 at the polyline end 
		Params:
			nrmCoord (float): normalised coord
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates tangent to polyline
		"""
		pass


	def getInterpolatedAxes(self, nrmCoord, pOrigin, pxAxis, pyAxis, pzAxis) -> None:
		r"""
		get the axes at the given normalised coordinate, nrmCoord=0.0 at the polyline start nrmCoord=1.0 at the polyline end 
		Params:
			nrmCoord (float): specified normalised coord
			pOrigin (array of float): An array of 3 real numbers, representing 3d coordinates location
			pxAxis (array of float): An array of 3 real numbers, representing 3d coordinates x axis
			pyAxis (array of float): An array of 3 real numbers, representing 3d coordinates y axis
			pzAxis (array of float): An array of 3 real numbers, representing 3d coordinates z axis
		Returns:
			None: 
		"""
		pass


	def getRadiusOfCurvature(self, nrmCoord, pPointOnLine, pCentreOfCurvature, pRadiusOfCurvature) -> int:
		r"""
		calculate the centre and radius of curvature at the given normalised coordinate along this polyline nrmCoord=0.0 at the polyline start nrmCoord=1.0 at the polyline end 
		Params:
			nrmCoord (float): specified normalised coord
			pPointOnLine (array of float): coordinates of the point on this line
			pCentreOfCurvature (array of float): coordinates of the centre of curvature
			pRadiusOfCurvature (float): radius of curvature
		Returns:
			int: on exit, 0 = success, -1 = very large radius, all other values = error
		"""
		pass


class IFProject(IFDispatch):
	"""
	Methods available on Project object 
	"""

	def getGoverningModel(self) -> IFDatabase:
		r"""
		Return the model which controls all sub-models in the project 
		Returns:
			IFDatabase: 
		"""
		pass


	def addSubModel(self, name) -> IFDatabase:
		r"""
		Create, attach, and return a new sub-model within this project. The name given will appear in the analysis treeview, and is also used by IFProject.getDatabaseByName 
		Params:
			name (str): name shown in the treeview
		Returns:
			IFDatabase: 
		"""
		pass


	def removeSubModel(self, db) -> None:
		r"""
		Remove a sub-model from this project. The sub-model must have been previously added with IFProject.addSubModel. It is not possible to remove the governing model. 
		Params:
			db (IFDatabase): The name or ID of a database, or a pointer to a IFDatabase object.
		Returns:
			None: 
		"""
		pass


	def getSubModels(self) -> list:
		r"""
		Return an array of all sub-models in this project 
		Returns:
			Array: Array of database objects
		"""
		pass


	def getDatabaseByName(self, name) -> IFDatabase:
		r"""
		Return a database by name 
		Params:
			name (str): 
		Returns:
			IFDatabase: 
		"""
		pass


	def existsDatabaseByName(self, name) -> bool:
		r"""
		Return whether or not a database exists with the name given 
		Params:
			name (str): 
		Returns:
			bool: 
		"""
		pass


	def setCurrentDatabase(self, db) -> None:
		r"""
		Set the given database as "current", so that IFModeller.database will return it The "current" database can also be set implicitly via IFView.setCurrent and IFView.setActiveLoadcase 
		Params:
			db (IFDatabase): The name or ID of a database, or a pointer to a IFDatabase object.
		Returns:
			None: 
		"""
		pass


	def close(self) -> None:
		r"""
		Close this project without saving changes. (Use IFModeller.project.IFProject.save first.) 
		Returns:
			None: 
		"""
		pass


	def save(self) -> None:
		r"""
		Save the project to disk. 
		Returns:
			None: 
		"""
		pass


	def saveAs(self, filename) -> None:
		r"""
		As IFProject.save but allows specification of a new name for the project 
		Params:
			filename (str): The path and name of the project file
		Returns:
			None: 
		"""
		pass


	def overrideSystemString(self, token, value) -> None:
		r"""
		Allows you to override a standard LUSAS system string for this model only. The values of system strings should never be changed without instruction from LUSAS technical support. To remove an override that was previously set, use an empty string as the value. To set the override value to be an empty string, use a single space. To obtain the current value of a system string, use IFModeller.getSystemString. To override a standard LUSAS system string for all models, use IFModeller.setSystemString 
		Params:
			token (str): internal name of the file to be overriden
			value (str): path to the file that should be used instead
		Returns:
			None: 
		"""
		pass


	def addFileToProjectFile(self, path, key) -> None:
		r"""
		Add a file which will be included within the project file when it is saved. The file must be within the LUSASFiles32 folder and will be reinstated when the project is reopened. 
		Params:
			path (str): Absolute file path
			key (str): Category of file
		Returns:
			None: 
		"""
		pass


	def removeFileFromProjectFile(self, path, key, deleteFile=None) -> None:
		r"""
		Remove a file previously added using addFileToProjectFile from the project file. The file must be within the LUSASFiles32 folder. 
		Params:
			path (str): Absolute file path
			key (str): Category of file
			deleteFile (bool, optional): If True, the file will be deleted from the disk as well as being removed. Default value is False
		Returns:
			None: 
		"""
		pass


	def listFilesInProjectFile(self, key) -> object:
		r"""
		Lists the files that are to be saved inside the project file having previously been added using addFileToProjectFile. 
		Params:
			key (str): Category of file
		Returns:
			object: Array of filenames
		"""
		pass


	def solveAllAnalyses(self, ignoreModified=None) -> int:
		r"""
		Tabulate and solve all analyses that need it, in the order that LUSAS believes best. If you set ignoreModified to be true, then LUSAS's internal knowledge is ignored, and all analyses will be solved whether LUSAS thinks it necessary or not. Returns 0 if all analyses solved successfully. If one or more analyses fail to solve, a failure code from LUSAS solver will be returned from the first to fail. 
		Params:
			ignoreModified (bool, optional): default false. Can be set true to ignore the modification state of each analysis
		Returns:
			int: 
		"""
		pass


	def openAllResults(self, scanOutputFiles=None, skipOutOfDate=None) -> None:
		r"""
		Open all results for all analyses Optionally (default true) skip any results that LUSAS considers to be out of date 
		Params:
			scanOutputFiles (bool, optional): default true. Can be set false to skip parsing output files and repeating errors and warnings into the text output window
			skipOutOfDate (bool, optional): default true. Can be set false to force LUSAS to load results files it believes to be out of date
		Returns:
			None: 
		"""
		pass


	def deleteAllSolverFiles(self, datFileToo=None) -> None:
		r"""
		Delete all of the files created by solver for all analyses Typically, this is dat, mys, out, log, his, dtf and rst files 
		Params:
			datFileToo (bool, optional): default true. Can be set false to skip deleting the dat file (it is often desirable to keep this one file)
		Returns:
			None: 
		"""
		pass


	def closeAllResults(self) -> None:
		r"""
		Close all results files 
		Returns:
			None: 
		"""
		pass


	def getReadOnly(self) -> bool:
		r"""
		Returns the state of the read-only check box on the file open dialog when this project was first opened. 
		Returns:
			bool: 
		"""
		pass


class IFReportChapter(IFDispatch):
	"""
	Represents a single chapter in a IFReport. Derived classes can represent geometry, attributes, results or user content. Each chapter has a name and a position in the IFReport 
	"""

	def setName(self, name) -> None:
		r"""
		Sets the name of this chapter 
		Params:
			name (str): 
		Returns:
			None: 
		"""
		pass


	def setTitle(self, title) -> None:
		r"""
		Sets the title of this chapter. That would be the text as appeared in table of contents and at the top of the page. 
		Params:
			title (str): 
		Returns:
			None: 
		"""
		pass


	def setDecimalPlaces(self, nDecimalPlaces) -> IFReportChapter:
		r"""
		Sets this chapter to use the specified number of decimal places to display real numbers 
		Params:
			nDecimalPlaces (int): number of decimal places
		Returns:
			IFReportChapter: 
		"""
		pass


	def setSigFig(self, nSigFig, trailingZeros=None) -> IFReportChapter:
		r"""
		Sets this chapter to use the specified number of significant figures to display real numbers 
		Params:
			nSigFig (int): number of significant figures
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			IFReportChapter: 
		"""
		pass


	def setThreshold(self, value) -> IFReportChapter:
		r"""
		Set a threshold value in order for all values that are less than this to be printed as zero. If the value is given as 'nothing' no threshold value is taken into account. 
		Params:
			value (float): or Nothing
		Returns:
			IFReportChapter: 
		"""
		pass


	def setChapterExtent(self, selectionType, groupName=None) -> None:
		r"""
		Sets the model selection type for this chapter 
		Params:
			selectionType (str): selection type (all/visible/group)
			groupName (str, optional): optional only if not group type
		Returns:
			None: 
		"""
		pass


	def addLoadcase(self, ID, resFile=None, eigen=None, harm=None) -> None:
		r"""
		Adds a loadcase to be reported upon 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			None: 
		"""
		pass


	def setLoadcaseSelectionType(self, loadcaseSelection) -> None:
		r"""
		Sets whether the chapter is for all the loadcases or envelopes or smart combinations that are in the model 
		Params:
			loadcaseSelection (str): 
		Returns:
			None: 
		"""
		pass


	def resetSelectedLoadcases(self) -> None:
		r"""
		removes all the loadcases that have been added via IFReportChapter.addLoadcase 
		Returns:
			None: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Gets the name of this chapter 
		Returns:
			str: 
		"""
		pass


	def getTitle(self) -> str:
		r"""
		Gets the title of this chapter 
		Returns:
			str: 
		"""
		pass


	def getReport(self) -> IFReport:
		r"""
		Gets the parent report of this chapter 
		Returns:
			IFReport: 
		"""
		pass


	def getPrecision(self, isDecimalPlaces, precision) -> None:
		r"""
		Returns both the mode and precision used to display real numbers in this chapter. Real numbers can either be displayed in a fixed number of decimal places or a fixed number of significant figures. If IFReport.setPrecisionForAll has been used on the parent report, then this function will return the precision specified for the parent report, rather than any values previously set for this chapter 
		Params:
			isDecimalPlaces (bool): Returned TRUE for decimal places, FALSE for significant figures
			precision (int): Number of DP or SF as appropriate
		Returns:
			None: 
		"""
		pass


	def getChapterExtent(self, selectionType, groupName) -> None:
		r"""
		Gets the model selection type for this chapter 
		Params:
			selectionType (str): selection type (all/visible/group)
			groupName (str): Name of string (only if type is group)
		Returns:
			None: 
		"""
		pass


	def getLoadcases(self) -> list:
		r"""
		Gets the list of loadcases to be reported upon. Note that any loadcases previously specified, but not currently present (e.g. if results are not loaded) will not be in the returned array, but will still form part of the chapter 
		Returns:
			Array: Array of loadcase objects
		"""
		pass


	def setAppendToPrevChapter(self, isAppend) -> None:
		r"""
		If true, this chapter hides its title, and suppresses its page break, and does not write itself into the table of contents - thus giving the appearance, to the reader, that it is part of the previous chapter 
		Params:
			isAppend (bool): else behave as normal
		Returns:
			None: 
		"""
		pass


	def setPrimaryComponent(self, entity, component) -> None:
		r"""
		Set the primary component to be used when in the selected loadcases are included envelopes or smart combinations 
		Params:
			entity (str): 
			component (str): 
		Returns:
			None: 
		"""
		pass


class IFCustomSubReport(IFDispatch):
	"""
	Represents a sub report that can be customised by the user in order to be included in the main report 
	"""

	def addText(self, section, left, top, text) -> None:
		r"""
		Adds text in the given section in the report. Positioning is relative to the previous text or image that was added. 
		Params:
			section (str): "Header", "Details", "Footer".
			left (int): Additional left positioning from the previous text that was added at the same line. Set -1 for the text to be placed in center
			top (int): Additional top positioning from the previous text or image that was added.
			text (str): Text to be added
		Returns:
			None: 
		"""
		pass


	def setTrailingText(self, section, top, text) -> None:
		r"""
		Sets the text that always goes at the end of the giving section. This text is wrapped, always positioning at left and can be a single string or an array of strings. 
		Params:
			section (str): "Header", "Details", "Footer".
			top (int): Additional top positioning from the previous text or image that was added.
			text (array of strs): 
		Returns:
			None: 
		"""
		pass


	def addImage(self, section, left, top, image, autoDelete=None) -> None:
		r"""
		Adds an image in the given section in the report. Positioning is relative to the previous text or image that was added Always goes to a new line 
		Params:
			section (str): "Header", "Details", "Footer".
			left (int): Left positioning. Set -1 for the image to be placed in center
			top (int): Additional top positioning from the previous text or image that was added.
			image (str): Path of the image file
			autoDelete (bool, optional): If True, the image file will be deleted from the hard drive when the report has created. Deafult value is False.
		Returns:
			None: 
		"""
		pass


	def newLine(self, section, lines=None) -> None:
		r"""
		Adds a number of void lines from the previous text that has been added. If no text has previsously been added no lines will be added. 
		Params:
			section (str): "Header", "Details", "Footer".
			lines (int, optional): Number of lines to be added. Default = 1.
		Returns:
			None: 
		"""
		pass


	def setStyle(self, style) -> None:
		r"""
		Set the style for the text that will follow. The style names and their properties are defined in an external file at "%Scripts%\\Report\\Configuration.xml". 
		Params:
			style (str): 
		Returns:
			None: 
		"""
		pass


	def createTable(self, top) -> None:
		r"""
		Creates a table which properties and data need to be set via IFCustomSubReport.addTableHeader, IFCustomSubReport.addTableRowData 
		Params:
			top (int): Additional top positioning from the last text that was added in the header section.
		Returns:
			None: 
		"""
		pass


	def addTableHeader(self, text, width) -> None:
		r"""
		Go to the next line(s) at the given section 
		Params:
			text (str): Header text
			width (int float): Table width. If given as integer it will be tha absolute width (setting this to zero will auto adjust it). If given as double it will be the percentage of the total table width
		Returns:
			None: 
		"""
		pass


	def addTableRowData(self, data) -> None:
		r"""
		Adds data in the next table row. Be aware that the number of strings in the given data should be equal with the number of headers. No warning will be shown if this is not the case but eventually the table will not be shown in reports. 
		Params:
			data (array of strs): 
		Returns:
			None: 
		"""
		pass


	def addOutOfDateWarning(self) -> None:
		r"""
		Adds the caption "Model needs solving. Results are out of date." 
		Returns:
			None: 
		"""
		pass


class IFReport(IFDispatch):
	"""
	Report class 
	"""

	def setName(self, name) -> IFReport:
		r"""
		Sets the name of the report 
		Params:
			name (str): report name
		Returns:
			IFReport: 
		"""
		pass


	def setTitle(self, title) -> IFReport:
		r"""
		Sets the title of the report 
		Params:
			title (str): report title
		Returns:
			IFReport: 
		"""
		pass


	def setDecimalPlaces(self, nDecimalPlaces) -> IFReport:
		r"""
		Sets this report to use the specified number of decimal places to display real numbers 
		Params:
			nDecimalPlaces (int): number of decimal places
		Returns:
			IFReport: 
		"""
		pass


	def setSigFig(self, nSigFig, trailingZeros=None) -> IFReport:
		r"""
		Sets the number of significant figures in the report 
		Params:
			nSigFig (int): number of significant figures
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			IFReport: 
		"""
		pass


	def setThreshold(self, value) -> IFReport:
		r"""
		Set a threshold value in order for all values that are less than this to be printed as zero. If the value is given as 'nothing' no threshold value is taken into account. 
		Params:
			value (float): or Nothing
		Returns:
			IFReport: 
		"""
		pass


	def addAttributeChapter(self, chapterName, nSigFig, type, position=None) -> IFReportChapter:
		r"""
		Adds an attribute chapter in the report 
		Params:
			chapterName (str): chapter name
			nSigFig (int): number of significant figures for this chapter
			type (str): dataset type(e.g mesh/material, etc)
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFReportChapter: 
		"""
		pass


	def addGeometryChapter(self, chapterName, nSigFig, type, position=None) -> IFReportChapter:
		r"""
		Adds a geometry chapter in the report 
		Params:
			chapterName (str): chapter name
			nSigFig (int): number of significant figures for this chapter
			type (str): geometry type(e.g point/line, etc)
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFReportChapter: 
		"""
		pass


	def addLoadsetChapter(self, chapterName, nSigFig, type, position=None) -> IFReportChapter:
		r"""
		Adds a loadset chapter in the report 
		Params:
			chapterName (str): chapter name
			nSigFig (int): number of significant figures for this chapter
			type (str): loadset type (e.g loadcase/envelope, etc)
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFReportChapter: 
		"""
		pass


	def addResultsChapter(self, chapterName, nSigFig=None, orderBy=None, position=None) -> IFResultsChapter:
		r"""
		Adds a result chapter in the report 
		Params:
			chapterName (str): chapter name
			nSigFig (int, optional): number of significant figures for this chapter
			orderBy (str, optional): order (e.g. by loadcase/feature, etc)
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFResultsChapter: 
		"""
		pass


	def addAnalysisTypeResultsChapter(self, chapterName, nSigFig=None, position=None, analysisType=None) -> IFResultsChapter:
		r"""
		Adds a result chapter in the report 
		Params:
			chapterName (str): chapter name
			nSigFig (int, optional): number of significant figures for this chapter
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
			analysisType (str, optional): analysis type e.g. "Eigenvalue"
		Returns:
			IFResultsChapter: 
		"""
		pass


	def addImageContentChapter(self, chapterName, fileName, caption=None, position=None) -> IFReportChapter:
		r"""
		Adds in the report a report chapter that is associated with an image 
		Params:
			chapterName (str): chapter name
			fileName (str): image file name
			caption (str, optional): caption to display below image
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFReportChapter: 
		"""
		pass


	def addTextContentChapter(self, chapterName, fileName, caption=None, position=None) -> IFReportChapter:
		r"""
		Adds in the report a report chapter that is associated with an text file 
		Params:
			chapterName (str): chapter name
			fileName (str): image file name
			caption (str, optional): caption to display below image
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFReportChapter: 
		"""
		pass


	def deleteChapter(self, chapterName) -> None:
		r"""
		Deletes a chapter 
		Params:
			chapterName (str): chapter name to be deleted
		Returns:
			None: 
		"""
		pass


	def moveChapter(self, chapterToMove, chapterToMoveAfter) -> None:
		r"""
		Moves a chapter 
		Params:
			chapterToMove (str): chapter name to be moved
			chapterToMoveAfter (str): chapter name to move after
		Returns:
			None: 
		"""
		pass


	def moveChapterFirst(self, chapterToMove) -> None:
		r"""
		Moves a chapter as the first chapter in the report 
		Params:
			chapterToMove (str): chapter name to be moved
		Returns:
			None: 
		"""
		pass


	def getChapter(self, name) -> IFReportChapter:
		r"""
		Returns a report chapter 
		Params:
			name (str): chapter name
		Returns:
			IFReportChapter: 
		"""
		pass


	def setPageSize(self, paperSize, isPageLandscape, left, bottom, right, top) -> None:
		r"""
		Specifies the size of paper, and margins, that will be used to print the report 
		Params:
			paperSize (int): paper size(9 for A4, 8 for A3, etc)
			isPageLandscape (bool): true if the orientation is landscape
			left (int): left margin (in mm)
			bottom (int): bottom margin (in mm)
			right (int): right margin (in mm)
			top (int): top margin (in mm)
		Returns:
			None: 
		"""
		pass


	def exportFile(self, fileName, format=None) -> None:
		r"""
		Exports the report to a file of the specified format If the format is not specified then the format will be taken from the file extension. 
		Params:
			fileName (str): 
			format (str, optional): (e.g "rtf" or "xls"); if not specified, format will be taken after file extension
		Returns:
			None: 
		"""
		pass


	def setPrecisionForAll(self, isForAll) -> None:
		r"""
		Specifies the size of paper, and margins, that will be used to print the report 
		Params:
			isForAll (bool): true to force the nr of sig. fig to be the same for all the chapters
		Returns:
			None: 
		"""
		pass


	def createCopy(self) -> IFReport:
		r"""
		Creates a copy of this report and adds it to the panel. Chapters will be copied as well. 
		Returns:
			IFReport: the new report that has been created
		"""
		pass


	def addGraphChapter(self, chapterName, graph, position=None, isAppend=None) -> IFReportChapter:
		r"""
		Adds a graph chapter in the report 
		Params:
			chapterName (str): chapter name
			graph (IFGraphWizard): The name or ID of a graphWizard, or a pointer to a IFGraphWizard object.
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
			isAppend (bool, optional): If false (the default), adds a normal chapter. If true, appends the contents of this chapter to the previous chapter.
		Returns:
			IFReportChapter: 
		"""
		pass


	def addSavedViewChapter(self, chapterName, modelView, position=None, isAppend=None) -> IFReportChapter:
		r"""
		Adds a chapter with a model view in the report 
		Params:
			chapterName (str): chapter name
			modelView (IFSavedView): The name or ID of a modelView, or a pointer to a IFSavedView object.
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
			isAppend (bool, optional): If false (the default), adds a normal chapter. If true, appends the contents of this chapter to the previous chapter.
		Returns:
			IFReportChapter: 
		"""
		pass


	def addNoteChapter(self, chapterName, modelView, position=None, isAppend=None) -> IFReportChapter:
		r"""
		Adds a chapter with a note in the report 
		Params:
			chapterName (str): chapter name
			modelView (IFNote): The name or ID of a note, or a pointer to a IFNote object.
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
			isAppend (bool, optional): If false (the default), adds a normal chapter. If true, appends the contents of this chapter to the previous chapter.
		Returns:
			IFReportChapter: 
		"""
		pass


	def show(self) -> None:
		r"""
		Shows the report in the report viewer dialog. 
		Returns:
			None: 
		"""
		pass


	def addOneClickReportChapter(self, chapterName, position=None, isAppend=None) -> IFReportChapter:
		r"""
		Adds a one-click report chapter in the report. 
		Params:
			chapterName (str): chapter name
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
			isAppend (bool, optional): If false (the default), adds a normal chapter. If true, appends the contents of this chapter to the previous chapter.
		Returns:
			IFReportChapter: 
		"""
		pass


	def setPageBreak(self, isPageBreak) -> None:
		r"""
		If set to True, each chapter will be shown in a new page. 
		Params:
			isPageBreak (bool): True for each chapter to be shown in a new page.
		Returns:
			None: 
		"""
		pass


	def setFrontPageView(self, savedView) -> IFReport:
		r"""
		Adds a saved view in the report's front page. Pass "Nothing" for no view in the front page. 
		Params:
			savedView (name, id, IFSavedView): , the saved view
		Returns:
			IFReport: 
		"""
		pass


	def addCustomChapter(self, chapterName, position=None, isAppend=None) -> IFCustomChapter:
		r"""
		Adds a custom report chapter in the report. 
		Params:
			chapterName (str): chapter name
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
			isAppend (bool, optional): If false (the default), adds a normal chapter. If true, appends the contents of this chapter to the previous chapter.
		Returns:
			IFCustomChapter: 
		"""
		pass


	def isPageBreak(self) -> bool:
		r"""
		Returns the flag previously set with IFReport.setPageBreak 
		Returns:
			bool: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns the name of the report 
		Returns:
			str: 
		"""
		pass


	def getTitle(self) -> str:
		r"""
		Returns the title of the report 
		Returns:
			str: 
		"""
		pass


	def getUnits(self) -> IFUnitSet:
		r"""
		Returns the units of the report 
		Returns:
			IFUnitSet: 
		"""
		pass


	def getPrecision(self, isDecimalPlaces, precision) -> None:
		r"""
		Returns both the mode and precision used to display real numbers in this report. Real numbers can either be displayed in a fixed number of decimal places or a fixed number of significant figures. Note that unless IFReport.setPrecisionForAll has been used, individual chapters may have their own overriding values. 
		Params:
			isDecimalPlaces (bool): Returned 1 for decimal places, 0 for significant figures (no trailing), 2 for significant figures (with trailing)
			precision (int): Number of DP or SF as appropriate
		Returns:
			None: 
		"""
		pass


	def getThreshold(self, pRetval) -> None:
		r"""
		Return the threshold value previously set using IFReport.setThreshold A value of 'nothing' may be returned if no threshold is set 
		Params:
			pRetval (float): 
		Returns:
			None: 
		"""
		pass


	def addModuleChapter(self, chapterName, moduleName, position=None) -> IFReportChapter:
		r"""
		Adds a report chapter int the report whose contents will be defined by a LUSAS module. 
		Params:
			chapterName (str): chapter name
			moduleName (str): module name
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFReportChapter: 
		"""
		pass


	def addPrestressChapter(self, chapterName, position=None) -> IFPrestressChapter:
		r"""
		Adds the prestress results chapter in the report 
		Params:
			chapterName (str): chapter name
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFPrestressChapter: 
		"""
		pass


	def addCableTuningTargetsResultsChapter(self, chapterName, position=None) -> IFCableTuningTargetsResultsChapter:
		r"""
		Adds a result chapter in the report 
		Params:
			chapterName (str): chapter name
			position (int, optional): position where this chapter will be added; if not specified, will be added at the end
		Returns:
			IFCableTuningTargetsResultsChapter: 
		"""
		pass


class IFAttribute(IFDispatch):
	"""
	Base class for all attributes. 
	"""

	def update(self) -> None:
		r"""
		For use by script programmers. If an attribute is edited in a script, e.g. by calling IFAttribute.setValue), Modeller must be informed when editing is over, so that it can adjust internal cached data to suit. If this is not done, visualisation and tabulation will continue to use the old values until some other event (e.g. mesh reset) causes this cached data to be reset. 
		Returns:
			None: 
		"""
		pass


	def getPen(self) -> int:
		r"""
		 
		Returns:
			int: 
		"""
		pass


	def setPen(self, pen) -> IFAttribute:
		r"""
		Changes the pen with which this attribute draws its on-screen visualisation, e.g. arrows, symbols etc. The pen ID indicates a pen in the pen library. This allows you to create plots where particular attributes stand out in a different colour. 
		Params:
			pen (int): pen number
		Returns:
			IFAttribute: 
		"""
		pass


	def setName(self, name) -> None:
		r"""
		Set the name of this attribute 
		Params:
			name (str): 
		Returns:
			None: 
		"""
		pass


	def setEditDialog(self, filename) -> None:
		r"""
		Set name of dialog used to edit this attribute when the "Edit Attribute..." context menu is chosen.This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFAttribute.setEditingMenuID or IFAttribute.setDefinitionMenuID 
		Params:
			filename (str): 
		Returns:
			None: 
		"""
		pass


	def getEditingMenuID(self, isRelativeID=None) -> int:
		r"""
		Get the menu ID that will be generated when this attribute is edited or double-clicked on. See setEditingMenuID 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def setEditingMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this attribute is edited or double-clicked on. The existing menu entry 'Edit Attribute...' will be modified in the context menu such that it generates the ID given. When this menu item is chosen by the user, or the attribute is double-clicked, all LUSAS extension modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can no longer view or modify the underlying modeller definition via the "Edit Attribute..." menu entry. To enable this, call IFAttribute.setDefinitionMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple types such as strings and integers
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def getDefinitionMenuID(self, isRelativeID=None) -> int:
		r"""
		Get the menu ID that will be generated when this attribute is edited or double-clicked on. See setDefinitionMenuID( 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def setDefinitionMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this attribute is edited or double-clicked on. A new menu entry 'Edit definition...' will be automatically added to the context menu, with the ID given. When this menu item is chosen by the user, or the attribute is double-clicked, all modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can still view and modify the underlying modeller definition via the "Edit Attribute..." menu entry. To disable this, call IFAttribute.setEditingMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple types such as strings and integers
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def setDoubleClickDialog(self, filename=None) -> IFAttribute:
		r"""
		Set name of dialog used to edit this attribute when it is double clicked in the treeview. This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFAttribute.setEditingMenuID or IFAttribute.setDefinitionMenuID 
		Params:
			filename (str, optional): If given, sets the dialog. If not given, reset to internal default dialog
		Returns:
			IFAttribute: 
		"""
		pass


	def insertContextMenuItem(self, beforeItem, itemText, command, helpString=None, sessionFile=None) -> None:
		r"""
		Inserts a new menu item before the specified item in the context (right click) menu for this attribute. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
			itemText (str): text of new item
			command (str): command to execute when menu item selected
			helpString (str, optional): help string to be displayed in status bar when cursor hovers over menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def removeContextMenuItem(self, itemText, sessionFile=None) -> IFAttribute:
		r"""
		Removes a context menu item previously added with IFAttribute.insertContextMenuItem. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			itemText (str): text of context menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			IFAttribute: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns the name of this attribute, as entered in the dialog when the attribute was created (or subsequently modified) 
		Returns:
			str: the returned name
		"""
		pass


	def getNameAndDescription(self) -> str:
		r"""
		Returns the name and description of this attribute, as shown in the modeller treeview Currently it is the same as "getName() (getDescription())" 
		Returns:
			str: the returned name
		"""
		pass


	def getAttributeType(self) -> str:
		r"""
		Returns the type of this attribute as a string, e.g. "Concentrated Load" 
		Returns:
			str: the returned type
		"""
		pass


	def deassignFrom(self, arg1, arg2=None, arg3=None) -> IFObjectSet:
		r"""
		Deassigns this attribute from the object(s) given Optionally also pass in assignment data giving extra details about the assignment, such as loadcase, local coordinates, load factor etc. If such an object is given, deassignment will only be performed on those assignments that match the details given - e.g. only those assignments with a particular loadcase. The assignment info, if given, must always be last. 
		Params:
			arg1 (object): Can be any database object capable of having assignments, or an array or objectset, containing any such objects. Alternatively specify an object type such as 'Volume'. Subsequent arguments can provide more context, typically with and assignment object.
			arg2 (object, optional): 
			arg3 (object, optional): 
		Returns:
			IFObjectSet: the set of objects affected by the command (i.e. successful deassignments)
		"""
		pass


	def assignTo(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFObjectSet:
		r"""
		Assigns this attribute to the object(s) given Optionally also pass in assignment data giving extra details about the assignment, such as loadcase, local coordinates, load factor etc. There are two ways to call this function. For most attributes only a single object, IFObjectSet, or array is required, and the attribute will be assigned to that. However, for interface mesh, it is necessary to indicate both primaries and secondaries at the same time. Thus, two objects, IFObjectSet, or arrays must be given. In the case of IFObjectSet and arrays, the same number of objects must be given in each, and the primary secondary pairing will be assumed from the order. E.g. item 1 in the first array will be the primary of item 1 in the second array, and so on. The assignment info, if given, must always be last. 
		Params:
			arg1 (object): Can be any database object capable of having assignments, or an array or objectset, containing any such objects. Alternatively specify an object type such as 'Volume'. Subsequent arguments can provide more context, typically with and assignment object.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFObjectSet: the set of objects affected by the command (i.e. successful assignments)
		"""
		pass


	def assignToAll(self, data) -> IFAttribute:
		r"""
		
		Params:
			data (IFAssignment): 
		Returns:
			IFAttribute: 
		"""
		pass


	def assignToAllOff(self, data) -> IFAttribute:
		r"""
		
		Params:
			data (IFAssignment): 
		Returns:
			IFAttribute: 
		"""
		pass


	def getValue(self, varName, row=None, units=None) -> object:
		r"""
		Returns the value of a named variable within this attribute In order to find the list of valid named variables, use IFAttribute.getValueNames. In order to find out what type of variable will be returned, use IFAttribute.getValueType If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. See IFAttribute.countRows for a description of the optional row argument.
 The returned value will be of a type appropriate to the variable being requested. It could be an object, a real number, a variation, a string, an integer etc, or an array of any of these. 
		Params:
			varName (str): 
			row (int, optional): 
			units (IFUnitSet, optional): 
		Returns:
			object: The type returned will depend on the value requested
		"""
		pass


	def setValue(self, varName, value, row=None, units=None) -> IFDispatch:
		r"""
		Sets the value of a named variable within this attribute In order to find the list of valid named variables, use IFAttribute.getValueNames. In order to find out what type of variable is expected, use IFAttribute.getValueType If an IFUnitSet object (or its name) is given, the value will be assumed to be given in those units. Otherwise it will be assumed to be in the database's current unit system. See IFAttribute.countRows for a description of the optional row argument.
 
		Params:
			varName (str): name of the value (e.g. "E")
			value (object): The type given will depend on the value specified
			row (int, optional): 
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValueNames(self) -> list[str]:
		r"""
		Allows user to inquire the names of values which are valid to be used in IFAttribute.setValue and IFAttribute.getValue The return value is an array of strings, each of which is a valid value name. 
		Returns:
			array of strs: Returned array of names
		"""
		pass


	def getValueDescription(self, varName) -> str:
		r"""
		Returns a description or definition of the given named value. A list of valid names may be obtained by calling IFAttribute.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: the returned string
		"""
		pass


	def getValueType(self, varName) -> str:
		r"""
		Returns the type (string, real, integer, attribute etc) of value that will be returned by IFAttribute.getValue for the given named variable. In order to find the list of valid named variables, use IFAttribute.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: 
		"""
		pass


	def getValueUnits(self, varName, units=None) -> str:
		r"""
		Returns the units ("N/mm�", "m/s", etc) of the value that will be returned by IFAttribute.getValue for the given named variable. In order to find the list of valid named variables, use IFAttribute.getValueNames Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			varName (str): name of the value (e.g. "E")
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			str: the returned string
		"""
		pass


	def countRows(self, varName) -> int:
		r"""
		Returns how many 'rows' of the given value exist within this attribute. Generally, rows represent rows in grids in the LUSAS Modeller user interface. Some attributes (slidelines and most materials) use rows to represent temperature dependence, with each row representing one temperature. Other attributes use rows for multiple versions of similar data, such as in discrete loads and some variations. Many simple attributes do not use rows at all, and will return 0 for all variables. Similarly, attributes that are row-based may have some values that are nonetheless not row-based, and are "shared" between all rows. This function will also return 0 for those values. 
 If this function returns 0, IFAttribute.getValue and IFAttribute.setValue should be called without the optional 'row' argument, or with it set to -1. If this function returns 1 or more, IFAttribute.getValue and IFAttribute.setValue will require the extra 'row' argument which should be in the range (0..nrows-1).
 Note that many values are implemented as arrays, whether or not they are present in rows. The only way to discover whether a particular value is row-based or array-based (or both) is to call both IFAttribute.countRows and IFAttribute.getValue 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			int: 
		"""
		pass


	def createValue(self, name, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Creates a new value within this attribute for subsequent use. The initial value will be 0.0 until modified by a call to IFAttribute.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFAttribute.setValue and/or subsequent access with IFAttribute.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			name (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def setValueDescription(self, name, desc, persist=None) -> IFDispatch:
		r"""
		specify a description to be used (in the report wizard) for a value previously added using IFAttribute.createValue. Note that if this function is not called, the value will not appear in the report. It is an error to call this function for any value not previously added using IFAttribute.createValue. By default, values that are added via createValue() are not persistent. That is, when the attribute is subsequently redefined using a call of the form db.create....(), all such data is lost, consistently with all other data. However, the persist flag may be set true to prevent this. This should only be done for data that cannot be logically invalidated by entering conflicting data in Modeller's user interface. For example, attaching a persistent value for "B" and "D" to an RSS attribute would be dangerous, as the end user is free to modify the values of A, Iyy etc, thus making an inconsistent set of values. 
		Params:
			name (str): name of the value
			desc (str): new description
			persist (bool, optional): persistence (default false)
		Returns:
			IFDispatch: 
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns the unique ID of this attribute IDs are program-generated and quite seperate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def setTreeLocation(self, name, initialExpanded=None, newAttrMenuItemID=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this attribute will be shown. If the folder does not already exist, it will be created. For example, a line mesh attribute would usually be shown in "Attributes/Mesh/Line". By calling this function with the word "Special", this attribute would be shown in the tree in "Attributes/Mesh/Line/Special". This enables the user to categorise or group certain attributes for whatever purpose. Calling with an empty string puts the attribute back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initialExpanded (bool, optional): default true (= open/expanded)
			newAttrMenuItemID (int, optional): default 0 (= default new attribute menu item)
		Returns:
			None: 
		"""
		pass


	def getSubType(self) -> str:
		r"""
		Returns the sub type of this attr (e.g. line mesh) as a string (e.g. "Line Mesh") Special case for no subtype = returns "None" rather than "Mesh" 
		Returns:
			str: 
		"""
		pass


	def isDefiningAttributes(self) -> bool:
		r"""
		Returns true is this attribute is used in the definition of other attributes 
		Returns:
			bool: 
		"""
		pass


	def getAssignments(self, andAssignedObjects=None) -> list[IFAssignment]:
		r"""
		Creates and returns an array of IFAssignment objects, each of which represents one attribute assignment made to this object. Note that the IFAssignment objects returned are copies of the ones in actual use - modifying them will have no effect. If you wish to modify assignment details it is necessary to re-assign the attribute to the object 
		Params:
			andAssignedObjects (bool, optional): default false, if true add the assigned objects to the IFAssignment objects returned
		Returns:
			array of IFAssignment objects: Returned array of IFAssignment objects
		"""
		pass


	def getLCAssignments(self, loadcase) -> list[IFAssignment]:
		r"""
		Behaves exactly like IFAssignment.getAssignments() except that it only works for material and geometric attributes, and the returned list is filtered to reflect the given loadcase. We are not returning assignments that are MADE in this given loadcase, but assignments that APPLY in the given loadcase. e.g. Consider that "this" material is assigned only to a particular line in LC1 and then a different material is assigned to the same line in LC4. Just like getAssignments(), when we ask for assignments in LC1, of course we get the assignment to that line. But with this function, when we ask for assignments in LC2, we also get the same return value (the earlier assignment still applies). When we ask for assignments in LC3, we still get the same, for the same reason. When we ask for assignments of this attribute in LC4, we get an empty array - because the line now has the other material assigned. 
		Params:
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. given loadcase to filter the array
		Returns:
			array of IFAssignment objects: Returned filtered array of IFAssignment objects
		"""
		pass


	def setDescription(self, description=None) -> IFAttribute:
		r"""
		Sets a helpful description to be used in the attribute tree. If no string is given, the attribute will automatically create a description. Note that most attribute types do not yet support this functionality, and therefore the automatically generated description would be blank. Alternatively, the description can be passed to this function in which case it overrides any automatic description 
		Params:
			description (str, optional): description to attach
		Returns:
			IFAttribute: 
		"""
		pass


	def getDescription(self) -> str:
		r"""
		returns the description that was added via IFAttribute.setDescription 
		Returns:
			str: 
		"""
		pass


	def isDefiningAssignedAttributes(self) -> bool:
		r"""
		Returns true if this attribute is used in the definition of other attributes and if any of those attributes are assigned 
		Returns:
			bool: 
		"""
		pass


	def applyUnits(self, pUnits, convertToGiven) -> IFAttribute:
		r"""
		Converts all numerical data inside this attribute to represent a units conversion. If convertToGiven is TRUE, the data is converted from the units of the current model to the units specified by the first argument.  If convertToGiven is FALSE, the underlying data is converted from the given units, to the units of the current model. 
		Params:
			pUnits (IFUnitSet): 
			convertToGiven (bool): 
		Returns:
			IFAttribute: 
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this attribute contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def removeExternalDefinition(self) -> None:
		r"""
		Remove all traces of externally applied definitions, such as those added using IFAttribute.setDescription, IFAttribute.setEditingMenuID, IFAttribute.setDefinitionMenuID, and IFAttribute.setDoubleClickDialog(). This has the effect of breaking the link to the external definition (usually a library or similar) 
		Returns:
			None: 
		"""
		pass


	def getIDAndName(self) -> str:
		r"""
		Returns the ID and name of this attribute, as shown in the modeller treeview Currently it is the same as "getID():getName()" 
		Returns:
			str: the returned name
		"""
		pass


	def getIDAndNameAndDescription(self) -> str:
		r"""
		Returns the ID, name and description of this attribute, as shown in the modeller treeview Currently it is the same as "getID():getName() (getDescription())" 
		Returns:
			str: the returned name
		"""
		pass


	def showEditDlg(self) -> int:
		r"""
		Pops up the dialog to edit this attribte 
		Returns:
			int: 1 if the user pressed OK, 2 if ther user pressed Cancel
		"""
		pass


	def setAnalysisCategory(self, category) -> IFAttribute:
		r"""
		Set the analysis category. 
		Params:
			category (str): "Grillage//Plate", "2D Inplane", "2D Axisymmetric", "3D"
		Returns:
			IFAttribute: 
		"""
		pass


	def getAnalysisCategory(self) -> str:
		r"""
		Get the analysis category. 
		Returns:
			str: "Grillage//Plate", "2D Inplane", "2D Axisymmetric", "3D"
		"""
		pass


	def moveAfter(self, ID) -> IFAttribute:
		r"""
		Move this attribute to be below the given attribute in the treeview 
		Params:
			ID (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object.
		Returns:
			IFAttribute: 
		"""
		pass


	def createCopy(self, name) -> IFAttribute:
		r"""
		Creates a new attribute in the same database as "this" attribute with the given new name, but which is otherwise a copy of "this" attribute 
		Params:
			name (str): name of attribute to create
		Returns:
			IFAttribute: newly created attribute
		"""
		pass


	def moveToFirst(self) -> IFAttribute:
		r"""
		Move this attribute to be the first attribute in its section of the treeview 
		Returns:
			IFAttribute: 
		"""
		pass


	def renumber(self, newID) -> IFAttribute:
		r"""
		change the ID of this attribute 
		Params:
			newID (int): must be > 0
		Returns:
			IFAttribute: 
		"""
		pass


	def isDefault(self) -> bool:
		r"""
		Returns true is this attribute is set as default 
		Returns:
			bool: 
		"""
		pass


class IFAssignment(IFDispatch):
	"""
	An assignment is a relationship between a database member (usually a IFPoint, IFLine, IFSurface or IFVolume), and an IFAttribute. The IFAssignment object also acts as a container for all the options and settings that can control and modify the assignment. During the assignment process, an IFAssignment object is used to define settings such as orientation and factor. Once assigned, the details can be queried using IFAttribute.getAssignments or IFGeometry.getAssignments 
	"""

	def clear(self) -> IFAssignment:
		r"""
		remove all stored data 
		Returns:
			IFAssignment: 
		"""
		pass


	def setAllDefaults(self) -> IFAssignment:
		r"""
		Reset back to default values for all data 
		Returns:
			IFAssignment: 
		"""
		pass


	def setIgnoreAll(self) -> IFAssignment:
		r"""
		Reset back to ignore all internal data when this object is used for filtering e.g. in IFAttribute.deassignFrom and IFObjectSet.add 
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadset(self, ID) -> IFAssignment:
		r"""
		Specify the loadset for the assignment. Generally this will be a IFLoadcase but in a load curve analysis, loading must be assigned to a IFLoadCurve. 
		Params:
			ID (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadsetOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadsetAll(self, analysisName) -> IFAssignment:
		r"""
		Specify the loadsets for the assignment. Generally this will be a IFLoadcase but in a load curve analysis, loading must be assigned to a IFLoadCurve. 
		Params:
			analysisName (str): analysis from which the all loadsets will be used in assignment
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadsetFromStart(self, ID) -> IFAssignment:
		r"""
		Specify the ending loadset for the assignment. Generally this will be a IFLoadcase but in a load curve analysis, loading must be assigned to a IFLoadCurve. 
		Params:
			ID (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadsetToEnd(self, ID) -> IFAssignment:
		r"""
		Specify the starting loadset for the assignment. Generally this will be a IFLoadcase but in a load curve analysis, loading must be assigned to a IFLoadCurve. 
		Params:
			ID (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadsetSpecified(self, ID) -> IFAssignment:
		r"""
		Specify the first loadset of a set for the assignment. Generally this will be a IFLoadcase but in a load curve analysis, loading must be assigned to a IFLoadCurve. 
		Params:
			ID (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFAssignment: 
		"""
		pass


	def addLoadsetSpecified(self, ID) -> IFAssignment:
		r"""
		Add a loadset to a set for the assignment. Generally this will be a IFLoadcase but in a load curve analysis, loading must be assigned to a IFLoadCurve. 
		Params:
			ID (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadsetRange(self, IDstart, IDend) -> IFAssignment:
		r"""
		Specify the range of loadsets the assignment. Generally this will be a IFLoadcase but in a load curve analysis, loading must be assigned to a IFLoadCurve. 
		Params:
			IDstart (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
			IDend (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setIgnoreLoadFactor(self) -> IFAssignment:
		r"""
		Specify that the load factor is to be ignored when deassigning 
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadFactor(self, loadFactor) -> IFAssignment:
		r"""
		Specify a numerical factor by which loading will be multiplied 
		Params:
			loadFactor (float): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setBetaAngle(self, Beta) -> IFAssignment:
		r"""
		Specify the beta angle for assignment of mesh. This is the angle between the line z axis (as modified by any assigned local coordinates) and the element z axis 
		Params:
			Beta (IFTransformationAttr): The name or ID of a transformation, or a pointer to a IFTransformationAttr object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setBetaAngleFromMatrix(self, Beta) -> IFAssignment:
		r"""
		Specify the beta angle for assignment of mesh. This ts the beta angle originally calculated from "setBetaAngleMatrix" 
		Params:
			Beta (IFTransformationAttr): The name or ID of a transformation, or a pointer to a IFTransformationAttr object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setBetaAngleMatrix(self, xAxisX, xAxisY, xAxisZ, yAxisX, yAxisY, yAxisZ, zAxisX, zAxisY, zAxisZ) -> IFAssignment:
		r"""
		Specify the beta angle for assignment of mesh using a matrix. This is the angle between the line z axis (as modified by any assigned local coordinates) and the element z axis 
		Params:
			xAxisX (float): x component of the X axis
			xAxisY (float): y component of the X axis
			xAxisZ (float): z component of the X axis
			yAxisX (float): x component of the Y axis
			yAxisY (float): y component of the Y axis
			yAxisZ (float): z component of the Y axis
			zAxisX (float): x component of the Z axis
			zAxisY (float): y component of the Z axis
			zAxisZ (float): z component of the Z axis
		Returns:
			IFAssignment: 
		"""
		pass


	def setPatchTransform(self, TransAttr) -> IFAssignment:
		r"""
		 
		Params:
			TransAttr (IFTransformationAttr): The name or ID of a transformation, or a pointer to a IFTransformationAttr object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setPatchTransformOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadTransform(self, TransAttr) -> IFAssignment:
		r"""
		 
		Params:
			TransAttr (IFTransformationAttr): The name or ID of a transformation, or a pointer to a IFTransformationAttr object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadTransformOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSearchArea(self, SearchAreaAttr) -> IFAssignment:
		r"""
		 
		Params:
			SearchAreaAttr (IFSearchArea): The name or ID of a searcharea, or a pointer to a IFSearchArea object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setSearchAreaOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setLoadMoving(self, loadMoving) -> IFAssignment:
		r"""
		controls the manner in which loading which falls outside the search area is applied 
		Params:
			loadMoving (str): "Include Full Load","Include Local X Projected Load","Include Local Y Projected Load","Include Local X & Y Projected Load","Include Non-Projected Load","Include Full Local X Load" or "Include Full Local Y Load"
		Returns:
			IFAssignment: 
		"""
		pass


	def setPrimarySecondaryType(self, type) -> IFAssignment:
		r"""
		set the assignment type to primary or secondary 
		Params:
			type (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setConsiderOverrides(self, isConsider) -> IFAssignment:
		r"""
		Only used when this object is being pass to an IFObjectSet function such as IFObjectSet.add. Follows the chain of inherited and overridden attributes, such that the objects considered are those 'currently using' this assignment - rather than the usual sense which is 'actually assigned in in the active loadcase'. This flag is switched to false by a call to IFAssignment.setIgnoreAll() 
		Params:
			isConsider (bool): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setConsiderAllAssigns(self, isConsider) -> IFAssignment:
		r"""
		Only used when this object is being pass to an IFObjectSet function such as IFObjectSet.add. Ignores the active loadcase, and considers any object, howsoever assigned - rather than the usual case which is 'actually assigned in the active loadcase'. This flag is switched to false by a call to IFAssignment.setIgnoreAll() 
		Params:
			isConsider (bool): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setOrientation(self, orientation) -> IFAssignment:
		r"""
		 
		Params:
			orientation (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setLocalCoord(self, LocalCoordAttr) -> IFAssignment:
		r"""
		 
		Params:
			LocalCoordAttr (IFLocalCoord): The name or ID of a localcoordinate, or a pointer to a IFLocalCoord object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setLocalCoordOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setOrientationPoint(self, Point) -> IFAssignment:
		r"""
		 
		Params:
			Point (IFPoint): The name or ID of a point, or a pointer to a IFPoint object.
		Returns:
			IFAssignment: 
		"""
		pass


	def addOrientationPoint(self, Point) -> IFAssignment:
		r"""
		 
		Params:
			Point (IFPoint): The name or ID of a point, or a pointer to a IFPoint object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setOrientationPointOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setBackgroundGrid(self, Grid) -> IFAssignment:
		r"""
		 
		Params:
			Grid (IFBackgroundGrid): The name or ID of a backgroundgrid, or a pointer to a IFBackgroundGrid object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setBackgroundGridOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setCompositeOrientation(self, orientation) -> IFAssignment:
		r"""
		 
		Params:
			orientation (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSelectionNone(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSelectionAll(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSelectionNoGeometry(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSelectionGeometry(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSelectionNoMesh(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSelectionMesh(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def addToSelection(self, typeName) -> IFAssignment:
		r"""
		 
		Params:
			typeName (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def removeFromSelection(self, typeName) -> IFAssignment:
		r"""
		 
		Params:
			typeName (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setMemorySelectionNone(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setMemorySelectionAll(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setMemorySelectionNoGeometry(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setMemorySelectionGeometry(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setMemorySelectionNoMesh(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setMemorySelectionMesh(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def addToMemorySelection(self, typeName) -> IFAssignment:
		r"""
		 
		Params:
			typeName (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def removeFromMemorySelection(self, typeName) -> IFAssignment:
		r"""
		 
		Params:
			typeName (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def addHOF(self, HOF) -> IFAssignment:
		r"""
		 
		Params:
			HOF (IFGeometry): 
		Returns:
			IFAssignment: 
		"""
		pass


	def removeAllHOFs(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def setInterfaceSecondary(self, Feat) -> IFAssignment:
		r"""
		 
		Params:
			Feat (IFGeometry): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setInterfaceSecondaryOff(self) -> IFAssignment:
		r"""
		 
		Returns:
			IFAssignment: 
		"""
		pass


	def meshPrimaryToSecondary(self) -> IFAssignment:
		r"""
		Set the primary interface feature off 
		Returns:
			IFAssignment: 
		"""
		pass


	def meshSecondaryToPrimary(self) -> IFAssignment:
		r"""
		Set the secondary interface feature off 
		Returns:
			IFAssignment: 
		"""
		pass


	def setDeassignMode(self, mode) -> IFAssignment:
		r"""
		Set the deassignment mode 
		Params:
			mode (str): "First" or "All"
		Returns:
			IFAssignment: 
		"""
		pass


	def setDeassignMatch(self, match) -> IFAssignment:
		r"""
		Set the deassignment matching mode 
		Params:
			match (str): "Attribute only" or "Attribute and data" or "Attribute and loadcase"
		Returns:
			IFAssignment: 
		"""
		pass


	def getAttribute(self) -> IFAttribute:
		r"""
		 
		Returns:
			IFAttribute: 
		"""
		pass


	def getDatabaseObject(self) -> IFDatabaseMember:
		r"""
		 
		Returns:
			IFDatabaseMember: 
		"""
		pass


	def getLoadFactor(self) -> float:
		r"""
		Returns the value specified by IFAssignment.setLoadFactor 
		Returns:
			float: 
		"""
		pass


	def getBetaAngle(self) -> object:
		r"""
		Returns the value specified by IFAssignment.setBetaAngle Note that the value will be returned as a VARIANT - as it may be either be a number or an IFVariationAttr. 
		Returns:
			float: 
		"""
		pass


	def getPatchTransform(self) -> IFTransformationAttr:
		r"""
		Returns the value specified by IFAssignment.setPatchTransform 
		Returns:
			IFTransformationAttr: 
		"""
		pass


	def getLoadTransform(self) -> IFTransformationAttr:
		r"""
		Returns the value specified by IFAssignment.setLoadTransform 
		Returns:
			IFTransformationAttr: 
		"""
		pass


	def getSearchArea(self) -> IFSearchArea:
		r"""
		Returns the value specified by IFAssignment.setSearchArea 
		Returns:
			IFSearchArea: 
		"""
		pass


	def getLoadMoving(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setLoadMoving 
		Returns:
			str: 
		"""
		pass


	def getPrimarySecondaryType(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setPrimarySecondaryType 
		Returns:
			str: 
		"""
		pass


	def isConsiderOverrides(self) -> bool:
		r"""
		Returns the value specified by IFAssignment.setConsiderOverrides 
		Returns:
			bool: 
		"""
		pass


	def isConsiderAllAssigns(self) -> bool:
		r"""
		Returns the value specified by IFAssignment.setConsiderAllAssigns 
		Returns:
			bool: 
		"""
		pass


	def getOrientation(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setOrientation 
		Returns:
			str: 
		"""
		pass


	def getLocalCoord(self) -> IFLocalCoord:
		r"""
		Returns the value specified by IFAssignment.setLocalCoord 
		Returns:
			IFLocalCoord: 
		"""
		pass


	def getOrientationPoint(self) -> IFPoint:
		r"""
		Returns the value specified by IFAssignment.setOrientationPoint 
		Returns:
			IFPoint: 
		"""
		pass


	def getBackgroundGrid(self) -> IFBackgroundGrid:
		r"""
		Returns the value specified by IFAssignment.setBackgroundGrid 
		Returns:
			IFBackgroundGrid: 
		"""
		pass


	def getCompositeOrientation(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setCompositeOrientation 
		Returns:
			str: 
		"""
		pass


	def getInterfaceSecondary(self) -> IFGeometry:
		r"""
		Returns the value specified by IFAssignment.setInterfaceSecondary 
		Returns:
			IFGeometry: 
		"""
		pass


	def getDeassignMode(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setDeassignMode 
		Returns:
			str: 
		"""
		pass


	def getDeassignMatch(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setDeassignMatch 
		Returns:
			str: 
		"""
		pass


	def getMeshPrimaryToSecondary(self) -> bool:
		r"""
		Returns the value specified by IFAssignment.meshPrimaryToSecondary 
		Returns:
			bool: 
		"""
		pass


	def setSearchAssignType(self, type) -> IFAssignment:
		r"""
		controls the manner in which the loading is apply to the objects in the search area 
		Params:
			type (str): "line" - project on to line "area" - project into area, exclude moments "moment" -  project into area, include moments "volume" - project into volume
		Returns:
			IFAssignment: 
		"""
		pass


	def getSearchAssignType(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setSearchAssignType 
		Returns:
			str: 
		"""
		pass


	def setInfNodeCoords(self, x, y, z) -> IFAssignment:
		r"""
		Set the coordinates at which influence will be assigned/deassigned. If this function is not called, Modeller will assume the coordinates from nodes and points in the current selection. 
		Params:
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFAssignment: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Gets the assignment name 
		Returns:
			str: 
		"""
		pass


	def getNameWithDescription(self) -> str:
		r"""
		Gets the assignment name including any description 
		Returns:
			str: 
		"""
		pass


	def isPending(self) -> bool:
		r"""
		Returns true if this assignment is pending 
		Returns:
			bool: 
		"""
		pass


	def isForCoincidentEffect(self) -> bool:
		r"""
		returns TRUE if the influence assignment is for a coincident effect 
		Returns:
			bool: 
		"""
		pass


	def getAttributeType(self) -> str:
		r"""
		return the type of the attribute in this assignment as a string, e.g. "Concentrated Load" 
		Returns:
			str: the returned type
		"""
		pass


	def addDrapeSurface(self, pSurface) -> IFAssignment:
		r"""
		add a surface to the list to be draped 
		Params:
			pSurface (IFsurface): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setRefPath(self, pRefPath) -> IFAssignment:
		r"""
		Specify the reference path that applies to this assignment 
		Params:
			pRefPath (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
		Returns:
			IFAssignment: 
		"""
		pass


	def getRefPath(self) -> IFReferencePath:
		r"""
		Retrieve the reference path that applies to this assignment  
		Returns:
			IFReferencePath: 
		"""
		pass


	def setTwistAngle(self, twist) -> IFAssignment:
		r"""
		Specify the twist along a line for beam elements 
		Params:
			twist (IFVariationAttr): The name or ID of a variation, or a pointer to a IFVariationAttr object.
		Returns:
			IFAssignment: 
		"""
		pass


	def setOrientJointToLocalAxes(self, dirStr) -> IFAssignment:
		r"""
		set the joint element axis to the local coordinates axis for joint interface meshing 
		Params:
			dirStr (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setIncludedMoments(self, type) -> IFAssignment:
		r"""
		set the "which moments to include" option for discrete load assignment 
		Params:
			type (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def getIncludedMoments(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setIncludedMoments 
		Returns:
			str: 
		"""
		pass


	def setAnalysis(self, analysisName) -> IFAssignment:
		r"""
		set associated analysis 
		Params:
			analysisName (str): Analysis name
		Returns:
			IFAssignment: 
		"""
		pass


	def getAnalysis(self) -> IFAnalysisBaseClass:
		r"""
		get associated analysis 
		Returns:
			IFAnalysisBaseClass: 
		"""
		pass


	def addInfluenceClarifyObj(self, obj) -> None:
		r"""
		add an object that will be used to restrict results calculation (equivalent to selecting the object when influence is assigned) 
		Params:
			obj (IFDatabaseMember): The name or ID of a databasemember, or a pointer to a IFDatabaseMember object.
		Returns:
			None: 
		"""
		pass


	def setDoValidateClarifyObj(self, doValidate) -> None:
		r"""
		switch on/off validation of objects added using IFAssignment.addInfluenceClarifyObj 
		Params:
			doValidate (bool): 
		Returns:
			None: 
		"""
		pass


	def setInfRezType(self, location) -> None:
		r"""
		"node" (for averaged), or "element" (for unaveraged) 
		Params:
			location (str): 
		Returns:
			None: 
		"""
		pass


	def addBeamShellSlice(self, name) -> None:
		r"""
		add a beam shell slice to the array where a DMI will be assigned 
		Params:
			name (str): Beam shell slice name
		Returns:
			None: 
		"""
		pass


	def getDiscreteLoadProjection(self, element, nodes, coords) -> int:
		r"""
		
		Params:
			element (IFElement): , intersected element
			nodes (array of IFNode): , intersected face nodes
			coords (array of float): , model space intersection coords
		Returns:
			int: set non-zero on error
		"""
		pass


	def setMatlAsgnType(self, type) -> IFAssignment:
		r"""
		set the material assignment type, may be "normal" or "rigidStart/End" for joint material assignment to rigid end zone joints 
		Params:
			type (str): assignment type
		Returns:
			IFAssignment: 
		"""
		pass


	def setLcDependentConstraintsOff(self) -> IFAssignment:
		r"""
		post V15.0 constraint equations assignments may be loadcase dependent, use this function to maintain pre-V15.0 behavior of scripts 
		Returns:
			IFAssignment: 
		"""
		pass


	def setLcDependentConstraintsOn(self) -> IFAssignment:
		r"""
		post V15.0 constraint equations assignments may be loadcase dependent, use this function to take advantage of the new behavior 
		Returns:
			IFAssignment: 
		"""
		pass


	def setMultipleId(self, id) -> IFAssignment:
		r"""
		Set an id for this assignment. 0 is default so there is no need to set. If -1 then each assignment will be considered individually to the object set that this will apply. Any other value will set the given value to to the assignment 
		Params:
			id (int): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setAsgnLoadComponent(self, type) -> IFAssignment:
		r"""
		set the loading assignment load component 
		Params:
			type (str): "all","envt environmental temperature", ...
		Returns:
			IFAssignment: 
		"""
		pass


	def getAsgnLoadComponent(self) -> str:
		r"""
		Returns the value specified by IFAssignment.setAsgnLoadComponent 
		Returns:
			str: 
		"""
		pass


	def getMultipleId(self) -> int:
		r"""
		Get the id of this assignment 
		Returns:
			int: 
		"""
		pass


	def setAutoZCoord(self, val) -> IFAssignment:
		r"""
		Set the option to auto calculate Z coord 
		Params:
			val (bool): 
		Returns:
			IFAssignment: 
		"""
		pass


	def getAutoZCoord(self) -> bool:
		r"""
		Get the option to auto calculate Z coord 
		Returns:
			bool: 
		"""
		pass


	def setZCoord(self, val) -> IFAssignment:
		r"""
		set option to manual value Z coord 
		Params:
			val (float): 
		Returns:
			IFAssignment: 
		"""
		pass


	def getZCoord(self) -> float:
		r"""
		Get option to manual value Z coord 
		Returns:
			float: 
		"""
		pass


	def setSingleFeatureJointType(self, typeStr) -> IFAssignment:
		r"""
		Set the "single feature mesh assignment" insertion type 
		Params:
			typeStr (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSingleFeatureMeshReverse(self, reverse) -> IFAssignment:
		r"""
		Set the "single feature mesh assignment" joints reversed flag in a 2d planar analysis with joints inserted between 2 surfaces and a meshed line 
		Params:
			reverse (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setSingleFeatureJointOrient(self, typeStr) -> IFAssignment:
		r"""
		Set the "single feature mesh assignment" orientation type for joints 
		Params:
			typeStr (str): 
		Returns:
			IFAssignment: 
		"""
		pass


	def addSingleFeatureJointSeparate(self, obj) -> IFAssignment:
		r"""
		For a "single feature mesh assignment" add a parent object to be separated from the assigned child object 
		Params:
			obj (IFDatabaseMember): The name or ID of a databasemember, or a pointer to a IFDatabaseMember object.
		Returns:
			IFAssignment: 
		"""
		pass


	def removeJointInterfaceAssignHofs(self) -> IFAssignment:
		r"""
		remove all joint/interface material/loading assignment hof object data 
		Returns:
			IFAssignment: 
		"""
		pass


	def addJointInterfaceAssignHofForLof(self, lofObj, hofObj) -> IFAssignment:
		r"""
		add the hof to the lof for joint/interface material/loading assignment 
		Params:
			lofObj (IFGeometry): 
			hofObj (IFGeometry): 
		Returns:
			IFAssignment: 
		"""
		pass


	def setTargetStressEnd(self, type) -> IFAssignment:
		r"""
		set the target stress loading assignment to lines end point type 
		Params:
			type (str): "start","end","select start","select end"
		Returns:
			IFAssignment: 
		"""
		pass


	def addTargetStressPair(self, hof, point) -> IFAssignment:
		r"""
		add target stress loading assignment object and point pairing 
		Params:
			hof (IFGeometry): 
			point (IFPoint): 
		Returns:
			IFAssignment: 
		"""
		pass


	def isAllLoadcases(self) -> bool:
		r"""
		return true if the loadcase range type is all loadcases 
		Returns:
			bool: 
		"""
		pass


	def isSingleLoadcase(self) -> bool:
		r"""
		return true if the loadcase range type is single loadcase 
		Returns:
			bool: 
		"""
		pass


	def isFromLoadcase(self) -> bool:
		r"""
		return true if the loadcase range type is from start 
		Returns:
			bool: 
		"""
		pass


	def isToLoadcase(self) -> bool:
		r"""
		return true if the loadcase range type is to end 
		Returns:
			bool: 
		"""
		pass


	def isSpecifiedLoadcases(self) -> bool:
		r"""
		return true if the loadcase range type is specified loadcases 
		Returns:
			bool: 
		"""
		pass


	def isRangeLoadcases(self) -> bool:
		r"""
		return true if the loadcase range type is range of loadcases 
		Returns:
			bool: 
		"""
		pass


	def isInLoadcaseRange(self, loadset) -> bool:
		r"""
		return true if the given loadcase is in the loadcase range 
		Params:
			loadset (name, id, IFLoadset): ,  the loadset
		Returns:
			bool: 
		"""
		pass


	def getAllLoadcases(self) -> object:
		r"""
		return array of all loadcases to which the loadcase range currently applies, this array may be very large 
		Returns:
			object: array <IFLoadset>
		"""
		pass


	def getSingleLoadcase(self) -> IFLoadset:
		r"""
		return the single loadcase from the loadcase range of type single 
		Returns:
			IFLoadset: 
		"""
		pass


	def getLoadcaseFrom(self) -> IFLoadset:
		r"""
		return the last loadcase from the loadcase range of type from start 
		Returns:
			IFLoadset: 
		"""
		pass


	def getLoadcaseTo(self) -> IFLoadset:
		r"""
		return the first loadcase from the loadcase range of type to end 
		Returns:
			IFLoadset: 
		"""
		pass


	def getLoadcaseRange(self, firstLc, lastLc) -> None:
		r"""
		return the first and last loadcases from the loadcase range of type range 
		Params:
			firstLc (IFLoadset): 
			lastLc (IFLoadset): 
		Returns:
			None: 
		"""
		pass


	def getSpecifiedLoadcases(self) -> object:
		r"""
		return array of loadcases from the loadcase range of type specified 
		Returns:
			object: array <IFLoadset>
		"""
		pass


	def getAssignedObjects(self) -> object:
		r"""
		return array of objects with this assignment 
		Returns:
			object: array <IFDatabaseMember>
		"""
		pass


	def setInterfaceMeshAsSelected(self, type) -> IFAssignment:
		r"""
		set interface mesh pairing type 
		Params:
			type (bool): true follow selection, false use best guess
		Returns:
			IFAssignment: 
		"""
		pass


	def setAssignReferencePath(self, refPath, nrmCrd, patchTransformType, doPatchReverse, loadTransformType, doLoadReverse, longitudinalAxis) -> IFAssignment:
		r"""
		discrete loading following a reference path 
		Params:
			refPath (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
			nrmCrd (float): normalised coordinate along the path
			patchTransformType (str or int): patch transformation type
			doPatchReverse (bool): if true reverse patch direction
			loadTransformType (str or int): load transformation type
			doLoadReverse (bool): if true reverse load direction
			longitudinalAxis (str or int): discrete load longitudinal axes
		Returns:
			IFAssignment: 
		"""
		pass


	def getPathNrmCrd(self) -> float:
		r"""
		return normalised distance along the load path 
		Returns:
			float: 
		"""
		pass


	def setInterfaceOrientationHof(self, hof) -> IFAssignment:
		r"""
		set the hof object used to orientation interface elements on the assigned lof object 
		Params:
			hof (IFGeometry): 
		Returns:
			IFAssignment: 
		"""
		pass


	def addInterfaceOrientationHof(self, hof) -> IFAssignment:
		r"""
		add the hof object used to orientation interface elements on the assigned lof object 
		Params:
			hof (IFGeometry): 
		Returns:
			IFAssignment: 
		"""
		pass


class IFControl(IFDispatch):
	"""
	 
	"""

	def setValue(self, varName, value, index=None, units=None) -> IFDispatch:
		r"""
		Set a value for the given named parameter. A list of valid names may be obtained by calling IFControl.getValueNames If an IFUnitSet object (or its name) is given, the value will be assumed to be given in those units. Otherwise it will be assumed to be in the database's current unit system 
		Params:
			varName (str): 
			value (object): 
			index (int, optional): 
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValue(self, varName, row=None, units=None) -> object:
		r"""
		Returns the value of a named variable within this control In order to find the list of valid named variables, use IFControl.getValueNames. In order to find out what type of variable will be returned, use IFControl.getValueType If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. See IFControl.countRows for a description of the optional row argument.
 The returned value will be of a type appropriate to the variable being requested. It could be an object, a real number, a variation, a string, an integer etc, or an array of any of these. 
		Params:
			varName (str): 
			row (int, optional): 
			units (IFUnitSet, optional): 
		Returns:
			object: 
		"""
		pass


	def getValueNames(self) -> list[str]:
		r"""
		Allows user to inquire the names of values which are valid to be used in IFControl.setValue and IFControl.getValue The return value is an array of strings, each of which is a valid value name. 
		Returns:
			array of strs: 
		"""
		pass


	def getValueDescription(self, varName) -> str:
		r"""
		Returns a description or definition of the given named value. A list of valid names may be obtained by calling IFControl.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: the returned string
		"""
		pass


	def getValueType(self, varName) -> str:
		r"""
		Return the type (string, real, integer, attribute etc) of value that will be returned by IFControl.getValue for the given named variable. In order to find the list of valid named variables, use IFControl.getValueNames 
		Params:
			varName (str): 
		Returns:
			str: 
		"""
		pass


	def getValueUnits(self, varName, units=None) -> str:
		r"""
		Return the units ("N/mm�", "m/s", etc) of the value that will be returned by IFControl.getValue for the given named variable. In order to find the list of valid named variables, use IFControl.getValueNames Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			varName (str): name of the value (e.g. "E")
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			str: the returned string
		"""
		pass


	def countRows(self, varName) -> int:
		r"""
		Returns how many 'rows' of the given value exist within this object. Generally, rows represent rows in grids in the LUSAS Modeller user interface If this function returns 0, IFControl.getValue and IFControl.setValue should be called without the optional 'row' argument, or with it set to -1. If this function returns 1 or more, IFControl.getValue and IFControl.setValue will require the extra 'row' argument which should be in the range (0..nrows-1).
 Note that many values are implemented as arrays, whether or not they are present in rows. The only way to discover whether a particular value is row-based or array-based (or both) is to call both IFControl.countRows and IFControl.getValue 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			int: 
		"""
		pass


	def createValue(self, name, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Create a new value within this control for subsequent use. The initial value will be 0.0 until modified by a call to IFControl.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFControl.setValue and/or subsequent access with IFControl.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			name (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def setValueDescription(self, name, desc, persist=None) -> IFDispatch:
		r"""
		specify a description to be used (in the report wizard) for a value previously added using IFControl.createValue. Note that if this function is not called, the value will not appear in the report. It is an error to call this function for any value not previously added using IFControl.createValue. By default, values that are added via createValue() are not persistent. That is, when the control is subsequently redefined using a call of the form loadcase.set....Control(), all such data is lost, consistently with all other data. However, the persist flag may be set true to prevent this. This should only be done for data that cannot be logically invalidated by entering conflicting data in Modeller's user interface. 
		Params:
			name (str): name of the value
			desc (str): new description
			persist (object, optional): persistence (default false)
		Returns:
			IFDispatch: 
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this control contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def createCopy(self, loadcase) -> IFControl:
		r"""
		Creates a clone control 
		Params:
			loadcase (IFLoadcase): The name or ID of a "Loadcase", or a pointer to a IFLoadcase object. Loadcase in which the copy will be created.
		Returns:
			IFControl: the new control that has been created
		"""
		pass


class IFLoadset(IFDispatch):
	"""
	 
	"""

	def setName(self, name) -> IFLoadset:
		r"""
		modify the name of this loadset 
		Params:
			name (str): 
		Returns:
			IFLoadset: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns the name of this loadset 
		Returns:
			str: name of this loadset
		"""
		pass


	def getTypeCode(self) -> int:
		r"""
		Returns a code indicating the type of this loadset from the following table 0: Loadcase (IFLoadcase) 1: Results Loadcase (IFResultsLoadset) 2: Basic combination (IFBasicCombination) 3: Envelope (IFEnvelope) 4: Fatigue Loadcase (IFFatigue) 5: IMD Loadcase (IFIMD) 6: Smart Combination (IFSmartCombination) 7: Standard Load Curve (IFLoadCurve) 8: Variation Load Curve (IFLoadCurve) 9: Table Load Curve (IFLoadCurve) 11: Target Value Loadcase (IFLoadsetTargetValues) 12: Cable Tuning Loadcase (IFCableTuningResults) 13: DMI Influence Results Loadcase 14: Target Values Loadcase 15: Non-Linear Cable Tuning Loadcase 
		Returns:
			int: The returned type
		"""
		pass


	def getResultsFileName(self) -> str:
		r"""
		Return the location of this loadset  
		Synonyms:
			getLocation
		Returns:
			str: 
		"""
		pass


	def getLocation(self) -> str:
		r"""
		Return the location of this loadset  
		Returns:
			str: either "model" or a results filename
		"""
		pass


	def hasResults(self) -> bool:
		r"""
		Returns true if this loadset is valid for post processing Note that a combination or envelope will return true even if some results are missing. See IFLoadset.hasAllResults  
		Returns:
			bool: indicates whether this loadcase is valid for post processing
		"""
		pass


	def hasAllResults(self) -> bool:
		r"""
		Returns true if this loadset is fully valid for post processing. For a simple loadcase, this function is exactly the same as IFLoadset.hasAllResults, but a combination or envelope will return false if some results are missing (i.e. some results file(s) loaded, and some not loaded)  
		Returns:
			bool: indicates whether this loadcase is fully valid for post processing
		"""
		pass


	def affectedByResultsFileClosure(self, fileID) -> bool:
		r"""
		Returns true if this loadset would be affected by the closure of the given file. For simple results loadcases, this means "does this loadcase belong to that file" For combinations and envelopes and similar, this means "does any loadcase constituent belong to that file" 
		Params:
			fileID (int): ID of the file being closed
		Returns:
			bool: 
		"""
		pass


	def isActiveInAnyView(self) -> bool:
		r"""
		Returns true if this loadset is currently active in any view 
		Returns:
			bool: 
		"""
		pass


	def getID(self) -> int:
		r"""
		The unique ID of this loadset IDs are program-generated and quite separate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def getResultsFileID(self) -> int:
		r"""
		Returns 0 if this loadset's location is the model. Otherwise the ID of the results file from which it was loaded  
		Returns:
			int: results file ID
		"""
		pass


	def getEigenvalueID(self) -> int:
		r"""
		 
		Returns:
			int: 
		"""
		pass


	def getHarmonicID(self) -> int:
		r"""
		 
		Returns:
			int: 
		"""
		pass


	def hasPrimaryComponent(self, entity, component) -> bool:
		r"""
		Returns true if this loadset is the currently active loadset, and was made active with a primary component. Otherwise returns false. On returning true, the entity and component variables are set to the entity and component which were specified when it was made active. Note - a primary component of "All" means "no coincident effects" which in turn means "each component calculated independently". 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
		Returns:
			bool: true if active, and primary component used
		"""
		pass


	def needsPrimaryComponent(self) -> bool:
		r"""
		Returns true if this loadset needs a primary component when set active. This will be the case if it is an envelope or smart combination. Additionally if it is a basic combination which contains an envelope or smart combination. Note - a primary component of "All" means "no coincident effects" which in turn means "each component calculated independently". 
		Returns:
			bool: true if primary component should be used
		"""
		pass


	def setValue(self, varName, value, index=None, units=None) -> IFDispatch:
		r"""
		Set a value for the given named parameter. A list of valid names may be obtained by calling IFLoadset.getValueNames If an IFUnitSet object (or its name) is given, the value will be assumed to be given in those units. Otherwise it will be assumed to be in the database's current unit system 
		Params:
			varName (str): 
			value (object): 
			index (int, optional): 
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValue(self, varName, row=None, units=None) -> object:
		r"""
		Returns the value of a named variable within this control In order to find the list of valid named variables, use IFLoadset.getValueNames. In order to find out what type of variable will be returned, use IFLoadset.getValueType If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. See IFLoadset.countRows for a description of the optional row argument.
 The returned value will be of a type appropriate to the variable being requested. It could be an object, a real number, a variation, a string, an integer etc, or an array of any of these. 
		Params:
			varName (str): 
			row (int, optional): 
			units (IFUnitSet, optional): 
		Returns:
			object: 
		"""
		pass


	def getValueNames(self) -> list[str]:
		r"""
		Allows user to inquire the names of values which are valid to be used in IFLoadset.setValue and IFLoadset.getValue The return value is an array of strings, each of which is a valid value name. 
		Returns:
			array of strs: 
		"""
		pass


	def getValueDescription(self, varName) -> str:
		r"""
		Returns a description or definition of the given named value. A list of valid names may be obtained by calling IFLoadset.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: the returned string
		"""
		pass


	def getValueType(self, varName) -> str:
		r"""
		Return the type (string, real, integer, attribute etc) of value that will be returned by IFLoadset.getValue for the given named variable. In order to find the list of valid named variables, use IFLoadset.getValueNames 
		Params:
			varName (str): 
		Returns:
			str: 
		"""
		pass


	def countRows(self, varName) -> int:
		r"""
		Returns how many 'rows' of the given value exist within this object. Generally, rows represent rows in grids in the LUSAS Modeller user interface If this function returns 0, IFLoadset.getValue and IFLoadset.setValue should be called without the optional 'row' argument, or with it set to -1. If this function returns 1 or more, IFLoadset.getValue and IFLoadset.setValue will require the extra 'row' argument which should be in the range (0..nrows-1).
 Note that many values are implemented as arrays, whether or not they are present in rows. The only way to discover whether a particular value is row-based or array-based (or both) is to call both IFLoadset.countRows and IFLoadset.getValue 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			int: 
		"""
		pass


	def getValueUnits(self, varName, units=None) -> str:
		r"""
		Return the units ("N/mm�", "m/s", etc) of the value that will be returned by IFLoadset.getValue for the given named variable. In order to find the list of valid named variables, use IFLoadset.getValueNames Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			varName (str): name of the value (e.g. "E")
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			str: the returned string
		"""
		pass


	def createValue(self, name, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Create a new value within this loadset for subsequent use. The initial value will be 0.0 until modified by a call to IFLoadset.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFLoadset.setValue and/or subsequent access with IFLoadset.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			name (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def setValueDescription(self, name, desc, persist=None) -> IFDispatch:
		r"""
		specify a description to be used (in the report wizard) for a value previously added using IFLoadset.createValue. Note that if this function is not called, the value will not appear in the report. It is an error to call this function for any value not previously added using IFLoadset.createValue. By default, values that are added via createValue() are not persistent. That is, when the loadset is subsequently redefined using a call of the form db.create...(), all such data is lost, consistently with all other data. However, the persist flag may be set true to prevent this. This should only be done for data that cannot be logically invalidated by entering conflicting data in Modeller's user interface. 
		Params:
			name (str): name of the value
			desc (str): new description
			persist (bool, optional): persistence (default false)
		Returns:
			IFDispatch: 
		"""
		pass


	def isThermal(self) -> bool:
		r"""
		Return true if this loadcase is a thermal loadcase 
		Returns:
			bool: 
		"""
		pass


	def isHygro(self) -> bool:
		r"""
		Return true if this loadcase is a hygro-thermal loadcase 
		Returns:
			bool: 
		"""
		pass


	def setEditDialog(self, filename) -> None:
		r"""
		Set name of dialog used to edit this loadset when the "Edit..." context menu is chosen. This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFLoadset.setEditingMenuID or IFLoadset.setDefinitionMenuID 
		Params:
			filename (str): 
		Returns:
			None: 
		"""
		pass


	def setEditingMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this loadset is edited or double-clicked on. The existing menu entry 'Edit...' will be modified in the context menu such that it generates the ID given. When this menu item is chosen by the user, or the loadset is double-clicked, all LUSAS extension modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can no longer view or modify the underlying modeller definition via the "Edit..." menu entry. To enable this, call IFLoadset.setDefinitionMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple types such as strings and integers
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def setDefinitionMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this loadset is edited or double-clicked on. A new menu entry 'Edit definition...' will be automatically added to the context menu, with the ID given. When this menu item is chosen by the user, or the loadset is double-clicked, all LUSAS extension modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can still view and modify the underlying modeller definition via the "Edit..." menu entry. To disable this, call IFLoadset.setEditingMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple data types like strings and integers.
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def getEditingMenuID(self, isRelativeID=None) -> int:
		r"""
		Retrieve the menu ID that was set using setDefinitionMenuID 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def getDefinitionMenuID(self, isRelativeID=None) -> int:
		r"""
		Retrieve the menu ID that was set using setEdttingMenuID 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def setDoubleClickDialog(self, filename=None) -> None:
		r"""
		Set name of dialog used to edit this loadset when it is double clicked in the treeview. This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFLoadset.setEditingMenuID or IFLoadset.setDefinitionMenuID 
		Params:
			filename (str, optional): If given, sets the dialog. If not given, reset to internal default dialog
		Returns:
			None: 
		"""
		pass


	def insertContextMenuItem(self, beforeItem, itemText, command, helpString=None, sessionFile=None) -> None:
		r"""
		Inserts a new menu item before the specified item in the context (right click) menu for this loadset. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
			itemText (str): text of new item
			command (str): command to execute when menu item selected
			helpString (str, optional): help string to be displayed in status bar when cursor hovers over menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def removeContextMenuItem(self, itemText, sessionFile=None) -> None:
		r"""
		Removes a context menu item previously added with IFLoadset.insertContextMenuItem. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			itemText (str): text of context menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this loadset contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def removeExternalDefinition(self) -> None:
		r"""
		Remove all traces of externally applied definitions, such as those added using IFLoadset.setEditingMenuID, IFLoadset.setDefinitionMenuID, and IFLoadset.setDoubleClickDialog(). This has the effect of breaking the link to the external definition (usually a library or similar) 
		Returns:
			None: 
		"""
		pass


	def getIDAndName(self) -> str:
		r"""
		Returns the ID and name of this loadset, as shown in the modeller treeview Currently it is the same as "getID():getName()" 
		Returns:
			str: the returned name
		"""
		pass


	def saveIntArray(self, name, array) -> None:
		r"""
		Preserves a named array of integers in this loadset LUSAS will not examine the integers, or use them in any way, but it will preserve them in the mdl file for later retreival using loadIntArray This mechanism is independent from the getValue / setValue system 
		Params:
			name (str): unique name for the array
			array (array of strs): The array of strings to save
		Returns:
			None: 
		"""
		pass


	def setDescription(self, description=None) -> IFLoadset:
		r"""
		Sets a helpful description to be used in the analysis tree. If no string is given, the loadset will automatically create a description. Note that most loadsets do not yet support this functionality, and therefore the automatically generated description would be blank. Alternatively, the description can be passed to this function in which case it overrides any automatic description 
		Params:
			description (str, optional): description to attach
		Returns:
			IFLoadset: 
		"""
		pass


	def getDescription(self) -> str:
		r"""
		returns the description that was added via IFLoadset.setDescription 
		Returns:
			str: 
		"""
		pass


	def getIDAndNameAndDescription(self) -> str:
		r"""
		Returns the ID, name and description of this loadset, as shown in the modeller treeview Currently it is the same as "getID():getName() (getDescription())" 
		Returns:
			str: the returned name
		"""
		pass


	def showOutOfDateWarning(self) -> bool:
		r"""
		return true if this loadset is out of date (with respect to currently loaded results) unlike IFAnalysisBaseClass.needsSolving, this function returns false if results are not loaded (const FInfluenceInterface* pAssign = NULL) const = 0; 
		Returns:
			bool: 
		"""
		pass


class IFGeometryData(IFDispatch):
	"""
	Acts as a storage mechanism for all the values, options and settings that control the manner in which geometry is created or modified. Using an object to store these settings enables all of the geometry creation and modification functions to have a short and simple argument list, and enables the user to use the same set of options when calling many different functions. There is one instance of a geometry options object which is always available to use, IFModeller.geometryData. This is the object which Modeller itself uses when creating session files. However, any number of additional objects can be created at any time using IFModeller.newGeometryData. Each one, as it is created, automatically sets itself up using all the default values for each setting. 
	"""

	def setAllDefaults(self) -> IFGeometryData:
		r"""
		Restores all values to their default state. These default values are hard coded within LUSAS Modeller and can not be changed. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def copiesOnTransform(self, nCopies) -> IFGeometryData:
		r"""
		specifies the number of copies that will be created in a copy operation. The default value is 1. 
		Params:
			nCopies (int): The number of copies
		Returns:
			IFGeometryData: 
		"""
		pass


	def setTransformation(self, transAttr=None) -> IFGeometryData:
		r"""
		specifies the IFTransformationAttr attribute which will be used in move, copy, sweep and similar operations. 
		Params:
			transAttr (IFTransformationAttr, optional): The name or ID of a transformation, or a pointer to a IFTransformationAttr object. The transformation to use
		Returns:
			IFGeometryData: 
		"""
		pass


	def setTransformationOff(self) -> IFGeometryData:
		r"""
		Switches off the transformation, such that the operation will be performed without a transformation (e.g. a copy in situ) 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLocalCoord(self, localAttr) -> IFGeometryData:
		r"""
		Specifies the IFLocalCoord attribute which will be used in move, copy, sweep and similar operations. 
		Params:
			localAttr (IFLocalCoord): The name or ID of a localcoordinate, or a pointer to a IFLocalCoord object. The local coordinate system to use
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLocalCoordOff(self) -> IFGeometryData:
		r"""
		Switches off the local coord transformation, such that any given coordinates will be assumed to be given in global coordinates 
		Returns:
			IFGeometryData: 
		"""
		pass


	def addCoords(self, X, Y=None, Z=None, isGlobal=None) -> IFGeometryData:
		r"""
		Add one or more sets of 3d coordinates to the geometry definition Coordinates can be entered as three values (x,y,z) or as a single dimensional array of three values, or as a two dimensional array. In the latter case the first dimension represents the number of coordinates to be added, the second dimension must be 3 Note that if a local coordinate object has been specified using IFGeometryData.setLocalCoord, the arguments could represent r z and theta. 
		Params:
			X (object): Two dimensional array of doubles. The first dimension is the number coordinates to be added, the second dimension must be 3 (X,Y,Z).
			Y (object, optional): 
			Z (object, optional): 
			isGlobal (object, optional): optional<boolean> default false, true for global coords, false for local coords w.r.t active local coordinates set
		Returns:
			IFGeometryData: 
		"""
		pass


	def setCreateMethod(self, method) -> IFGeometryData:
		r"""
		Specifies the type of object that will be created. The default is "unset" in which case LUSAS Modeller will use the most appropriate value, having analysed the data (i.e. coordinates and lower order features) to be used 
		Params:
			method (str): Valid values are: "unset", "straight", "arc", "spline", "combined", "planar", "cylindrical", "conical", "spherical", "coons", "nurb", "volume", "cylinder", "cone", "cube", "cuboid", "sphere", "tetrahedral", "pentahedral", "hexahedral", "ellipsoid", "ellipse", "lofted"
		Returns:
			IFGeometryData: 
		"""
		pass


	def split(self, logical) -> IFGeometryData:
		r"""
		Specifies whether or not to split existing features upon intersection. For example, intersecting two straight lines creates a point where they intersect, but can optionally also create four new lines, representing the two parts of each of the original lines that meet at the new point 
		Params:
			logical (bool): Whether or not to split existing features
		Returns:
			IFGeometryData: 
		"""
		pass


	def keepMinor(self) -> IFGeometryData:
		r"""
		Specifies a minor arc when creating an arc or ellipse from points, coordinates or tangent between lines. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def keepMajor(self) -> IFGeometryData:
		r"""
		Specifies a major arc when creating an arc or ellipse from points, coordinates or tangent between lines. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def makeCircle(self) -> IFGeometryData:
		r"""
		Specifies a full circle when creating an arc or ellipse from points, coordinates or tangent between lines. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setAxisPointIsMajor(self) -> IFGeometryData:
		r"""
		Specifies that the axis direction given as part of the data to create an ellipse defines the major axis of the ellipse. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setAxisPointIsMinor(self) -> IFGeometryData:
		r"""
		Specifies that the axis direction given as part of the data to create an ellipse defines the minor axis of the ellipse. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def keepInternal(self) -> IFGeometryData:
		r"""
		When creating a tangent between two arcs, specifies internal tangent 
		Returns:
			IFGeometryData: 
		"""
		pass


	def keepExternal(self) -> IFGeometryData:
		r"""
		When creating a tangent between two arcs, specifies external tangent 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setReferenceCoords(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		specifies the reference position used to select particular solutions to a tangent, intersection or projection command.  
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setNoReferenceCoords(self) -> IFGeometryData:
		r"""
		 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setHeight(self, height) -> IFGeometryData:
		r"""
		Specifies the height of a cuboid, cylinder or cone when creating these solids. 
		Params:
			height (float): Height of solid
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLength(self, length) -> IFGeometryData:
		r"""
		Specifies the length of a cuboid or all sides of a cube when creating these solids. 
		Params:
			length (float): Length of solid
		Returns:
			IFGeometryData: 
		"""
		pass


	def setWidth(self, width) -> IFGeometryData:
		r"""
		Specifies the width of a cuboid when creating this solid. 
		Params:
			width (float): Width of solid
		Returns:
			IFGeometryData: 
		"""
		pass


	def setPitch(self, pitch) -> IFGeometryData:
		r"""
		Specifies the pitch of a helix. 
		Params:
			pitch (float): Pitch of helix
		Returns:
			IFGeometryData: 
		"""
		pass


	def setRightHandScrew(self) -> IFGeometryData:
		r"""
		Specifies a right hand thread direction of a helix. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLeftHandScrew(self) -> IFGeometryData:
		r"""
		Specifies a left hand thread direction of a helix. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setOrigin(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		Specify the origin (centre) of a cube, cuboid, cylinder, cone, sphere or ellipsoid when creating these shapes. 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setVectorX(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setVectorY(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setVectorZ(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setStartTangent(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		Specifies the start tangent when creating a spline from points and end tangents 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setEndTangent(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		Specifies the end tangent when creating a spline from points and end tangents 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def addUControlPoint(self, X, Y=None, Z=None) -> IFGeometryData:
		r"""
		 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setRadius(self, radius) -> IFGeometryData:
		r"""
		Sets the radius when creating an arc from coordinates or as tangents to line, the radius when creating a cylinder or sphere, the base radius when creating a cone or the radius along the first axis when creating an ellipsoid. 
		Params:
			radius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setMajorRadius(self, radius) -> IFGeometryData:
		r"""
		Sets the major radius when creating an ellipsoid. 
		Params:
			radius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setMinorRadius(self, radius) -> IFGeometryData:
		r"""
		Sets the minor radius when creating an ellipsoid. 
		Params:
			radius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setRadius2(self, radius) -> IFGeometryData:
		r"""
		Sets the apex radius when creating a cone or the radius along the second axis when creating an ellipsoid. 
		Params:
			radius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setRadius3(self, radius) -> IFGeometryData:
		r"""
		Sets the radius along the third axis when creating an ellipsoid. 
		Params:
			radius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setStartAngleDegrees(self, angleDegrees) -> IFGeometryData:
		r"""
		Sets the start swept angle of an arc derived line map. 
		Params:
			angleDegrees (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setEndAngleDegrees(self, angleDegrees) -> IFGeometryData:
		r"""
		Sets the end swept angle of an arc derived line map. 
		Params:
			angleDegrees (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setStartMiddleEnd(self) -> IFGeometryData:
		r"""
		Indicates that the list of coordinates given to define an arc are the start, middle and end point of the arc. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setStartEndInplane(self) -> IFGeometryData:
		r"""
		Indicates that the list of coordinates given to define an arc are the start point, end point and another point in the same plane as the arc. Note the arcs radius must also be specified. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setStartEndCentre(self) -> IFGeometryData:
		r"""
		Indicates that the list of coordinates given to define an arc or an ellipse are the start, end and centre point of the arc. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setCentreStartInplane(self) -> IFGeometryData:
		r"""
		Indicates that the list of coordinates given to define an arc or an ellipse are the centre, start and a point in the plane of the arc. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setStartCentreSwept(self) -> IFGeometryData:
		r"""
		Indicates that the list of coordinates given to define an arc are the centre, start and a point in the plane of the arc and in the swept direction 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setUserName(self, strName) -> IFGeometryData:
		r"""
		specify the required ID of the next feature to be created, e.g if strName="point23" then the point created by the next point creation command will be 23, similarly, "line2", "surface14", "volume9" 
		Params:
			strName (str): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setMaximumDimension(self, dimension) -> IFGeometryData:
		r"""
		Sets the maximum feature dimension (point=0, line=1, surface=2, volume=3) when creating a cube, cuboid, cylinder, cone, sphere or ellipsoid, when sweeping features or when creating features from mesh, by offsetting or by extruding other features. 
		Params:
			dimension (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def addUKnot(self, knot, pMultiplicity=None) -> IFGeometryData:
		r"""
		add a knot to a bspline or u direction of a bspline surface 
		Params:
			knot (float): 
			pMultiplicity (int, optional): Number of times to add given knot
		Returns:
			IFGeometryData: 
		"""
		pass


	def addVKnot(self, knot, pMultiplicity=None) -> IFGeometryData:
		r"""
		add a knot to the v direction of a bspline surface 
		Params:
			knot (float): 
			pMultiplicity (int, optional): Number of times to add given knot
		Returns:
			IFGeometryData: 
		"""
		pass


	def addUWeight(self, weight) -> IFGeometryData:
		r"""
		add a weight to a bspline or u direction of a bspline surface 
		Params:
			weight (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setUDegree(self, degree) -> IFGeometryData:
		r"""
		set the degree of a bspline or u direction degree of a bspline surface 
		Params:
			degree (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setVDegree(self, degree) -> IFGeometryData:
		r"""
		set the v direction degree of a bspline surface 
		Params:
			degree (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def sweptArcType(self, bMethod) -> IFGeometryData:
		r"""
		When sweeping features using a rotation, specifies the sweep type to be minor, major or straight 
		Params:
			bMethod (str): method of sweep
		Returns:
			IFGeometryData: 
		"""
		pass


	def set3dPlane(self, perpendicular, pointInPlane) -> IFGeometryData:
		r"""
		Defines a plane by a perpendicular vector and a point in the plane. 
		Params:
			perpendicular (coordarray): Vector perpendicular to the plane
			pointInPlane (array of float): An array of 3 real numbers, representing 3d coordinates Coordinates of point in plane
		Returns:
			IFGeometryData: 
		"""
		pass


	def set3dPlaneCoefficients(self, coefficients, coeff) -> IFGeometryData:
		r"""
		Defines a plane with the equation A.x + B.y + C.z = D where 
		Params:
			coefficients (array of float): Array of three numbers, A, B, C
			coeff (float): D
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBooleanSimplify(self, logical) -> IFGeometryData:
		r"""
		Switches on simplification after boolean operator 
		Params:
			logical (bool): = true to simplify
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBooleanReverseOrderOfSubtraction(self, logical) -> IFGeometryData:
		r"""
		Reverses primary/secondary selection order in a boolean subtraction 
		Params:
			logical (bool): = true to reverse order
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBooleanDeletePrimary(self, logical) -> IFGeometryData:
		r"""
		Deletes primary selection after boolean operation 
		Params:
			logical (bool): = true to delete primary selection
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBooleanDeleteSecondary(self, logical) -> IFGeometryData:
		r"""
		Deletes secondary selection after boolean operation 
		Params:
			logical (bool): = true to delete secondary selection
		Returns:
			IFGeometryData: 
		"""
		pass


	def setEmbedInSurface(self, bEmbed) -> IFGeometryData:
		r"""
		Embeds a line/point in a surface after a manifolding operation 
		Params:
			bEmbed (bool): = true to embed feature in surface
		Returns:
			IFGeometryData: 
		"""
		pass


	def deleteIfSplit(self, logical) -> IFGeometryData:
		r"""
		Deletes original objects after a splitting operation 
		Params:
			logical (bool): = true to delete objects
		Returns:
			IFGeometryData: 
		"""
		pass


	def useInDependents(self, logical) -> IFGeometryData:
		r"""
		 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def insertCombinedIntoSurface(self, logical) -> IFGeometryData:
		r"""
		Redefines surfaces using combined lines created by splitting 
		Params:
			logical (bool): = true to redefine surfaces
		Returns:
			IFGeometryData: 
		"""
		pass


	def useLocalSurfaceDirectionX(self, logical) -> IFGeometryData:
		r"""
		When splitting a surface by parametrics indicates whether to split along local x direction or not. 
		Params:
			logical (bool): = true to use local x direction
		Returns:
			IFGeometryData: 
		"""
		pass


	def splitBySinglePoints(self, logical) -> IFGeometryData:
		r"""
		Option to split surfaces using a single point 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def pairOffInSelection(self, logical) -> IFGeometryData:
		r"""
		Process the selection in pairs or not. 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSplitAllSame(self, logical) -> IFGeometryData:
		r"""
		set true if the same splitting data applies to all objects to split 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def addSplitParametric(self, index, value) -> IFGeometryData:
		r"""
		add parametric coordinate to the array 
		Params:
			index (int): array index
			value (float): parametric value
		Returns:
			IFGeometryData: 
		"""
		pass


	def initialiseSplitParametrics(self, size) -> IFGeometryData:
		r"""
		size the parametric splitting coordinates array 
		Params:
			size (int): number of parametric coordinates
		Returns:
			IFGeometryData: 
		"""
		pass


	def addSplitDivisions(self, index, value) -> IFGeometryData:
		r"""
		add splitting divisions array 
		Params:
			index (int): array index
			value (int): number of divisions
		Returns:
			IFGeometryData: 
		"""
		pass


	def initialiseSplitDivisions(self, size) -> IFGeometryData:
		r"""
		size the splitting divisions array 
		Params:
			size (int): number of sets of divisions
		Returns:
			IFGeometryData: 
		"""
		pass


	def splitAtIntersections(self, logical) -> IFGeometryData:
		r"""
		Option to split lines or surfaces at the intersection points or lines 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBooleanSliceDeletePositiveSide(self, logical) -> IFGeometryData:
		r"""
		Delete the objects to the positive side of the slice plane after slicing geometry 
		Params:
			logical (bool): = true to delete positive side
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBooleanSliceDeleteNegativeSide(self, logical) -> IFGeometryData:
		r"""
		Delete the objects to the negative side of the slice plane after slicing geometry 
		Params:
			logical (bool): = true to delete negative side
		Returns:
			IFGeometryData: 
		"""
		pass


	def useSelectionOrder(self, logical) -> IFGeometryData:
		r"""
		If this option is specified as false (the default), LUSAS Modeller will analyse the topology of lower order features to determine the most sensible definition order for construction of a new object. If true, the order in which they are selected determines the order in which they will appear in the perimeter of the new object. 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def createCombinedLine(self, logical) -> IFGeometryData:
		r"""
		create a combined line having created a set of lines from 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def closeEndPoints(self, logical) -> IFGeometryData:
		r"""
		a) If creating a single spline or arc then close the line to define a closed loop defined by a single point. b) Determines whether or not the polyline created by multiple lines constructed at the same time is closed to make a polygon by creating an extra line back to the first point. Only valid if IFGeometryData.createMultipleObjects is also used - otherwise no polyline will be created 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def cycleOffset(self, offset) -> IFGeometryData:
		r"""
		cycle the lines in a surface definition or the surfaces in a volume definition by the given value 
		Params:
			offset (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def cycleReverse(self, logical) -> IFGeometryData:
		r"""
		reverse the points in a line definition or the lines in a surface definition 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def exactOnly(self, logical) -> IFGeometryData:
		r"""
		When creating points by line intersections, considers only exact intersections or not. 
		Params:
			logical (bool): = true for exact intersections only
		Returns:
			IFGeometryData: 
		"""
		pass


	def maxDistance(self, tol) -> IFGeometryData:
		r"""
		Specifies intersection tolerance when creating points by line intersection or projection 
		Params:
			tol (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def numberIntersections(self, numb) -> IFGeometryData:
		r"""
		maximum number of points to create by line intersection or projection, zero indicates all possible solutions 
		Params:
			numb (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setProjectionObjectType(self, objType) -> IFGeometryData:
		r"""
		Sets the type of object to project points onto. 
		Params:
			objType (str): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def facetNumber(self, number) -> IFGeometryData:
		r"""
		number of facets to use along a line or over a surface 
		Params:
			number (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def facetLength(self, length) -> IFGeometryData:
		r"""
		mean edge length of facets along a line or over a surface 
		Params:
			length (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def facetDeviation(self, deviation) -> IFGeometryData:
		r"""
		maximum allowable distance from a facet to the line or surface 
		Params:
			deviation (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def facetAngle(self, angleDegrees) -> IFGeometryData:
		r"""
		minimum allowable angle between adjacent facets along a line 
		Params:
			angleDegrees (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def facetFactor(self, factor) -> IFGeometryData:
		r"""
		factor the existing number of facets along a line or over a surface, e.g if factor=2 then the existing facet tolerance will be adjusted to double the existing number of facets; similarly if factor=0.5 then the existing number of facets will be halved 
		Params:
			factor (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def useFacetFactor(self, logical) -> IFGeometryData:
		r"""
		apply the faceting factor specified ignoring the any specified faceting tolerances 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def facetSurfacesOnly(self, logical) -> IFGeometryData:
		r"""
		apply the facet tolerance only to surfaces 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def facetLinesOnly(self, logical) -> IFGeometryData:
		r"""
		apply the facet tolerance only to lines 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setThickness(self, value) -> IFGeometryData:
		r"""
		When creating features by extruding or offsetting, sets the distance of new feature from original feature 
		Params:
			value (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def thicknessReferencePosition(self, x, y, z) -> IFGeometryData:
		r"""
		A reference position used to define the extrusion or offset direction of a line or surface 
		Params:
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setAwayFromReferencePosition(self) -> IFGeometryData:
		r"""
		When creating features by extruding or offsetting specifies that the new feature is created away from the reference position 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setTowardsReferencePosition(self) -> IFGeometryData:
		r"""
		When creating features by extruding or offsetting specifies that the new feature is created towards the reference position 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setEqualAboutReferencePosition(self) -> IFGeometryData:
		r"""
		When creating features by extruding or offsetting specifies that the new feature is created equispaced about the origin feature 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyRadius(self, radius) -> IFGeometryData:
		r"""
		Change the radius of a arc to the given value 
		Params:
			radius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyRadii(self, majorRadius, minorRadius) -> IFGeometryData:
		r"""
		Change the radii of an ellipse to the given values 
		Params:
			majorRadius (float): 
			minorRadius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyLengthMovingStart(self, length) -> IFGeometryData:
		r"""
		Change the length of a line to the given value maintaining the same end position 
		Params:
			length (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyLengthMovingEnd(self, length) -> IFGeometryData:
		r"""
		Change the length of a line to the given value maintaining the same start position 
		Params:
			length (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyLengthMovingBoth(self, length) -> IFGeometryData:
		r"""
		Change the length of a line to the given value by moving both start and end positions the same amount 
		Params:
			length (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyLengthMovingNeither(self, length) -> IFGeometryData:
		r"""
		Change the length of a line to the given value maintaining both start and end positions 
		Params:
			length (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyAngleDegreesMovingStart(self, angleDegrees) -> IFGeometryData:
		r"""
		Change the swept angle of an arc or ellipse to the given value maintaining the end position 
		Params:
			angleDegrees (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyAngleDegreesMovingEnd(self, angleDegrees) -> IFGeometryData:
		r"""
		Change the swept angle of an arc or ellipse to the given value maintaining the start position 
		Params:
			angleDegrees (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyAngleDegreesMovingBoth(self, angleDegrees) -> IFGeometryData:
		r"""
		Change the swept angle of an arc or ellipse to the given value maintaining by moving start and end positions the same amount 
		Params:
			angleDegrees (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyAngleDegreesMovingNeither(self, angleDegrees) -> IFGeometryData:
		r"""
		Change the swept angle of an arc or ellipse to the given value maintaining both the start and end positions 
		Params:
			angleDegrees (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyPosition(self, x, y, z) -> IFGeometryData:
		r"""
		Change the position of a point to the given coordinates 
		Params:
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyCentre(self, x, y, z) -> IFGeometryData:
		r"""
		Change the centre of an arc or ellipse to the given coordinates 
		Params:
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyMakePlanar(self) -> IFGeometryData:
		r"""
		move the selected points onto the stored plane 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifyMakeLinesPlanar(self) -> IFGeometryData:
		r"""
		move the selected lines onto the stored plane 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifySplineDefnMovingStart(self) -> IFGeometryData:
		r"""
		Change the spline definition moving the start position but maintaining the end position 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifySplineDefnMovingEnd(self) -> IFGeometryData:
		r"""
		Change the spline definition moving the end position but maintaining the start position 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifySplineDefnMovingBoth(self) -> IFGeometryData:
		r"""
		Change the spline definition moving both the start and end positions 
		Returns:
			IFGeometryData: 
		"""
		pass


	def modifySplineDefnMovingNeither(self) -> IFGeometryData:
		r"""
		Change the spline definition maintaining both the start and end positions 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setOffsetFilletType(self, type) -> IFGeometryData:
		r"""
		When creating features by extruding or offsetting specifies that new lines created from originally joined lines should be joined (or filleted) by arcs, straight lines or not at all 
		Params:
			type (str): fillet type = arc/straight/none
		Returns:
			IFGeometryData: 
		"""
		pass


	def setParametricExtensionDistance(self, length) -> IFGeometryData:
		r"""
		When creating points by extending selected points along selected lines specifies the distance to extend the point as a parametric distance of the line 
		Params:
			length (float): parametric distance to extend point
		Returns:
			IFGeometryData: 
		"""
		pass


	def setActualExtensionDistance(self, length) -> IFGeometryData:
		r"""
		When creating points by extending selected points along selected lines specifies the actual distance to extend the point 
		Params:
			length (float): distance to extend point
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeSurfaceHoles(self) -> IFGeometryData:
		r"""
		Specifies that surface holes are to be removed when modifying a surface. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeSurfacePenetration(self) -> IFGeometryData:
		r"""
		Specifies that surface boundary penetration are to be removed when modifying a surface. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeSurfaceHolePenetration(self) -> IFGeometryData:
		r"""
		Specifies that surface hole penetration are to be removed when modifying a surface. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeSurfaceInternalPoints(self) -> IFGeometryData:
		r"""
		Specifies that surface embedded internal points are to be removed when modifying a surface. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeVolumeHoles(self) -> IFGeometryData:
		r"""
		Specifies that volume holes are to be removed when modifying a volume. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeVolumeVoids(self) -> IFGeometryData:
		r"""
		Specifies that volume voids are to be removed when modifying a volume. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeVolumePenetration(self) -> IFGeometryData:
		r"""
		Specifies that volume boundary penetrations are to be removed when modifying a volume. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def deleteAllHolesOn(self) -> IFGeometryData:
		r"""
		Specifies that all holes are to be deleted when modifying a feature. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def deleteAllHolesOff(self) -> IFGeometryData:
		r"""
		Specifies that only selected holes are to be deleted when modifying a feature. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def deleteIfHoleRemovedOn(self) -> IFGeometryData:
		r"""
		delete the lines defining the hole removed from a surface, or delete the surfaces defining the void removed from a volume 
		Returns:
			IFGeometryData: 
		"""
		pass


	def deleteIfHoleRemovedOff(self) -> IFGeometryData:
		r"""
		do not delete the lines defining the hole removed from a surface, or do not delete the surfaces defining the void removed from a volume 
		Returns:
			IFGeometryData: 
		"""
		pass


	def surfaceAcrossHolesOn(self) -> IFGeometryData:
		r"""
		Create surfaces across the selected holes removed from a surface 
		Returns:
			IFGeometryData: 
		"""
		pass


	def surfaceAcrossHolesOff(self) -> IFGeometryData:
		r"""
		Do not create surfaces across the selected holes removed from a surface 
		Returns:
			IFGeometryData: 
		"""
		pass


	def surfaceAcrossAllHolesOn(self) -> IFGeometryData:
		r"""
		Create surfaces across all holes removed from a surface 
		Returns:
			IFGeometryData: 
		"""
		pass


	def surfaceAcrossAllHolesOff(self) -> IFGeometryData:
		r"""
		Do not create surfaces across all holes removed from a surface 
		Returns:
			IFGeometryData: 
		"""
		pass


	def mergeDefiningGeometryOn(self) -> IFGeometryData:
		r"""
		 
		Returns:
			IFGeometryData: 
		"""
		pass


	def mergeDefiningGeometryOff(self) -> IFGeometryData:
		r"""
		 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSliceTranslation(self, x, y, z) -> IFGeometryData:
		r"""
		 
		Params:
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeAllCoords(self) -> IFGeometryData:
		r"""
		remove all coordinates previously added using IFGeometryData.addCoords 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeAllUKnots(self) -> IFGeometryData:
		r"""
		remove all knots previously added using IFGeometryData.addUKnot 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeAllUWeights(self) -> IFGeometryData:
		r"""
		remove all weights previously added using IFGeometryData.addUWeight 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeAllUControlPointCoords(self) -> IFGeometryData:
		r"""
		remove all weights previously added using IFGeometryData.addUControlPoint 
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeAllSplitParametrics(self) -> IFGeometryData:
		r"""
		remove all split parametrics previously added using IFGeometryData.addSplitParametric 
		Returns:
			IFGeometryData: 
		"""
		pass


	def createSingleObject(self) -> IFGeometryData:
		r"""
		When constructing lines from multiple coordinates, indicates that only one line should be constructed to intersect all coordinates given 
		Returns:
			IFGeometryData: 
		"""
		pass


	def createMultipleObjects(self) -> IFGeometryData:
		r"""
		When constructing lines from multiple coordinates, indicates that one line should be constructed between each pair of lines - to form a linked 'polyline'. The function IFGeometryData.closeEndPoints determines whether or not the polyline is closed to make a polygon by creating an extra line back to the first point 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setFitToPoints(self) -> IFGeometryData:
		r"""
		When creating an arc specifies that the arc that best fits the points is created. 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimOuterBoundaryOn(self) -> IFGeometryData:
		r"""
		Trimming lines define the new boundary of the surface to be trimmed 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimOuterBoundaryOff(self) -> IFGeometryData:
		r"""
		Trimming lines define new hole(s) in the surface to be trimmed 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimDeleteOuterBoundaryOn(self) -> IFGeometryData:
		r"""
		Delete the old boundary of the surface to be trimmed 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimDeleteOuterBoundaryOff(self) -> IFGeometryData:
		r"""
		Do not delete the old boundary of the surface to be trimmed 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimDeleteTrimmingLinesOn(self) -> IFGeometryData:
		r"""
		Delete the lines used to trim the surface 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimDeleteTrimmingLinesOff(self) -> IFGeometryData:
		r"""
		Do not delete the lines used to trim the surface 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimHoleByMoving(self) -> IFGeometryData:
		r"""
		switch on surface hole trimming by moving an existing hole 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimBoundaryByMoving(self) -> IFGeometryData:
		r"""
		switch on surface boundary trimming by moving the existing boundary 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimByMovingOff(self) -> IFGeometryData:
		r"""
		switch off surface trimming by moving 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimHoleByCopying(self) -> IFGeometryData:
		r"""
		switch on surface hole trimming by copying an existing hole 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimByCopyingOff(self) -> IFGeometryData:
		r"""
		switch off surface trimming by copying 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimBoundaryByAddition(self) -> IFGeometryData:
		r"""
		switch on surface boundary trimming by addition 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimBoundaryByAdditionOff(self) -> IFGeometryData:
		r"""
		switch off surface boundary trimming by addition 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimBoundaryBySubtraction(self) -> IFGeometryData:
		r"""
		switch on surface boundary trimming by subtraction 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimBoundaryBySubtractionOff(self) -> IFGeometryData:
		r"""
		switch off surface boundary trimming by subtraction 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimHoleByAddition(self) -> IFGeometryData:
		r"""
		switch on surface hole trimming by addition 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimHoleByAdditionOff(self) -> IFGeometryData:
		r"""
		switch off surface hole trimming by addition 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimHoleBySubtraction(self) -> IFGeometryData:
		r"""
		switch on surface hole trimming by subtraction 
		Returns:
			IFGeometryData: 
		"""
		pass


	def trimHoleBySubtractionOff(self) -> IFGeometryData:
		r"""
		switch off surface hole trimming by subtraction 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLowerOrderGeometryType(self, objType) -> IFGeometryData:
		r"""
		Set the lower order feature type for definition commands. This setting allows geometry creation commands to know which data you wish to use to define geometry. For example if points, lines and surfaces are all present in the object set, you can choose which are used to define a volume - depending on which is selected, you may get a very different shape! Note that, if not explicitly specified, the default type depends on the contents of the object on which the creation function is called, as well as the other functions that have been called on "this" data object.
 For example, imagine you have 4 points in the database, 2 of them are selected and additionally some coordinates have been added to "this" data object, then by default:
 IFModeller.database.IFDatabaseOperations.createLine(data) will attempt to create a line passing through all 4 points
 IFModeller.selection.IFDatabaseOperations.createLine(data) will create a line passing through the 2 selected points
 IFModeller.newObjectSet().IFDatabaseOperations.createLine(data) will create a line passing through the coordinates in "data"
 In each case, you can use data.IFGeometryData.setLowerOrderGeometryType() to override this default behaviour and choose whether to create the line by existing points or by coordinates 
		Params:
			objType (str): "coordinates", "points", "lines", "surfaces" or "volumes"
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBaseSurfaceCycle(self, number) -> IFGeometryData:
		r"""
		set number of cycles for base surface of volume 
		Params:
			number (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setBaseSurfaceReverse(self, logical) -> IFGeometryData:
		r"""
		set reverse for base surface of volume 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setCycleType(self, type) -> IFGeometryData:
		r"""
		set the type for the cycle geometry command 
		Params:
			type (str): Valid values are: "local", "cycles", "surface"
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLineExtension(self, logical) -> IFGeometryData:
		r"""
		set true to allow line intersection outside the line ends 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLineNrmExtension(self, normalisedDist) -> IFGeometryData:
		r"""
		set the nornmalised distance extension tolerance 
		Params:
			normalisedDist (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setReverseKeepX(self, logical) -> IFGeometryData:
		r"""
		set true to x direction the same when a surface is reversed 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setReverseKeepY(self, logical) -> IFGeometryData:
		r"""
		set true to y direction the same when a surface is reversed 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setLimitManifoldLines(self, logical) -> IFGeometryData:
		r"""
		set true to chop manifold lines at the manifold points, set false to span the surface from boundary to boundary with the manifold line 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setIgnoreSurfaceHoles(self, logical) -> IFGeometryData:
		r"""
		set true to ignore surface holes when manifolding 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setControlPointSizes(self, isize, jsize) -> IFGeometryData:
		r"""
		set the sizes of the bspline surface control point matrix 
		Params:
			isize (int): 
			jsize (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setControlPointCoords(self, isize, jsize, x, y, z) -> IFGeometryData:
		r"""
		set a control point in the bspline surface control point matrix 
		Params:
			isize (int): 
			jsize (int): 
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setWeight(self, isize, jsize, w) -> IFGeometryData:
		r"""
		set a weight in the bspline surface control point matrix 
		Params:
			isize (int): 
			jsize (int): 
			w (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setNodeMergingTolerance(self, tol) -> IFGeometryData:
		r"""
		specify the tolerance for node merging in an open volume 
		Params:
			tol (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def createArcCentrePoint(self, logical) -> IFGeometryData:
		r"""
		set true to create a point at the new arc centre when creating an arc line by start-end-centre method 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def useSeamsInVolumeOn(self) -> IFGeometryData:
		r"""
		Use seams in surfaces used to create volumes from the volume wizard 
		Returns:
			IFGeometryData: 
		"""
		pass


	def useSeamsInVolumeOff(self) -> IFGeometryData:
		r"""
		Do not use seams in surfaces used to create volumes from the volume wizard 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setUseDeformedOn(self) -> IFGeometryData:
		r"""
		Use deformed node coordinates when converting mesh to geometry 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setUseDeformedOff(self) -> IFGeometryData:
		r"""
		Do not use deformed node coordinates when converting mesh to geometry 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setUseDeformedFactor(self, factor) -> IFGeometryData:
		r"""
		Factor to apply when using deformed node coordinates when converting mesh to geometry 
		Params:
			factor (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setExtractAllVolumes(self) -> IFGeometryData:
		r"""
		extract all possibles volumes from a selection of surface 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setNumberVolumesToExtract(self, number) -> IFGeometryData:
		r"""
		set the maximum number of volumes to extract from a selection of surface 
		Params:
			number (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setReverseStartTangent(self, logical) -> IFGeometryData:
		r"""
		reverse the start tangent of the new spline line tangent to existing lines 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setReverseEndTangent(self, logical) -> IFGeometryData:
		r"""
		reverse the start tangent of the new spline line tangent to existing lines 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSplitTypeParametric(self) -> IFGeometryData:
		r"""
		set splitting distances to parametric distances 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSplitTypeActual(self) -> IFGeometryData:
		r"""
		set splitting distances to actual distances 
		Returns:
			IFGeometryData: 
		"""
		pass


	def set2dMinimumRadius(self, minimumRadius) -> IFGeometryData:
		r"""
		set the 2d polyline minimum fillet radius 
		Params:
			minimumRadius (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def addInternalSurfacePoint(self, point) -> IFGeometryData:
		r"""
		store the given internal surface point 
		Params:
			point (IFPoint): The name or ID of a point, or a pointer to a IFPoint object.
		Returns:
			IFGeometryData: 
		"""
		pass


	def removeAllInternalSurfacePoints(self) -> IFGeometryData:
		r"""
		remove all stored internal surface points 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setHollowVolumeAllowSplit(self, logical) -> IFGeometryData:
		r"""
		set flag to indicate if lines may be split in order to create a geometrically closed hollow volume 
		Params:
			logical (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setMaxSurfLinesExtraction(self, maxAllowableLinesInSurface) -> IFGeometryData:
		r"""
		set the maximum allowable number of lines defining a surface when extracting multiple surfaces from a set of lines 
		Params:
			maxAllowableLinesInSurface (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setMaxSurfFromLineExtraction(self, maxAllowSurfsFromLine) -> IFGeometryData:
		r"""
		set the maximum allowable number of surfaces defined by a line when extracting multiple surfaces from a set of lines 
		Params:
			maxAllowSurfsFromLine (int): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSectionOffset(self, offsetX, offsetY) -> IFGeometryData:
		r"""
		set the 2d polyline minimum fillet radius 
		Params:
			offsetX (float): 
			offsetY (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSectionRotation(self, angleDegs) -> IFGeometryData:
		r"""
		rotate the section CCW by the given angle 
		Params:
			angleDegs (float): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSectionMirrorX(self, doMirror) -> IFGeometryData:
		r"""
		mirror the section in the X axis 
		Params:
			doMirror (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSectionMirrorY(self, doMirror) -> IFGeometryData:
		r"""
		mirror the section in the Y axis 
		Params:
			doMirror (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setSectionSingleSurface(self, oneSurface) -> IFGeometryData:
		r"""
		create surface or multiple surfaces from the section 
		Params:
			oneSurface (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setRenumberOutput(self, renumber) -> IFGeometryData:
		r"""
		Specifies whether or not any objects created are to be automatically renumbered. By default, for most operations, the output set is not renumbered, and therefore the IDs of newy created objects may seem quite unpredictable Any renumbering that does take place would follow the settings from IFDatabase.renumberSettings  
		Params:
			renumber (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


	def setOrientVolumeToAxes(self, doOrientToAxes) -> IFGeometryData:
		r"""
		set true to orientate a cube or cuboid created by the volume shape wizard to the axes used in the creation of the volume 
		Params:
			doOrientToAxes (bool): 
		Returns:
			IFGeometryData: 
		"""
		pass


class IF3dCoords(IFDispatch):
	"""
	 
	"""

	def setX(self, x) -> None:
		r"""
		 
		Params:
			x (float): 
		Returns:
			None: 
		"""
		pass


	def setY(self, y) -> None:
		r"""
		 
		Params:
			y (float): 
		Returns:
			None: 
		"""
		pass


	def setZ(self, z) -> None:
		r"""
		 
		Params:
			z (float): 
		Returns:
			None: 
		"""
		pass


	def setXYZ(self, x, y, z) -> None:
		r"""
		 
		Params:
			x (float): 
			y (float): 
			z (float): 
		Returns:
			None: 
		"""
		pass


	def addX(self, x) -> None:
		r"""
		 
		Params:
			x (float): 
		Returns:
			None: 
		"""
		pass


	def addY(self, y) -> None:
		r"""
		 
		Params:
			y (float): 
		Returns:
			None: 
		"""
		pass


	def addZ(self, z) -> None:
		r"""
		 
		Params:
			z (float): 
		Returns:
			None: 
		"""
		pass


	def getX(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def getY(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def getZ(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def getXYZ(self, X, Y=None, Z=None) -> None:
		r"""
		Return X,Y and Z coordinates of this object. If the first argument is given as an array of 3 doubles, the other two arguments should be omitted, and that array will be changed to contain X, Y, and Z. Otherwise the first argument will be returned as X, the second as Y, and the third as Z 
		Params:
			X (float): X coordinate
			Y (float, optional): Y coordinate
			Z (float, optional): Z coordinate
		Returns:
			None: 
		"""
		pass


	def getLength(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def normalise(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def normaliseMe(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def distanceFromPoint(self, X, Y=None, Z=None) -> float:
		r"""
		 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			float: 
		"""
		pass


	def dotProduct(self, X, Y=None, Z=None) -> float:
		r"""
		 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			float: 
		"""
		pass


	def crossProduct(self, X, Y=None, Z=None) -> list[float]:
		r"""
		 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates
		"""
		pass


	def crossProductCoords(self, pGiven) -> IF3dCoords:
		r"""
		 
		Params:
			pGiven (IF3dCoords): Array of 3 real numbers representing a coordinate axis in 3D space.
		Returns:
			IF3dCoords: 
		"""
		pass


class IF2dCoords(IFDispatch):
	"""
	 
	"""

	def setX(self, x) -> None:
		r"""
		 
		Params:
			x (float): 
		Returns:
			None: 
		"""
		pass


	def setY(self, y) -> None:
		r"""
		 
		Params:
			y (float): 
		Returns:
			None: 
		"""
		pass


	def setXY(self, x, y) -> None:
		r"""
		 
		Params:
			x (float): 
			y (float): 
		Returns:
			None: 
		"""
		pass


	def addX(self, x) -> None:
		r"""
		 
		Params:
			x (float): 
		Returns:
			None: 
		"""
		pass


	def addY(self, y) -> None:
		r"""
		 
		Params:
			y (float): 
		Returns:
			None: 
		"""
		pass


	def getX(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def getY(self) -> float:
		r"""
		 
		Returns:
			float: 
		"""
		pass


	def getXY(self, X, Y) -> None:
		r"""
		 
		Params:
			X (float): X coordinate
			Y (float): Y coordinate
		Returns:
			None: 
		"""
		pass


class IFGraphBase(IFDispatch):
	"""
	Base interface for the Graph and GraphWizard interfaces. Provides the common commands to create a graph 
	"""

	def getTitle(self) -> str:
		r"""
		Return the title of this graph, as previously set using IFGraphBase.setTitle 
		Returns:
			str: The returned title
		"""
		pass


	def setTitle(self, graphName) -> None:
		r"""
		Set a title for this graph. The title will be shown centered above the graph 
		Params:
			graphName (str): Title to set
		Returns:
			None: 
		"""
		pass


	def setXAxisLabel(self, xAxisName) -> None:
		r"""
		 
		Params:
			xAxisName (str): 
		Returns:
			None: 
		"""
		pass


	def setYAxisLabel(self, yAxisName) -> None:
		r"""
		 
		Params:
			yAxisName (str): 
		Returns:
			None: 
		"""
		pass


	def setAxesLabels(self, xAxisName, yAxisName) -> None:
		r"""
		 
		Params:
			xAxisName (str): 
			yAxisName (str): 
		Returns:
			None: 
		"""
		pass


	def showGrid(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def hideGrid(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def setLinearX(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def setLinearY(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def setLogX(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def setLogY(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def minX(self, minX) -> None:
		r"""
		 
		Params:
			minX (float): 
		Returns:
			None: 
		"""
		pass


	def maxX(self, maxX) -> None:
		r"""
		 
		Params:
			maxX (float): 
		Returns:
			None: 
		"""
		pass


	def minY(self, minY) -> None:
		r"""
		 
		Params:
			minY (float): 
		Returns:
			None: 
		"""
		pass


	def maxY(self, maxY) -> None:
		r"""
		 
		Params:
			maxY (float): 
		Returns:
			None: 
		"""
		pass


	def setRanges(self, maxY, minX, maxX, minY) -> None:
		r"""
		 
		Params:
			maxY (float): 
			minX (float): 
			maxX (float): 
			minY (float): 
		Returns:
			None: 
		"""
		pass


	def autoMinX(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def autoMaxX(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def autoMinY(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def autoMaxY(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def createFourierResults(self, entity, combination, angle, nDiv, node, component, pInLoadCase=None) -> list[IFDataset]:
		r"""
		 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			combination (str): 
			angle (float): 
			nDiv (int): 
			node (IFNode): The name or ID of a node, or a pointer to a IFNode object.
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			pInLoadCase (loadcase, optional): 
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createFromLoadCurve(self, loadCurve, applyAssignmentFactor=None) -> list[IFDataset]:
		r"""
		create graph from loadCurve 
		Params:
			loadCurve (IFLoadCurve): The name or ID of a loadcurve, or a pointer to a IFLoadCurve object.
			applyAssignmentFactor (bool, optional): , if T apply the assignment factor
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createFromVariation(self, attr, nValues, factor, line=None) -> list[IFDataset]:
		r"""
		 
		Params:
			attr (IFVariationAttr): The name or ID of a variation, or a pointer to a IFVariationAttr object.
			nValues (int): 
			factor (float): 
			line (name, line, IFLine, optional): 
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def setResultsModalDamping(self, type, modes, viscous=None, structural=None) -> IFGraph:
		r"""
		 
		Params:
			type (str): 
			modes (str): 
			viscous (array of float, optional): 
			structural (array of float, optional): 
		Returns:
			IFGraph: 
		"""
		pass


	def createResultsModalTime(self, restType, respType, node, col, start, end, step, excType) -> list[IFDataset]:
		r"""
		 
		Params:
			restType (str): 
			respType (str): 
			node (int): 
			col (str): 
			start (float): 
			end (float): 
			step (float): 
			excType (int): 
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createResultsModalFrequency(self, restType, respType, node, col, start, end, step, resType, psd=None) -> list[IFDataset]:
		r"""
		 
		Params:
			restType (str): 
			respType (str): 
			node (int): 
			col (str): 
			start (float): 
			end (float): 
			step (float): 
			resType (int): 1=Real, 2=Imaginary,3=Amplitude,4=Phase,5=PSD input,6=PSD response,7=All
			psd (IFPSD, optional): The name or ID of a PSD, or a pointer to a IFPSD object.
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def setPointExcitation(self, type, node, largeMass, component, amplitude=None) -> IFGraph:
		r"""
		 
		Params:
			type (str): "Force", "Displacement", "Velocity", or "Acceleration"
			node (IFNode): The name or ID of a node, or a pointer to a IFNode object.
			largeMass (float): large mass
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			amplitude (float, optional): amplitude
		Returns:
			IFGraph: 
		"""
		pass


	def setRealLoadingExcitation(self, ID, resFile=None, eigen=None, harm=None) -> IFGraph:
		r"""
		 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFGraph: 
		"""
		pass


	def setImaginaryLoadingExcitation(self, ID, resFile=None, eigen=None, harm=None) -> IFGraph:
		r"""
		 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFGraph: 
		"""
		pass


	def setRealImaginaryLoadingExcitation(self, real, imaginary) -> IFGraph:
		r"""
		 
		Params:
			real (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
			imaginary (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFGraph: 
		"""
		pass


	def setSupportMotionExcitation(self, type, motionType, x, y, z) -> IFGraph:
		r"""
		 
		Params:
			type (str): 
			motionType (str): 
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFGraph: 
		"""
		pass


	def setHistoryDump(self, dump, type) -> IFGraph:
		r"""
		 
		Params:
			dump (str): Dump History Sequence. Multiple file, dump and loadcase IDs can be referred to. Example: 1D0:1T31I10, which means result file 1, dump 0, loadcase IDs from 1 to 31 in intervals of 10 (i.e. 1, 11, 21, 31)
			type (str): Results type of dump.
		Returns:
			IFGraph: 
		"""
		pass


	def setHarmonicComponent(self, type) -> None:
		r"""
		Set the component used for harmonic response 
		Params:
			type (str): "real", "imaginary", "amplitude", "phase", or "psd"
		Returns:
			None: 
		"""
		pass


	def openHistory(self, filename) -> None:
		r"""
		Open results history file 
		Params:
			filename (str): History filename
		Returns:
			None: 
		"""
		pass


	def createResultsHistoryNodal(self, entity, component, arg3, arg4, arg5=None) -> IFDataset:
		r"""
		 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			arg3 (str): 
			arg4 (str): 
			arg5 (str, optional): 
		Returns:
			IFDataset: returns dataset just created
		"""
		pass


	def createResultsHistoryGauss(self, entity, component, element, GaussPoint) -> IFDataset:
		r"""
		draws a time history graph of a result at a Gauss point within a solid or surface element 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			element (IFElement): The name or ID of a element, or a pointer to a IFElement object.
			GaussPoint (int): index of the Gauss point to be considered
		Returns:
			IFDataset: returns dataset just created
		"""
		pass


	def createResultsHistoryInternal(self, entity, component, element, internalPoint) -> IFDataset:
		r"""
		draws a time history graph of a result at an internal point within a beam element 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			element (IFElement): The name or ID of a element, or a pointer to a IFElement object.
			internalPoint (int): index of the internal point to be considered
		Returns:
			IFDataset: returns dataset just created
		"""
		pass


	def createNamedVariableHistory(self, name, isNonlinear) -> IFDataset:
		r"""
		 
		Params:
			name (str): 
			isNonlinear (bool): 
		Returns:
			IFDataset: returns dataset just created
		"""
		pass


	def createHistoryEnergyTotal(self, dump, type) -> IFDataset:
		r"""
		 
		Params:
			dump (str): 
			type (str): 
		Returns:
			IFDataset: returns dataset just created
		"""
		pass


	def createSlidelineResults(self, type, component, posX=None, posY=None) -> list[IFDataset]:
		r"""
		 
		Params:
			type (str): "Angle" or "Distance"
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			posX (float, optional): Only needed when type is "Angle". Alternative, can be the node from which the coordinates x, y will be extracted
			posY (float, optional): Only needed when type is "Angle" and posX is not a node
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createThermalSurfaceResults(self, type, component, posX=None, posY=None) -> list[IFDataset]:
		r"""
		 
		Params:
			type (str): "Angle" or "Distance"
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			posX (float, optional): Only needed when type is "Angle". Alternative, can be the node from which the coordinates x, y will be extracted
			posY (float, optional): Only needed when type is "Angle" and posX is not a node
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createSliceResults(self, entity, component, startX, startY, endX, endY, stringX=None, stringY=None, posX=None, posY=None, posZ=None, useAngle=None, matrix=None, corridorWidth=None) -> list[IFDataset]:
		r"""
		Create a graph by 'cutting' the model along a line specified by end coordinates. The line is given in rotated model coordinates, along with the rotation matrix used to rotate them. Only works on surface elements (including the result of a 3d slice through a solid). Optionally the given line may be considered as an arc, by specifying an origin, in which case distances are presented as subtended angles. A corridor width may be given, in which case the program considers three parallel lines, (left, right and centre) and averages values between them (0.25*left + 0.5*centre + 0.25*right) 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			startX (float): rotated model coords X of start of line to 'cut' model
			startY (float): rotated model coords Y of start of line to 'cut' model
			endX (float): rotated model coords X of end of line to 'cut' model
			endY (float): rotated model coords Y of end of line to 'cut' model
			stringX (str, optional): Optional x axis legend (if not given, one will be computed automatically)
			stringY (str, optional): Optional y axis legend (if not given, one will be computed automatically)
			posX (float, optional): Origin x (only used if 'useAngle' is true)
			posY (float, optional): Origin y (only used if 'useAngle' is true)
			posZ (float, optional): Origin z (only used if 'useAngle' is true)
			useAngle (bool, optional): 'distance as angle' checkbox
			matrix (array of float, optional): transformation matrix (usually rotation of current view)
			corridorWidth (float, optional): width of corridor to be averaged
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createSliceResultsByObject(self, entity, component, object, projType, stringX=None, stringY=None, matrix=None, corridorWidth=None) -> list[IFDataset]:
		r"""
		Create a graph by 'cutting' the model along a line specified as an object. Only works on surface elements (including the result of a 3d slice through a solid). The given object may be a line (straight or curved), an annotation line, a reference path, or a previously cut slice graph. A projection vector must be given to convert the given line into a plane which cuts the model. Typically, the projection vector is screen z. A corridor width may be given, in which case the program considers three parallel lines, (left, right and centre) and averages values between them (0.25*left + 0.5*centre + 0.25*right). 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			object (IFDatabaseMember): The name or ID of a databasemember, or a pointer to a IFDatabaseMember object. Object to use to 'cut' model
			projType (str): "Normal to screen", "Normal to line", "Vertically", "In X direction", "In X direction", or "In Z direction"
			stringX (str, optional): Optional x axis legend (if not given, one will be computed automatically)
			stringY (str, optional): Optional y axis legend (if not given, one will be computed automatically)
			matrix (array of float, optional): transformation matrix (usually rotation of current view)
			corridorWidth (float, optional): width of corridor to be averaged
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createSliceResultantEffects(self, sliceType, startX, startY, endX, endY, matrix=None, corridorWidth=None) -> list[IFDataset]:
		r"""
		 
		Params:
			sliceType (str): 
			startX (float): 
			startY (float): 
			endX (float): 
			endY (float): 
			matrix (float, optional): transformation matrix
			corridorWidth (float, optional): width of corridor to be averaged
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createSliceResultantEffectsByObject(self, sliceType, object, projType, matrix=None, corridorWidth=None) -> list[IFDataset]:
		r"""
		 
		Params:
			sliceType (str): 
			object (IFDatabaseMember): The name or ID of a databasemember, or a pointer to a IFDatabaseMember object. Object to use to 'cut' model
			projType (str): "Cut model normal to screen", "Cut model normal to line", or "Cut model vertically"
			matrix (array of float, optional): transformation matrix (usually rotation of current view)
			corridorWidth (float, optional): width of corridor to be averaged
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def createFromPrestress(self, assignments) -> list[IFDataset]:
		r"""
		 
		Params:
			assignments (array of ints): 
		Returns:
			array of IFDataset objects: The datasets just created in array format
		"""
		pass


	def setResultsTransformNone(self) -> None:
		r"""
		Switch off all results transformation for this graph. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformElement(self) -> None:
		r"""
		Use element local axes as the results transformation for this graph. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformXYAngle(self, m_XYAngle) -> None:
		r"""
		Uses the specified angle (in the XY plane - i.e. about Z) as the results transformation for this sub-chapter. 
		Params:
			m_XYAngle (float): 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformLocal(self, localCoordSe, shellPlane) -> None:
		r"""
		Use the specified local coordinate as the results transformation for this graph. 
		Params:
			localCoordSe (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
			shellPlane (int): Shell plane for resultants (1, 2 or 3)
		Returns:
			None: 
		"""
		pass


	def setResultsTransformPath(self, path, skew=None) -> None:
		r"""
		Uses the specified path as the results transformation for this graph 
		Params:
			path (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
			skew (bool, optional): True if local y = transverse
		Returns:
			None: 
		"""
		pass


	def setResultsTransformFeature(self) -> None:
		r"""
		Uses the parent feature's local directions as the results transformation for this graph 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformGlobal(self) -> None:
		r"""
		Uses the global axes directions as the results transformation for this graph 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformAttributeType(self, type) -> None:
		r"""
		Uses the given attribute type to obtain the results transformation for this graph. 
		Params:
			type (object): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def setExtent(self, selectionType, groupName=None) -> None:
		r"""
		Sets the model selection type for this graph 
		Params:
			selectionType (str): selection type (all/visible/group)
			groupName (str, optional): optional only if not group type
		Returns:
			None: 
		"""
		pass


	def setWindowPos(self, x, y, cx, cy) -> None:
		r"""
		Sets the graph window positioning and sizes 
		Params:
			x (int): Position of the left side of the window, in client coordinates.
			y (int): Position of the top of the window, in client coordinates
			cx (int): The width of the window, in pixels.
			cy (int): The height of the window, in pixels.
		Returns:
			None: 
		"""
		pass


	def setTopRightText(self, topRightText) -> None:
		r"""
		Sets the text in the top right corner of the graph 
		Params:
			topRightText (str): Text
		Returns:
			None: 
		"""
		pass


	def setTopLeftText(self, topLeftText) -> None:
		r"""
		Sets the text in the top left corner of the graph 
		Params:
			topLeftText (str): Text
		Returns:
			None: 
		"""
		pass


	def setBottomRightText(self, bottomRightText) -> None:
		r"""
		Sets the text in the bottom right corner of the graph 
		Params:
			bottomRightText (str): Text
		Returns:
			None: 
		"""
		pass


	def setBottomLeftText(self, bottomLeftText) -> None:
		r"""
		Sets the text in the bottom left corner of the graph 
		Params:
			bottomLeftText (str): Text
		Returns:
			None: 
		"""
		pass


	def showModelTitle(self) -> None:
		r"""
		Displays model title on graph 
		Returns:
			None: 
		"""
		pass


	def hideModelTitle(self) -> None:
		r"""
		Hides the model title from graph 
		Returns:
			None: 
		"""
		pass


	def setXAxisPosn(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def setYAxisPosn(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def majorGridColour(self, r, g, b) -> None:
		r"""
		 
		Params:
			r (int): 
			g (int): 
			b (int): 
		Returns:
			None: 
		"""
		pass


	def minorGridColour(self, r, g, b) -> None:
		r"""
		 
		Params:
			r (int): 
			g (int): 
			b (int): 
		Returns:
			None: 
		"""
		pass


	def majorGridStyle(self, style) -> None:
		r"""
		 
		Params:
			style (str): 
		Returns:
			None: 
		"""
		pass


	def minorGridStyle(self, style) -> None:
		r"""
		 
		Params:
			style (str): 
		Returns:
			None: 
		"""
		pass


	def majorGridWidth(self, w) -> None:
		r"""
		 
		Params:
			w (int): 
		Returns:
			None: 
		"""
		pass


	def minorGridWidth(self, w) -> None:
		r"""
		 
		Params:
			w (int): 
		Returns:
			None: 
		"""
		pass


	def showMinorGrid(self, rX, rY) -> None:
		r"""
		 
		Params:
			rX (int): 
			rY (int): 
		Returns:
			None: 
		"""
		pass


	def hideMinorGrid(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def logGraph(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def linearGraph(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def autoScaling(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def setMajorTickColour(self, axis, r, g, b) -> None:
		r"""
		 
		Params:
			axis (str): 
			r (int): 
			g (int): 
			b (int): 
		Returns:
			None: 
		"""
		pass


	def setMajorTickSize(self, axis, s) -> None:
		r"""
		 
		Params:
			axis (str): 
			s (int): 
		Returns:
			None: 
		"""
		pass


	def setMajorTickWidth(self, axis, w) -> None:
		r"""
		 
		Params:
			axis (str): 
			w (int): 
		Returns:
			None: 
		"""
		pass


	def setMinorTickColour(self, axis, r, g, b) -> None:
		r"""
		 
		Params:
			axis (str): 
			r (int): 
			g (int): 
			b (int): 
		Returns:
			None: 
		"""
		pass


	def setMinorTickRatio(self, axis, r) -> None:
		r"""
		 
		Params:
			axis (str): 
			r (int): 
		Returns:
			None: 
		"""
		pass


	def setMinorTickSize(self, axis, s) -> None:
		r"""
		 
		Params:
			axis (str): 
			s (float): 
		Returns:
			None: 
		"""
		pass


	def setMinorTickWidth(self, axis, w) -> None:
		r"""
		 
		Params:
			axis (str): 
			w (int): 
		Returns:
			None: 
		"""
		pass


	def setTickInside(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def setTickOutside(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def showTicks(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def hideTicks(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def showMinorTicks(self, axis, r) -> None:
		r"""
		 
		Params:
			axis (str): 
			r (int): 
		Returns:
			None: 
		"""
		pass


	def hideMinorTicks(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def setAxisLabelResolution(self, axis, d) -> None:
		r"""
		 
		Params:
			axis (str): 
			d (float): 
		Returns:
			None: 
		"""
		pass


	def setAxisLabelAutoOrientation(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def setAxisLabelOrientation(self, axis, angle, posn) -> None:
		r"""
		 
		Params:
			axis (str): 
			angle (float): 
			posn (str): 
		Returns:
			None: 
		"""
		pass


	def setAxisLabelTextStyle(self, axis, nsf, ndp) -> None:
		r"""
		 
		Params:
			axis (str): 
			nsf (int): 
			ndp (int): 
		Returns:
			None: 
		"""
		pass


	def setAxisLabelInside(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


	def setAxisLabelOutside(self, axis) -> None:
		r"""
		 
		Params:
			axis (str): 
		Returns:
			None: 
		"""
		pass


class IFGraphWizardCurve(IFDispatch):
	"""
	Data that are associated with the curves in the graph wizard attribute 
	"""

	def dataNames(self, xDataName, yDataName) -> None:
		r"""
		Sets the title for the x and y data 
		Params:
			xDataName (str): 
			yDataName (str): 
		Returns:
			None: 
		"""
		pass


	def autoLegend(self) -> None:
		r"""
		Specifies that the legend will be created automatically 
		Returns:
			None: 
		"""
		pass


	def setLegendText(self, lText) -> None:
		r"""
		Sets the text to be used as the legend, and turns off the automatic legend 
		Params:
			lText (str): 
		Returns:
			None: 
		"""
		pass


	def setLineColour(self, red, green, blue) -> None:
		r"""
		Sets colour of curve line (and frame of symbols) using rgb values 
		Params:
			red (int): 0..255
			green (int): 0..255
			blue (int): 0..255
		Returns:
			None: 
		"""
		pass


	def setLineStyle(self, style) -> None:
		r"""
		Set curve line style 
		Params:
			style (str): solid, dash, dot, none
		Returns:
			None: 
		"""
		pass


	def setLineWidth(self, w) -> None:
		r"""
		Set curve line thickness 
		Params:
			w (int): 
		Returns:
			None: 
		"""
		pass


	def hideSymbols(self) -> None:
		r"""
		Hides symbols on curve 
		Returns:
			None: 
		"""
		pass


	def showSymbols(self, type) -> None:
		r"""
		Shows symbols on curve and specifies symbol type 
		Params:
			type (str): 
		Returns:
			None: 
		"""
		pass


	def autoSymbolSize(self) -> None:
		r"""
		Specifies auto-sizing of symbols is to be used 
		Returns:
			None: 
		"""
		pass


	def setSymbolHeight(self, h) -> None:
		r"""
		Sets size of symbol in 10's of pixels 
		Params:
			h (int): 
		Returns:
			None: 
		"""
		pass


	def setSegments(self, nSegs) -> None:
		r"""
		Set frequency of symbols 
		Params:
			nSegs (int): 
		Returns:
			None: 
		"""
		pass


	def setSymbolFillStyle(self, fill) -> None:
		r"""
		Sets symbol fill style 
		Params:
			fill (str): "None", "Shade" or "Solid"
		Returns:
			None: 
		"""
		pass


	def setSymbolShadeAngle(self, a) -> None:
		r"""
		Sets the angle for symbol shading 
		Params:
			a (float): 
		Returns:
			None: 
		"""
		pass


	def setSymbolColour(self, red, green, blue) -> None:
		r"""
		Sets colour of symbol fill using rgb values 
		Params:
			red (int): 0..255
			green (int): 0..255
			blue (int): 0..255
		Returns:
			None: 
		"""
		pass


	def setSymbolStartColour(self, red, green, blue) -> None:
		r"""
		Sets colour of symbol fill using rgb values 
		Params:
			red (int): 0..255
			green (int): 0..255
			blue (int): 0..255
		Returns:
			None: 
		"""
		pass


	def setSymbolEndColour(self, red, green, blue) -> None:
		r"""
		Sets colour of symbol fill using rgb values 
		Params:
			red (int): 0..255
			green (int): 0..255
			blue (int): 0..255
		Returns:
			None: 
		"""
		pass


	def setSymbolWidth(self, w) -> None:
		r"""
		Sets size of symbol in 10's of pixels 
		Params:
			w (int): 
		Returns:
			None: 
		"""
		pass


class IFDialog(IFDispatch):
	"""
	Standard interface to any kind of dialog 
	"""

	def showDialog(self) -> bool:
		r"""
		Show the dialog. Returns TRUE if OK button pressed, FALSE otherwise. 
		Returns:
			bool: 
		"""
		pass


class IFResultsComponentSet(IFDispatch):
	"""
	A container for a set of single results components. E.g. for a 2d beam, "Fx", "Fy", and "Mz" would form one 'set'. Other 'sets' may contain principals, equivalents, wood-armer, etc. May store Gauss point, internal point, nodal, element nodal, and/or inspection location results. The results are logically contained within a loadcase, a transformation, an entity, and (for envelopes) a primary component. It is possible (and typical) to store multiple related components within the same component object. For example, all Wood Armer results would typically reside within the same object.
 Please note that the calling conventions of these subroutines prohibit their use in VBScript and other similar languages that require weakly typed (VARIANT) arguments. VARIANTS can lead to slow performance, whereas higher languages (such as VB.NET) can exploit the strongly typed arguments, and gain a speed advantage. Please use the older IFNode.getResults and similar functions for VBScript and similar languages.
 Note that the results within an IFResultsComponentSet are "captured" at a particular moment in time and do not update in response to changes to the current view, or the IFResultsContext that was used to create those results.
 For example, you can create a IFResultsContext, use it to create an IFResultsComponentSet, and inquire the results. You can then change the active loadcase in that context, and the results in the IFResultsComponentSet DO NOT CHANGE. Thus, you can use that context to create another IFResultsComponentSet, which are from the newly active loadcase, and compare the two different sets of results.
 This is quite natural and logical when using the functions herein, but could perhaps be confusing if you pass an IFResultsComponentSet object to functions like IFNode.getResults.
 Deleting the context that was used to create the IFResultsComponentSet does not delete the IFResultsComponentSet. Results for all elements in an IFResultsComponentSet object remain cached, using up quite a lot of memory, until that IFResultsComponentSet object is released, for example (in VBScript) by setting the last pointer to "nothing", or (in .NET) by forcing the garbage collection using FinalReleaseComObject. 
	"""

	def getComponentNumber(self, component) -> int:
		r"""
		Convert from component name to a component number Note that this conversion is a relatively slow operation, and should not be called within (for example) an element loop 
		Params:
			component (str): name of component
		Returns:
			int: 
		"""
		pass


	def getFirstComponentNumber(self) -> int:
		r"""
		Return the number of the first component stored in 'this'. Components are stored consecutively and contiguously 
		Returns:
			int: 
		"""
		pass


	def countComponents(self) -> int:
		r"""
		return the number of components stored within this 
		Returns:
			int: 
		"""
		pass


	def getEntityName(self) -> str:
		r"""
		return the entity name within which this object presents its results 
		Returns:
			str: 
		"""
		pass


	def getComponentName(self, componentNumber) -> str:
		r"""
		Convert from component index within 'this' object to a component name Note that this conversion is a relatively slow operation, and should not be called within a loop 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
		Returns:
			str: 
		"""
		pass


	def getContinuousResults(self, componentNumber, node, units, loadcase) -> float:
		r"""
		equivalent to node.IFNode.getResults(this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			node (IFNode): Node at which results are required
			units (IFUnitSet): The units in which results are required
			loadcase (IFLoadset): Returned: If the loadcase which 'owns' these results is an envelope, the variable will be set to the results loadcase that caused the result
		Returns:
			float: Results value
		"""
		pass


	def getAveragedResults(self, componentNumber, element, node, units, loadcase) -> float:
		r"""
		equivalent to element.IFElement.getAveragedNodeResults(node, this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			node (int): Local index (0..19) of node within element at which results are required
			units (IFUnitSet): The units in which results are required
			loadcase (IFLoadset): Returned: If the loadcase which 'owns' these results is an envelope, the variable will be set to the results loadcase that caused the result
		Returns:
			float: Results value
		"""
		pass


	def getAveragedResultsArray(self, componentNumber, element, units) -> list:
		r"""
		equivalent to element.IFElement.getAveragedNodeResultsArray(node, this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			units (IFUnitSet): The units in which results are required
		Returns:
			array: returned array
		"""
		pass


	def getElementNodalResults(self, componentNumber, element, node, units, loadcase) -> float:
		r"""
		equivalent to element.IFElement.getNodeResults(node, this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			node (int): Local index (0..19) of node within element at which results are required
			units (IFUnitSet): The units in which results are required
			loadcase (IFLoadset): Returned: If the loadcase which 'owns' these results is an envelope, the variable will be set to the results loadcase that caused the result
		Returns:
			float: Results value
		"""
		pass


	def getElementNodalResultsArray(self, componentNumber, element, units) -> list:
		r"""
		equivalent to element.IFElement.getNodeResultsArray(node, this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			units (IFUnitSet): The units in which results are required
		Returns:
			array: returned array
		"""
		pass


	def getGaussResults(self, componentNumber, element, gpIndex, units, loadcase) -> float:
		r"""
		equivalent to element.IFElement.getGaussResults(gpIndex, this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			gpIndex (int): index of Gauss point
			units (IFUnitSet): The units in which results are required
			loadcase (IFLoadset): Returned: If the loadcase which 'owns' these results is an envelope, the variable will be set to the results loadcase that caused the result
		Returns:
			float: Results value
		"""
		pass


	def getGaussResultsArray(self, componentNumber, element, units) -> list:
		r"""
		equivalent to element.IFElement.getGaussResultsArray(this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			units (IFUnitSet): The units in which results are required
		Returns:
			array: returned array
		"""
		pass


	def getInternalResults(self, componentNumber, element, index, units, loadcase) -> float:
		r"""
		equivalent to element.IFElement.getInternalResults(index, this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			index (int): index of internal point
			units (IFUnitSet): The units in which results are required
			loadcase (IFLoadset): Returned: If the loadcase which 'owns' these results is an envelope, the variable will be set to the results loadcase that caused the result
		Returns:
			float: Results value
		"""
		pass


	def getInternalResultsArray(self, componentNumber, element, units) -> list:
		r"""
		equivalent to element.IFElement.getInternalResultsArray(this object, componentNumber) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			units (IFUnitSet): The units in which results are required
		Returns:
			array: returned array
		"""
		pass


	def getInspLocnResults(self, componentNumber, feature, attr, index, units) -> list[float]:
		r"""
		equivalent to feature.getResultsAt(attr, index, this object, componentNumber, units) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			feature (IFGeometry): feature on which to find results
			attr (IFInspectionPoint): attribute defining the location within feature
			index (int): index of location number within attr (corresponds to the row number in the definition dialog) (ignored for inspection locations assigned to points)
			units (IFUnitSet): The units in which results are required
		Returns:
			array of float: returned array
		"""
		pass


	def getLocalResultsInElement(self, componentNumber, element, x, y, z, units) -> float:
		r"""
		will return results at the given location, by interpolating between nearest Gauss points / nodes 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			element (IFElement): Element at which results are required
			x (float): local coord in element
			y (float): local coord in element
			z (float): local coord in element
			units (IFUnitSet): The units in which results are required
		Returns:
			float: Results value
		"""
		pass


	def isValidValue(self, value) -> list[float]:
		r"""
		returns true if the given value is valid. The answer will be false if (for example) you asked for a reaction of an unsupported node, or if you ask for a value from an element that is not in the set of elements showing results, if if you ask for a value of a user defined result that cannot be evaluated (e.g. divide by zero). In practice, this concept is represented using the system parameter DBL_MIN - the smallest positive value that the architecture can represent 
		Params:
			value (float): a value returned by any of the get...Results() methods of this object
		Returns:
			array of float: 
		"""
		pass


	def getFeatureResults(self, componentNumber, feature, type, units, pLocnIndex1, pLocnIndex2) -> float:
		r"""
		equivalent to feature.getResults(type, this object, componentNumber, units) 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			feature (IFGeometry): Feature at which results are required
			type (int): 3 = maximum, 4 = minimum, 5 = absolute 6 = extreme
			units (IFUnitSet): The units in which results are required
			pLocnIndex1 (int): Returned: The node id for nodal results or the element id (for Gauss, internal and elementNodal results) from which the returned value has been calculated
			pLocnIndex2 (int): Returned: 0 for nodal results or the index within the element (for Gauss, internal and elementNodal results) at which the returned value has been calculated
		Returns:
			float: 
		"""
		pass


	def readFromFile(self, filename, locationType) -> None:
		r"""
		write the contents of this results component set to a file 
		Params:
			filename (str): "header" file to read, which contains all the inputs of this object in a textual format - entity, components, loadcase, etc. This file also contains the location of the main "body" data file and the location of a file which contains any appropriate errors
			locationType (str): "Gauss"/"Internal", "Nodal", "ElementNodal", "FeatureMax", "FeatureMin", "FeatureAbs", or "FeatureExt"
		Returns:
			None: 
		"""
		pass


	def dumpToFile(self, filename1, filename2, filename3, locationType, fileType=None) -> None:
		r"""
		write the contents of this results component set to a file 
		Params:
			filename1 (str): "header" file to write, which contains all the inputs of this object in a textual format - entity, components, loadcase, etc
			filename2 (str): "body" file to write, which contains the actual data
			filename3 (str): "error" file to write, which contains any errors that may apply to the data (e.g. when a design check has been applied to an inappropriate member)
			locationType (str): "Gauss"/"Internal", "Nodal", "ElementNodal", "FeatureMax", "FeatureMin", "FeatureAbs", or "FeatureExt"
			fileType (str, optional): "text" or "binary". Only used for filename2. filename1 is always written in text format
		Returns:
			None: 
		"""
		pass


	def getGraphSliceData(self, componentNumber, pLine, distances, values) -> None:
		r"""
		Use the given inspection line as the location of a "graph through 2d". Returns the values of the given component at each intersection with each element, and the distances of those intersections along the graph 
		Params:
			componentNumber (int): number of component (as returned by IFResultsComponentSet.getComponentNumber())
			pLine (IFInspectionLine): location of the graph
			distances (array of reals): distances along graph (x axis)
			values (array of reals): values of component (y axis) setContinuousResult(componentNumber, node, value);            use node.setScriptedResults setAveragedResult(componentNumber, element, node, value);     use ele.setAveragedScriptedResults setElementNodalResult(componentNumber, element, node, value); use ele.setNodeScriptedResults setGaussResult(componentNumber, element, gp, value);          use ele.setGaussScriptedResults setInternalResult(componentNumber, element, gp, value);       use ele.setInternalScriptedResults
		Returns:
			None: 
		"""
		pass


class IFResultsContext(IFDispatch):
	"""
	Contains all the settings and option that apply to results For example, transformations, wood armer data, active set of elements, etc. May be passed in to functions like IFNode.getResults to allow fine control of such settings 
	"""

	def setFourierAngle(self, angle) -> IFResultsContext:
		r"""
		Specify the angle to be used with post-processing of fourier elements 
		Params:
			angle (float): 
		Returns:
			IFResultsContext: 
		"""
		pass


	def getFourierAngle(self, angle) -> None:
		r"""
		Retrieve the angle to be used with post-processing of fourier elements 
		Params:
			angle (float): 
		Returns:
			None: 
		"""
		pass


	def getShowResultsSet(self) -> IFObjectSet:
		r"""
		Returns the set of objects currently showing results 
		Returns:
			IFObjectSet: 
		"""
		pass


	def getCalcResultsSet(self) -> IFObjectSet:
		r"""
		Returns the set of objects currently calculating results 
		Returns:
			IFObjectSet: 
		"""
		pass


	def setResultsTransformNone(self) -> None:
		r"""
		Use 'none' as the results transformation in this context. Calling this function on the view modifies the transformation setting of all currently showing drawing layers and sets the default transformation for new drawing layers, as they are created. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformElement(self) -> None:
		r"""
		Use element local axes as the results transformation in this context. Calling this function on the view modifies the transformation setting of all currently showing drawing layers and sets the default transformation for new drawing layers, as they are created. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view (For continuous results, such as displacement, nodal axes (transformed freedoms) are used) 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformLocal(self, localCoordSet, shellPlane) -> None:
		r"""
		Use the specified local coordinate as the results transformation in this context. Calling this function on the view modifies the transformation setting of all currently showing drawing layers and sets the default transformation for new drawing layers, as they are created. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Params:
			localCoordSet (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
			shellPlane (int): Shell plane for resultants (1, 2 or 3)
		Returns:
			None: 
		"""
		pass


	def setResultsTransformPath(self, path, skew=None) -> None:
		r"""
		Uses the specified path as the results transformation in this context. Calling this function on the view modifies the transformation setting of all currently showing drawing layers and sets the default transformation for new drawing layers, as they are created. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Params:
			path (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
			skew (bool, optional): True if local y = transverse
		Returns:
			None: 
		"""
		pass


	def setResultsTransformFeature(self) -> None:
		r"""
		Uses the parent feature's local directions as the results transformation in this context. Calling this function on the view modifies the transformation setting of all currently showing drawing layers and sets the default transformation for new drawing layers, as they are created. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformGlobal(self) -> None:
		r"""
		Uses the global axes directions as the results transformation in this context. Calling this function on the view modifies the transformation setting of all currently showing drawing layers and sets the default transformation for new drawing layers, as they are created. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformAttributeType(self, type) -> None:
		r"""
		Uses the given attribute type (currently limited to "material" and "results transform" to obtain the results transformation in this view. Calling this function modifies the transformation setting of all currently showing drawing layers and sets the default transformation for new drawing layers, as they are created. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Params:
			type (object): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def getNodalResultsMaxMin(self, entity, component, maxValue, minValue, maxNode, minNode) -> None:
		r"""
		For the given results entity and component this function returns the maximum and minimum nodal results values and the nodes at which they occur within this context. Such results are affected by which elements are currently visible, as well as the current loadset, current lamina, current fibre settings and current results transformation 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			maxValue (float): the returned maximum value
			minValue (float): the returned minimum value
			maxNode (IFNode): the returned node at which maximum value occurs
			minNode (IFNode): the returned node at which minimum value occurs
		Returns:
			None: 
		"""
		pass


	def getGaussResultsMaxMin(self, entity, component, maxValue, minValue, maxElement, minElement, maxGaussPoint, minGaussPoint) -> None:
		r"""
		For the given results entity and component this function returns the maximum and minimum Gauss point results values and the element/Gauss point at which they occur within this context. Such results are affected by which elements are currently visible, as well as the current loadset, current lamina, current fibre settings and current results transformation 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			maxValue (float): the returned maximum value
			minValue (float): the returned minimum value
			maxElement (IFElement): the returned element at which maximum value occurs
			minElement (IFElement): the returned element at which minimum value occurs
			maxGaussPoint (int): the returned Gauss point at which maximum value occurs
			minGaussPoint (int): the returned Gauss point at which minimum value occurs
		Returns:
			None: 
		"""
		pass


	def getInternalResultsMaxMin(self, entity, component, maxValue, minValue, maxElement, minElement, maxInternalPoint, minInternalPoint) -> None:
		r"""
		For the given results entity and component this function returns the maximum and minimum internal point results values and the element/internal point at which they occur within this context. Such results are affected by which elements are currently visible, as well as the current loadset, current lamina, current fibre settings and current results transformation 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			maxValue (float): the returned maximum value
			minValue (float): the returned minimum value
			maxElement (IFElement): the returned element at which maximum value occurs
			minElement (IFElement): the returned element at which minimum value occurs
			maxInternalPoint (int): the returned internal point at which maximum value occurs
			minInternalPoint (int): the returned internal point at which minimum value occurs
		Returns:
			None: 
		"""
		pass


	def getElementNodalResultsMaxMin(self, entity, component, maxValue, minValue, maxElement, minElement, maxNode, minNode) -> None:
		r"""
		For the given results entity and component this function returns the maximum and minimum element nodal point results values and the element/node at which they occur within this context. Such results are affected by which elements are currently visible, as well as the current loadset, current lamina, current fibre settings and current results transformation 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			maxValue (float): the returned maximum value
			minValue (float): the returned minimum value
			maxElement (IFElement): the returned element at which maximum value occurs
			minElement (IFElement): the returned element at which minimum value occurs
			maxNode (int): the returned local node at which maximum value occurs. Use IFElement.getNodes to access the node object
			minNode (int): the returned local node at which minimum value occurs. Use IFElement.getNodes to access the node object
		Returns:
			None: 
		"""
		pass


	def getResultsEntityNames(self) -> list[str]:
		r"""
		Creates and returns an array of valid entity names. Which names are returned will be affected by which elements are currently visible, as well as the current loadset, current lamina, current fibre settings and current results transformation 
		Returns:
			array of strs: the returned array of names
		"""
		pass


	def getResultsComponentNames(self, resType) -> list[str]:
		r"""
		Creates and returns an array of valid component names for the given results entity. Which names are returned will be affected by which elements are currently visible, as well as the current loadset, current lamina, current fibre settings and current results transformation 
		Params:
			resType (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
		Returns:
			array of strs: the returned array of names
		"""
		pass


	def setActiveLamina(self, laminate, lamina) -> None:
		r"""
		Set active the given lamina (layer) belonging to the given laminate (composite attribute). Thus, if this function is called with the lamina name 'layer1', and the laminate 'bob', only elements with an assignment to 'bob' will be affected. The active lamina is the one that is used for visualisation and results plots There is always an active lamina, even if the currently requested results or visualisation do not require it (in which case it is ignored). 
		Params:
			laminate (IFComposite): The name or ID of a composite, or a pointer to a IFComposite object. Specifies a composite attribute
			lamina (str): 
		Returns:
			None: 
		"""
		pass


	def setActiveLaminaName(self, lamina) -> None:
		r"""
		Set active the given lamina (layer) name, independently of any particular laminate (composite attribute). Thus, if this function is called with the lamina name 'layer1', any elements containing a lamina named 'layer1' (from any laminate) will be affected. The active lamina is the one that is used for visualisation and results plots There is always an active lamina, even if the currently requested results or visualisation do not require it (in which case it is ignored). 
		Params:
			lamina (str): 
		Returns:
			None: 
		"""
		pass


	def setActiveFibre(self, geomCSBeam, fibre) -> None:
		r"""
		Set active the given fibre belonging to the given geometric beam attribute. Thus, if this function is called with the fibre name 'fibre1', and the attribute 'bob', only elements with an assignment to 'bob' will be affected. The active fibre is the one that is used for visualisation and results plots There is always an active fibre, even if the currently requested results or visualisation do not require it (in which case it is ignored). 
		Params:
			geomCSBeam (IFGeometric): The name or ID of a geometric, or a pointer to a IFGeometric object. specifies a geometric cross section beam attribute
			fibre (str): fibre name
		Returns:
			None: 
		"""
		pass


	def setActiveFibreName(self, fibre) -> None:
		r"""
		Set active the given fibre name, independently of any particular geometric beam attribute. Thus, if this function is called with the lamina name 'fibre1', any elements containing a fibre named 'fibre1' (from any geometric beam attribute) will be affected. The active fibre is the one that is used for visualisation and results plots There is always an active fibre, even if the currently requested results or visualisation do not require it (in which case it is ignored). 
		Params:
			fibre (str): fibre name
		Returns:
			None: 
		"""
		pass


	def setActiveLoadset(self, ID, resFile=None, eigen=None, harm=None) -> None:
		r"""
		Specify which loadcase is used for visualisation and results processing in this context. Use this function for simple loadcase types that do not need a primary component. Note that you cannot use this function to mean "no coincident effects" - you must use IFResultsContext.setActiveLoadsetAssocVal() with a primary component of "all"  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			None: 
		"""
		pass


	def setActiveLoadsetAssocVal(self, entity, component, ID, resFile=None, eigen=None, harm=None) -> None:
		r"""
		Specify which loadcase is used for results processing in this context. Use this function when setting active a loadcase type (such as an envelope or combination) which needs a primary component. Note - a primary component of "All" means "no coincident effects" which in turn means "each component calculated independently". When calling this function in view, you must also re-specify the results transformations for the context, to force all the individual drawing layers to use the same transformation. Failure to do this will lead to erroneous output.  
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			None: 
		"""
		pass


	def getActiveLoadset(self) -> IFLoadset:
		r"""
		Returns the loadset which has previously been set active in this context. Note that this loadset will either be a pre- or post-processing loadset. Pre-processing loadsets are used to define the behaviour of the model and can be used for visualising attributes and their assignments in the view. Post-processing loadset are created by the solution and can be used to access/view results. There is a strong link between any given post-processing loadset and the pre-processing loadset that created it. Thus, if the currently active loadset is a post-processing loadset, it is possible to call IFResultsContext.getActivePreLoadset to obtain the pre-processing equivalent. Similarly, in linear jobs only, if the currently active loadset is a pre-processing loadset, it is possible to call IFResultsContext.getActivePostLoadset to obtain the post-processing equivalent. 
		Returns:
			IFLoadset: 
		"""
		pass


	def getActivePreLoadset(self) -> IFLoadset:
		r"""
		Returns the loadcase being used for visualisation in this view. Note that if IFResultsContext.getActiveLoadset returns a results processing loadset, this function will return the corresponding pre-processing equivalent - i.e. the loadset that was input to the solver. Note also that there are some circumstances when this function will fail, for example if the results file has been opened directly and not on top of a model. Therefore you should always check, using IFResultsContext.hasActivePreLoadset, before calling this function. 
		Returns:
			IFLoadset: 
		"""
		pass


	def getActivePostLoadset(self) -> IFLoadset:
		r"""
		Returns the loadcase being used for results processing in this context. Note that if IFResultsContext.getActiveLoadset returns a pre-processing loadset, this function will return the corresponding post-processing equivalent - i.e. the loadset that was created by the solver. Note also that there are some circumstances when this function will fail, for example if no results file has been opened. Therefore you should always check, using IFResultsContext.hasActivePostLoadset, before calling this function. 
		Returns:
			IFLoadset: 
		"""
		pass


	def hasActivePreLoadset(self) -> bool:
		r"""
		Returns whether or not there is an active loadcase that can be used for visualisation in this view, in other words, whether or not it is safe to call IFResultsContext.getActivePreLoadset In practice this function returns TRUE unless results have been loaded without a model. 
		Returns:
			bool: 
		"""
		pass


	def hasActivePostLoadset(self) -> bool:
		r"""
		Returns whether or not there is an active loadcase that can be used for results processing in this view, in other words, whether or not it is safe to call IFResultsContext.getActivePostLoadset In practice this function returns TRUE if a post-processing loadset was directly made active, and also for linear jobs where a pre-processing loadset was directly made active. However it returns FALSE for non-linear jobs where a pre-processing loadset was directly made active, because it is not clear which increment or time step is required. 
		Returns:
			bool: 
		"""
		pass


	def getAllActiveLaminae(self) -> list:
		r"""
		Returns a list of all composite laminae that are currently "in use" in this context. In this context, "in use" means: present in any element that is currently showing results. Note therefore, that an empty array will always be returned unless results are loaded. 
		Returns:
			array: the returned array
		"""
		pass


	def setHarmonicComponent(self, type) -> IFResultsContext:
		r"""
		Set the component used for harmonic response 
		Params:
			type (str): "real", "imaginary", "amplitude", "phase", or "psd"
		Returns:
			IFResultsContext: 
		"""
		pass


	def getHarmonicComponent(self) -> str:
		r"""
		Retrieve the value previously specified using IFResultsContext.setHarmonicComponent 
		Returns:
			str: 
		"""
		pass


	def getUserDefinedResultsErrors(self, flushList=None) -> list:
		r"""
		Retrieve an array of the most recent list of errors encountered processing user defined results The array may be very large, as it will include all nodes/elements/features that reported an error, for each requested component (e.g. diagrams and contours may be looking at different components) The array is structured as a N * 5 array, where N is the total number of errors encoutered, col 0 contains the node/element/feature, col 1 contains the index, col 2 contains the error code, col 3 contains the error message if available, col 4 contains the component name. Messages may come from the system (such as "divide by zero") or they may come from the UDR definition itself, via the error() function. The internally stored list of errors is always flushed each redraw, but can optionally also be flushed by this function. 
		Params:
			flushList (bool, optional): default false. If true, the internally stored list will be cleared
		Returns:
			array: 
		"""
		pass


	def copyResultsTransform(self, pContext) -> None:
		r"""
		copy transformation settings from another context into this one 
		Params:
			pContext (IFResultsContext): context from which to copy settings
		Returns:
			None: 
		"""
		pass


	def copyActiveSets(self, pContext) -> None:
		r"""
		copy active sets (visible, show results, calc results) from another context into this one 
		Params:
			pContext (IFResultsContext): context from which to copy settings
		Returns:
			None: 
		"""
		pass


	def copyActiveLamina(self, pContext) -> None:
		r"""
		copy active lamina info from another context into this one 
		Params:
			pContext (IFResultsContext): context from which to copy settings
		Returns:
			None: 
		"""
		pass


	def copyActiveFibre(self, pContext) -> None:
		r"""
		copy active fibre info from another context into this one 
		Params:
			pContext (IFResultsContext): context from which to copy settings
		Returns:
			None: 
		"""
		pass


	def copyActiveLoadcase(self, pContext) -> None:
		r"""
		copy active loadcase info from another context into this one 
		Params:
			pContext (IFResultsContext): context from which to copy settings
		Returns:
			None: 
		"""
		pass


class IFLayer(IFDispatch):
	"""
	Base class for all layers 
	"""

	def moveTo(self, index) -> None:
		r"""
		Move this drawing layer to the position indicated within its parent. 0 means 'move it to be first', 1 means 'move it to be after the first one' and so on. 
		Params:
			index (int): new position
		Returns:
			None: 
		"""
		pass


	def reset(self) -> None:
		r"""
		Reset this drawing layer back to its default settings 
		Returns:
			None: 
		"""
		pass


	def setVisible(self, isVisible) -> None:
		r"""
		Set this drawing layer to either visible or invisible Invisible drawing layers retain all their settings but draw nothing 
		Params:
			isVisible (bool): new state
		Returns:
			None: 
		"""
		pass


	def setTransparent(self, isTransparent) -> None:
		r"""
		Set this drawing layer to either 50% transparent (TRUE) or totally opaque(FALSE). Note that this setting has no effect unless the parent view is allowing transparency with IFView.allowTransparency 
		Params:
			isTransparent (bool): new state
		Returns:
			None: 
		"""
		pass


class IFOptions(IFDispatch):
	"""
	A repository for every global setting and value. 
	"""

	def setDouble(self, keyID, value, setVisible=None, analysisName=None) -> None:
		r"""
		Modifies a double precision option or setting to have a new value 
		Params:
			keyID (str): name of option
			value (float): new value
			setVisible (bool, optional): show this option in the options dialog?
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			None: 
		"""
		pass


	def setInteger(self, keyID, value, setVisible=None, analysisName=None) -> None:
		r"""
		Modifies an integer option or setting to have a new value 
		Params:
			keyID (str): name of option
			value (int): new value
			setVisible (bool, optional): show this option in the options dialog?
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			None: 
		"""
		pass


	def setString(self, keyID, value, setVisible=None, analysisName=None) -> None:
		r"""
		Modifies a string option or setting to have a new value 
		Params:
			keyID (str): name of option
			value (str): new value
			setVisible (bool, optional): show this option in the options dialog?
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			None: 
		"""
		pass


	def setBoolean(self, keyID, value, setVisible=None, analysisName=None) -> None:
		r"""
		Modifies a boolean option or setting to have a new value 
		Params:
			keyID (str): name of option
			value (bool): new value
			setVisible (bool, optional): show this option in the options dialog?
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			None: 
		"""
		pass


	def getDouble(self, keyID, defaultValue, analysisName=None) -> float:
		r"""
		Retrieves the current value of a double precision option or setting 
		Params:
			keyID (str): 
			defaultValue (float): 
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			float: 
		"""
		pass


	def getInteger(self, keyID, defaultValue, analysisName=None) -> int:
		r"""
		Retrieves the current value of an integer option or setting 
		Params:
			keyID (str): 
			defaultValue (int): 
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			int: 
		"""
		pass


	def getString(self, keyID, defaultValue, analysisName=None) -> str:
		r"""
		Retrieves the current value of a string option or setting 
		Params:
			keyID (str): 
			defaultValue (str): 
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			str: 
		"""
		pass


	def getBoolean(self, keyID, defaultValue, analysisName=None) -> bool:
		r"""
		Retrieves the current value of a boolean option or setting 
		Params:
			keyID (str): 
			defaultValue (bool): Boolean to be returned if keyID does not exist
			analysisName (str, optional): Analysis to interrogate; Empty string indicates database (shared by all analyses)
		Returns:
			bool: 
		"""
		pass


class IFExportDataObj(IFDispatch):
	"""
	 
	"""

	def setFilename(self, filename) -> IFExportDataObj:
		r"""
		Sets name of the file to create 
		Params:
			filename (str): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setContent(self, contentStr) -> IFExportDataObj:
		r"""
		 
		Params:
			contentStr (str): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setLevel(self, levelStr) -> IFExportDataObj:
		r"""
		 
		Params:
			levelStr (str): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setDeformedGeomOn(self) -> IFExportDataObj:
		r"""
		Exports mesh using deformed nodal coordinates 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setDeformedGeomOff(self) -> IFExportDataObj:
		r"""
		Exports mesh using undeformed nodal coordinates 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setDeformedGeomFactor(self, factor) -> IFExportDataObj:
		r"""
		Sets scaling factor to be applied to deformed nodal coordinates 
		Params:
			factor (float): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setUpDeformedGeometry(self) -> IFExportDataObj:
		r"""
		 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def addComment(self, comment) -> IFExportDataObj:
		r"""
		Adds a comment to be output to the export file 
		Params:
			comment (str): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def clearComment(self) -> IFExportDataObj:
		r"""
		Removes all stored comments 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setRealNumberSigFig(self, sigfig) -> IFExportDataObj:
		r"""
		Sets the number of significant figures to be used in all real number output 
		Params:
			sigfig (int): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setElementType(self, elementTypeStr) -> IFExportDataObj:
		r"""
		 
		Params:
			elementTypeStr (str): "structural" or "thermal"
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setElementOutput(self, elementSelTypeStr, iElementOut, iElementHis) -> IFExportDataObj:
		r"""
		Sets element output control parameters 
		Params:
			elementSelTypeStr (str): 
			iElementOut (int): 
			iElementHis (int): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setNodeOutput(self, nodeSelTypeStr, iNodeOut, iNodeHis) -> IFExportDataObj:
		r"""
		Sets node output control parameters 
		Params:
			nodeSelTypeStr (str): 
			iNodeOut (int): 
			iNodeHis (int): 
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setUsersName(self, usersName) -> IFExportDataObj:
		r"""
		Sets the string to be output as the user name 
		Params:
			usersName (str): user name parameter string
		Returns:
			IFExportDataObj: 
		"""
		pass


	def setUsersOrganisation(self, usersOrganisation) -> IFExportDataObj:
		r"""
		Sets the string to be output as the user organisation 
		Params:
			usersOrganisation (str): user organisation parameter string
		Returns:
			IFExportDataObj: 
		"""
		pass


class IFLusasRunOptionsObj(IFDispatch):
	"""
	 
	"""

	def setAllDefaults(self) -> IFLusasRunOptionsObj:
		r"""
		Sets all default values 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def waitForSolution(self, wait) -> IFLusasRunOptionsObj:
		r"""
		Waits for solution to complete 
		Params:
			wait (bool): 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def createOwnWindow(self, hasOwnWindow) -> IFLusasRunOptionsObj:
		r"""
		 
		Params:
			hasOwnWindow (bool): 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def runRemote(self, machineName) -> IFLusasRunOptionsObj:
		r"""
		 
		Params:
			machineName (str): 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def runVersion(self, versionStr) -> IFLusasRunOptionsObj:
		r"""
		 
		Params:
			versionStr (str): 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def removeThermalOption(self) -> IFLusasRunOptionsObj:
		r"""
		Sets all default values 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def setRequiredLicense(self, requiredLicense) -> IFLusasRunOptionsObj:
		r"""
		 
		Params:
			requiredLicense (str): 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def setRequiredOptions(self, requiredOptions) -> IFLusasRunOptionsObj:
		r"""
		 
		Params:
			requiredOptions (str): 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


class IFImportDataObj(IFDispatch):
	"""
	 
	"""

	def setFilename(self, filename) -> IFImportDataObj:
		r"""
		Sets up the name of the file to be imported 
		Params:
			filename (str): name of the file to be imported
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setInformOnErrorOn(self) -> IFImportDataObj:
		r"""
		Outputs a message if an error occurs during import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setInformOnErrorOff(self) -> IFImportDataObj:
		r"""
		Do not output a message if an error occurs during import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setInformOnWarningOn(self) -> IFImportDataObj:
		r"""
		Outputs a message if a warning occurs during import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setInformOnWarningOff(self) -> IFImportDataObj:
		r"""
		Do not output a message if a warning occurs during import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setInformOnProgressOn(self) -> IFImportDataObj:
		r"""
		Switches on output of progress messages during import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setInformOnProgressOff(self) -> IFImportDataObj:
		r"""
		Switches off output of progress messages during import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setSuppressGeometryOn(self) -> IFImportDataObj:
		r"""
		 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setSuppressGeometryOff(self) -> IFImportDataObj:
		r"""
		 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setEntitiesToProcess(self, entityIds) -> IFImportDataObj:
		r"""
		set up a string of entity identifiers to import 
		Params:
			entityIds (str): semi-colon separated list of entity IDs to import
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setFormsDatabaseDebugFileOn(self) -> IFImportDataObj:
		r"""
		create a file for the geometry creation debug output 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setFormsDatabaseDebugFileOff(self) -> IFImportDataObj:
		r"""
		Do not create a file for the geometry creation debug output 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setParserDebugFileOn(self) -> IFImportDataObj:
		r"""
		Creates a file for the file parsing debug output 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setParserDebugFileOff(self) -> IFImportDataObj:
		r"""
		Do not create a file for the file parsing debug output 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setParsingOnlyOn(self) -> IFImportDataObj:
		r"""
		Parsing the file only without creating geometry or attributes 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setParsingOnlyOff(self) -> IFImportDataObj:
		r"""
		Sets parsing only mode off 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setScaleFactor(self, factor) -> IFImportDataObj:
		r"""
		Sets pre-import scaling factor to enable imported geometry to be scaled before creation 
		Params:
			factor (float): scale factor
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeleteUnconnectedLinesOn(self) -> IFImportDataObj:
		r"""
		Deletes all unconnected line post-import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeleteUnconnectedLinesOff(self) -> IFImportDataObj:
		r"""
		Do not delete unconnected line post-import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeleteLinesWithNoSurfacesOn(self) -> IFImportDataObj:
		r"""
		Deletes all lines defining no surfaces post-import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeleteLinesWithNoSurfacesOff(self) -> IFImportDataObj:
		r"""
		Do not delete lines defining no surfaces post-import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeletePointsWithNoLinesOn(self) -> IFImportDataObj:
		r"""
		Deletes all points defining no lines post-import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeletePointsWithNoLinesOff(self) -> IFImportDataObj:
		r"""
		Do not delete points defining no lines post-import 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeleteDependentsOn(self) -> IFImportDataObj:
		r"""
		Deletes geometry marked as dependent in the file imported 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDeleteDependentsOff(self) -> IFImportDataObj:
		r"""
		Do not delete geometry marked as dependent in the file imported 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setExcludedEntityTypes(self, typeNumbers) -> IFImportDataObj:
		r"""
		Sets up a string of entity types to be ignored during import 
		Params:
			typeNumbers (str): semi-colon separated list of entity type names to import
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setDrawingLevelsToProcess(self, level) -> IFImportDataObj:
		r"""
		Sets up a string of level identifiers to be processed during import 
		Params:
			level (str): semi-colon separated list of layer names from which to import objects
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setCurvaturePercentTol(self, percentTol) -> IFImportDataObj:
		r"""
		Sets up the maximum allowable percentage ratio of minimum radius of curvature to line length 
		Params:
			percentTol (float): maximum allowable percentage ration of minimum radius of curvature to line length
		Returns:
			IFImportDataObj: 
		"""
		pass


	def lockMeshPostImport(self) -> IFImportDataObj:
		r"""
		Locks the mesh after import is complete 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setOnTopOfExistingModel(self, flag) -> IFImportDataObj:
		r"""
		Sets true is importing on top of existing model 
		Params:
			flag (bool): 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setMergePostImportOff(self) -> IFImportDataObj:
		r"""
		Switches off the post-import geometry merging 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setMergePostImportOn(self, tol) -> IFImportDataObj:
		r"""
		Switches on the post-import geometry merging using the specified tolerance 
		Params:
			tol (float): merge tolerance to use
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setCreateSolidOff(self) -> IFImportDataObj:
		r"""
		Imported model may or may not form solid volume(s) 
		Returns:
			IFImportDataObj: 
		"""
		pass


	def setCreateSolidOn(self) -> IFImportDataObj:
		r"""
		Imported model should form solid volume(s) 
		Returns:
			IFImportDataObj: 
		"""
		pass


class IFElementDataObj(IFDispatch):
	"""
	Element Data 
	"""

	def setAllDefaults(self) -> IFElementDataObj:
		r"""
		Sets all default values 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def setOrientation(self, orientationNodes) -> IFElementDataObj:
		r"""
		 
		Params:
			orientationNodes (array of IFNode objects): 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def setEndReleaseTypes(self, startNodeReleasedFreedoms, endNodeReleasedFreedoms) -> IFElementDataObj:
		r"""
		 
		Params:
			startNodeReleasedFreedoms (array of ints): 
			endNodeReleasedFreedoms (array of ints): 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def setOrientationOff(self) -> IFElementDataObj:
		r"""
		 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def setEndReleasesOff(self) -> IFElementDataObj:
		r"""
		 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def setUserName(self, userName) -> IFElementDataObj:
		r"""
		 
		Params:
			userName (int): 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def setCoupledId(self, coupledId) -> IFElementDataObj:
		r"""
		 
		Params:
			coupledId (int): 
		Returns:
			IFElementDataObj: 
		"""
		pass


class IFFeatureToken(IFDispatch):
	"""
	a token that represents a feature 
	"""

	def isValid(self, featureRequired) -> bool:
		r"""
		Add straight line to tendon 
		Params:
			featureRequired (int): 
		Returns:
			bool: 
		"""
		pass


class IFGridWindow(IFDispatch):
	"""
	Common behaviour between IFPrintResultsWindow and IFLPIGridWindow 
	"""

	def setCurrent(self) -> IFGridWindow:
		r"""
		Set this window active 
		Returns:
			IFGridWindow: 
		"""
		pass


	def setCurrentTab(self, tabName) -> IFGridWindow:
		r"""
		Activate named tab 
		Params:
			tabName (str): name of tab to be activated
		Returns:
			IFGridWindow: 
		"""
		pass


	def saveAs(self, fileName, fileType) -> IFGridWindow:
		r"""
		Save active tab to file 
		Params:
			fileName (str): name of the file to create
			fileType (str): file type; two possible values: 'Microsoft Excel' or 'Text'
		Returns:
			IFGridWindow: 
		"""
		pass


	def saveAllAs(self, fileName, fileType) -> IFGridWindow:
		r"""
		Save all tabs to file 
		Params:
			fileName (str): name of the file to create
			fileType (str): file type; two possible values: 'Microsoft Excel' or 'Text'
		Returns:
			IFGridWindow: 
		"""
		pass


	def close(self) -> None:
		r"""
		close this print results window 
		Returns:
			None: 
		"""
		pass


class IFAnalysisBaseClass(IFDispatch):
	"""
	Analysis base class interface 
	"""

	def getName(self) -> str:
		r"""
		Returns the name of this analysis 
		Returns:
			str: the returned name
		"""
		pass


	def isBase(self) -> bool:
		r"""
		Determine whether this analysis currently serves as the base analysis 
		Returns:
			bool: 
		"""
		pass


	def isThermal(self) -> bool:
		r"""
		Return true if this analysis is a thermal analysis 
		Returns:
			bool: 
		"""
		pass


	def isHygro(self) -> bool:
		r"""
		Return true if this analysis is a hygro-thermal analysis 
		Returns:
			bool: 
		"""
		pass


	def hasResults(self) -> bool:
		r"""
		Determine whether this analysis has results loaded 
		Returns:
			bool: 
		"""
		pass


	def getFilenameNoExtension(self) -> str:
		r"""
		Return the base part of the filenames associated with this analysis. The returned value will generally be of the form "C:\path\model~analysis" but this should not be assumed. Callers may safely add file extensions such as ".dat". 
		Returns:
			str: 
		"""
		pass


	def setName(self, analysisName) -> None:
		r"""
		Sets the name of this analysis 
		Params:
			analysisName (str): the new name
		Returns:
			None: 
		"""
		pass


	def getType(self) -> int:
		r"""
		Return the type of this analysis. Valid return values are structural analysis = 1, thermal analysis = 2, direct method influence analysis = 6, reciprocal theorem influence analysis = 7, VLO analysis = 10, cable tuning analysis = 12 
		Returns:
			int: 
		"""
		pass


	def loadDblArray(self, name) -> list[float]:
		r"""
		Retrieves an array saved previously using saveDblArray. If array doesn't exist a null array is returned. This mechanism is independent from the getValue / setValue system 
		Params:
			name (str): name to search for
		Returns:
			array of floats: The returned array of strings
		"""
		pass


	def needsSolving(self, considerChanges, why) -> bool:
		r"""
		Returns true if the analysis needs to be solved, false if the current results are up to date. If the return value is true, 'why' is filled in with a message to explain what aspect of the analysis is out of date. If 'considerChanges' is false, then the answer is based solely on whether or not a valid results file exists on disk. If 'considerChanges' is true, the answer is also based on changes to attribute definitions, attribute assignments, and similar. 
		Params:
			considerChanges (bool): See main description
			why (str): See main description
		Returns:
			bool: 
		"""
		pass


	def setEditDialog(self, filename) -> None:
		r"""
		Set name of dialog used to edit this analysis when the "Edit..." context menu is chosen. This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFAnalysisBaseClass.setEditingMenuID or IFAnalysisBaseClass.setDefinitionMenuID 
		Params:
			filename (str): 
		Returns:
			None: 
		"""
		pass


	def setEditingMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this analysis is edited or double-clicked on. The existing menu entry 'Edit...' will be modified in the context menu such that it generates the ID given. When this menu item is chosen by the user, or the analysis is double-clicked, all LUSAS extension modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can no longer view or modify the underlying modeller definition via the "Edit..." menu entry. To enable this, call IFAnalysisBaseClass.setDefinitionMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple types such as strings and integers
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def setDefinitionMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this analysis is edited or double-clicked on. A new menu entry 'Edit definition...' will be automatically added to the context menu, with the ID given. When this menu item is chosen by the user, or the analysis is double-clicked, all LUSAS extension modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can still view and modify the underlying modeller definition via the "Edit..." menu entry. To disable this, call IFAnalysisBaseClass.setEditingMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple types such as strings and integers
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def getEditingMenuID(self, isRelativeID=None) -> int:
		r"""
		Retrieve the menu ID that was set using setDefinitionMenuID 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def getDefinitionMenuID(self, isRelativeID=None) -> int:
		r"""
		Retrieve the menu ID that was set using setEditingMenuID 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def setDoubleClickDialog(self, filename=None) -> None:
		r"""
		Set name of dialog used to edit this analysis when it is double clicked in the treeview. This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFAnalysisBaseClass.setEditingMenuID or IFAnalysisBaseClass.setDefinitionMenuID 
		Params:
			filename (str, optional): If given, sets the dialog. If not given, reset to internal default dialog
		Returns:
			None: 
		"""
		pass


	def insertContextMenuItem(self, beforeItem, itemText, command, helpString=None, sessionFile=None) -> None:
		r"""
		Inserts a new menu item before the specified item in the context (right click) menu for this analysis. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
			itemText (str): text of new item
			command (str): command to execute when menu item selected
			helpString (str, optional): help string to be displayed in status bar when cursor hovers over menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def removeContextMenuItem(self, itemText, sessionFile=None) -> None:
		r"""
		Removes a context menu item previously added with IFAnalysisBaseClass.insertContextMenuItem. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			itemText (str): text of context menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def removeExternalDefinition(self) -> None:
		r"""
		Remove all traces of externally applied definitions, such as those added using IFAnalysisBaseClass.setEditingMenuID, IFAnalysisBaseClass.setDefinitionMenuID, and IFAnalysisBaseClass.setDoubleClickDialog(). This has the effect of breaking the link to the external definition (usually a library or similar) 
		Returns:
			None: 
		"""
		pass


	def createCopy(self, target=None, copyMaterials=None) -> IFAnalysisBaseClass:
		r"""
		Creates a copy of this analysis and adds it to the panel. Loadcases and their assignments will be copied as well. If "this" analysis is a branch, then it is necessary to specify the loadcase in which the copy will be created Conversely, if "this" analysis is not a branch, the target should not be given 
		Params:
			target (IFLoadcase, optional): The name or ID of a "Loadcase", or a pointer to a IFLoadcase object. Loadcase in which to create copy
			copyMaterials (str, optional): "copy","no copy","inherit" material and composite assignments
		Returns:
			IFAnalysisBaseClass: the new analysis that has been created
		"""
		pass


	def copyAssignmentsFrom(self, sourceAnalysis, attrType=None, attributes=None) -> None:
		r"""
		Copy assignments from the given analysis into this analysis. If only the source analysis is given then all assignments of all attributes will be copied 
		Params:
			sourceAnalysis (IFAnalysisBaseClass): The name or ID of a "Analysis", or a pointer to a IFAnalysisBaseClass object. Analysis from which assignments will be copied
			attrType (str, optional): Type of attributes whose assignments will be copied
			attributes (array, optional): Names and/or numbers of the attributes whose assignments will be copied
		Returns:
			None: 
		"""
		pass


	def getAnalysisResultsFilenames(self) -> list[str]:
		r"""
		return an array of all of the results filenames associated with this analysis (usually there will be only one). Filenames will be returned in a tokenised format e.g. "%DBFolder%\%Modelname%_analysis.mys". Tokens can be expanded, and full valid windows pathname obtained, by using IFModeller.expandPath 
		Returns:
			array of strs: Results filenames
		"""
		pass


	def getAnalysisResultsFileIDs(self) -> list[int]:
		r"""
		return an array of all of the results file IDs associated with this analysis (usually there will be only one). These IDs are used to identify loadcases in the definitions of envelopes and combinations 
		Returns:
			array of ints: Results file IDs
		"""
		pass


	def setValue(self, varName, value, units=None) -> IFDispatch:
		r"""
		Set a value for the given named parameter. A list of valid names may be obtained by calling IFAnalysisBaseClass.getValueNames If an IFUnitSet object (or its name) is given, the value will be assumed to be given in those units. Otherwise it will be assumed to be in the database's current unit system 
		Params:
			varName (str): 
			value (object): 
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValue(self, varName, units=None) -> object:
		r"""
		Returns the value of a named variable within this analysis. In order to find the list of valid named variables, use IFAnalysisBaseClass.getValueNames. In order to find out what type of variable will be returned, use IFAnalysisBaseClass.getValueType If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. The returned value will be of a type appropriate to the variable being requested. It could be an object, a real number, a variation, a string, an integer etc, or an array of any of these. 
		Params:
			varName (str): 
			units (IFUnitSet, optional): 
		Returns:
			object: 
		"""
		pass


	def getValueNames(self) -> list[str]:
		r"""
		Allows user to inquire the names of values which are valid to be used in IFAnalysisBaseClass.setValue and IFAnalysisBaseClass.getValue The return value is an array of strings, each of which is a valid value name. 
		Returns:
			array of strs: 
		"""
		pass


	def getValueDescription(self, varName) -> str:
		r"""
		Returns a description or definition of the given named value. A list of valid names may be obtained by calling IFAnalysisBaseClass.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: the returned string
		"""
		pass


	def getValueType(self, varName) -> str:
		r"""
		Return the type (string, real, integer, attribute etc) of value that will be returned by IFAnalysisBaseClass.getValue for the given named variable. In order to find the list of valid named variables, use IFAnalysisBaseClass.getValueNames 
		Params:
			varName (str): 
		Returns:
			str: 
		"""
		pass


	def getValueUnits(self, varName, units=None) -> str:
		r"""
		Return the units ("N/mm�", "m/s", etc) of the value that will be returned by IFAnalysisBaseClass.getValue for the given named variable. In order to find the list of valid named variables, use IFAnalysisBaseClass.getValueNames Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			varName (str): name of the value (e.g. "E")
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			str: the returned string
		"""
		pass


	def createValue(self, name, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Create a new value within this analysis for subsequent use. The initial value will be 0.0 until modified by a call to IFAnalysisBaseClass.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFAnalysisBaseClass.setValue and/or subsequent access with IFAnalysisBaseClass.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			name (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def setValueDescription(self, name, desc, persist=None) -> IFDispatch:
		r"""
		specify a description to be used (in the report wizard) for a value previously added using IFAnalysisBaseClass.createValue. Note that if this function is not called, the value will not appear in the report. It is an error to call this function for any value not previously added using IFAnalysisBaseClass.createValue. By default, values that are added via createValue() are not persistent. That is, when the control is subsequently redefined using a call of the form loadcase.set....Control(), all such data is lost, consistently with all other data. However, the persist flag may be set true to prevent this. This should only be done for data that cannot be logically invalidated by entering conflicting data in Modeller's user interface. 
		Params:
			name (str): name of the value
			desc (str): new description
			persist (object, optional): persistence (default false)
		Returns:
			IFDispatch: 
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this control contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def addDependentAttrType(self, attrType) -> None:
		r"""
		add dependent attribute type to this analysis, any change in this analysis invalidates the attributes type in the dependent analyses of this analysis 
		Params:
			attrType (str): type of attribute
		Returns:
			None: 
		"""
		pass


	def removeDependentAttrType(self, attrType) -> None:
		r"""
		remove dependent attribute type from this analysis 
		Params:
			attrType (str): type of attribute
		Returns:
			None: 
		"""
		pass


	def setSelectedResultsGroup(self, type, groupName=None) -> None:
		r"""
		set the selected results group 
		Params:
			type (str): selected results type, "all", "group", "assignments"
			groupName (object, optional): name of the group
		Returns:
			None: 
		"""
		pass


	def setSelectedElementOutputGroup(self, type, groupName=None) -> None:
		r"""
		set the selected elements output group 
		Params:
			type (str): selected output type, "all", "group"
			groupName (object, optional): name of the group
		Returns:
			None: 
		"""
		pass


	def setSelectedNodeOutputGroup(self, type, groupName=None) -> None:
		r"""
		set the selected ndoes output group 
		Params:
			type (str): selected output type, "all", "group"
			groupName (object, optional): name of the group
		Returns:
			None: 
		"""
		pass


	def getLoadsetByName(self, name) -> IFLoadset:
		r"""
		Get a loadcase in this analysis 
		Params:
			name (str): name of the loadcase to look for
		Returns:
			IFLoadset: 
		"""
		pass


	def resultsFileValidity(self) -> int:
		r"""
		Return an integer that explains the validity of the results file of this analysis 0: Valid 1: Invalid 2: Out of date 
		Returns:
			int: 
		"""
		pass


	def getModificationTime(self, analysisOnly) -> int:
		r"""
		Returns the number of seconds between Jan 1st 1970 and the time at which this analysis was most recently modified - either directly (e.g. assignment) or indirectly (e.g. assignment to a previous loadcase) There are two possible answers - one excludes assignments of attributes that do not affect the solution (this is the same as the flag that is used internally to know whether the analysis needs solving or not). The other includes all attributes, even those that do not affect solution. 
		Params:
			analysisOnly (bool): if true, the value returned excludes attributes which do not affect solution
		Returns:
			int: 
		"""
		pass


	def closeResults(self) -> None:
		r"""
		Close all results files belonging to this analysis 
		Returns:
			None: 
		"""
		pass


	def setModified(self, affectsSolution, affectsCache) -> None:
		r"""
		Marks this analysis as needing to be solved, and/or needing to have all results caches deleted. Note that the examples given by the side of each argument are already covered by modeller's internal logic and mentioned here only to explain the sort of circumstance why you would want to call this function. 
		Params:
			affectsSolution (bool): Usually true. Can be set false for changes that affect results, but not solver (e.g. assign a design attribute)
			affectsCache (bool): Usually false. Can be set true for changes that affect results cache, but not solver (e.g. modify a local coordinate that is used in a transformation)
		Returns:
			None: 
		"""
		pass


	def solve(self, ignoreModified=None) -> int:
		r"""
		Follows the internal knowledge of "this" to tabulate and solve exactly what LUSAS believes needs solving. If multiple solutions are needed (for example to calculate prestress effects) this will be done, but only if LUSAS believes them to be out of date. If this analysis has prerequisites (for example, if this analysis starts with deformations from another analysis), then those prerequisites will be solved first, but only if LUSAS believes them to be out of date. Thus, looping all analyses, in any order, and calling solve() will bring all results up to date. If you set ignoreModified to be true, then LUSAS's internal knowledge is ignored, and the analysis (and any prerequisites) will be solved whether LUSAS thinks it necessary or not Returns 0 for success, or a failure code from LUSAS solver 
		Params:
			ignoreModified (object, optional): default false. Can be set true to ignore the modification state of this and its prerequisites
		Returns:
			int: 
		"""
		pass


	def openResults(self, scanOutputFiles=None, skipOutOfDate=None) -> None:
		r"""
		Open any available results for this analysis. Note - there is no error for any results which are missing, or need to be solved, or need updating from a previous version. Nonetheless, such files will not be loaded. Optionally (default true) skip any results that LUSAS considers to be out of date 
		Params:
			scanOutputFiles (object, optional): default true. Can be set false to skip parsing output files and repeating errors and warnings into the text output window
			skipOutOfDate (object, optional): default true. Can be set false to force LUSAS to load results files it believes to be out of date
		Returns:
			None: 
		"""
		pass


	def deleteSolverFiles(self, datFileToo=None) -> None:
		r"""
		Delete all of the files created by solver for this analysis Typically, this is dat, mys, out, log, his, dtf and rst files 
		Params:
			datFileToo (object, optional): default true. Can be set false to skip deleting the dat file (it is often desirable to keep this one file)
		Returns:
			None: 
		"""
		pass


	def setRestartFromDump(self, restartFile, dumpNo, restartIncType=None, startingIncLength=None, maximumIncLength=None) -> IFAnalysisBaseClass:
		r"""
		Sets up the restart file and dump from which this analysis will start. Calling this function clears any settings previously set using IFAnalysisBaseClass.setRestartFromLoadcase or IFAnalysisBaseClass.setDeformedMeshStart 
		Params:
			restartFile (str): full path of an rst file
			dumpNo (int): Dump number within rst file
			restartIncType (str, optional): increment type "load factor" or "arc length"
			startingIncLength (float, optional): starting increment length
			maximumIncLength (float, optional): maximum increment length
		Returns:
			IFAnalysisBaseClass: Return this object
		"""
		pass


	def setRestartFromLoadcase(self, loadcase, restartIncType=None, startingIncLength=None, maximumIncLength=None) -> IFAnalysisBaseClass:
		r"""
		Sets up the loadcase from which this analysis will start. This analysis will start from the end of the given loadcase. Calling this function clears any settings previously set using IFAnalysisBaseClass.setRestartFromDump or IFAnalysisBaseClass.setDeformedMeshStart 
		Params:
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Model loadcase at which to start
			restartIncType (str, optional): increment type "load factor" or "arc length"
			startingIncLength (float, optional): starting increment length
			maximumIncLength (float, optional): maximum increment length
		Returns:
			IFAnalysisBaseClass: Return this object
		"""
		pass


	def getRestartSettings(self, restartType, loadcase, analysis, timestep) -> None:
		r"""
		Retrieves the restart settings previously set with IFAnalysisBaseClass.setRestartFromLoadcase or IFAnalysisBaseClass.setRestartFromDump 
		Params:
			restartType (int): 0 = no restart, 1 = planned restart (from loadcase), 2 = unplanned restart (from dump)
			loadcase (IFLoadcase): Only set when restartType = 1
			analysis (str): Only set when restartType = 2
			timestep (int): Only set when restartType = 2
		Returns:
			None: 
		"""
		pass


	def removeRestart(self) -> IFAnalysisBaseClass:
		r"""
		Clears any settings previously set using IFAnalysisBaseClass.setRestartFromDump or IFAnalysisBaseClass.setRestartFromLoadcase 
		Returns:
			IFAnalysisBaseClass: Return this object
		"""
		pass


class IFVLOInfluenceAssignEntry(IFDispatch):
	"""
	Interface for influence assignment to be analysed in VLO 
	"""

	def getName(self) -> str:
		r"""
		returns the name of the influence assignment 
		Returns:
			str: 
		"""
		pass


	def getNameWithDescription(self) -> str:
		r"""
		returns the name of the influence assignment 
		Returns:
			str: 
		"""
		pass


	def getUniqueID(self) -> int:
		r"""
		Returns an number that uniquely identifies an influence chosen for a VLO analysis; this is actually the influence assignment rank for the automatic influences or the attribute's unique id for manual influences (v14.1) 
		Returns:
			int: 
		"""
		pass


	def getInfObj(self) -> IFDispatch:
		r"""
		returns the influence assignment in this entry 
		Returns:
			IFDispatch: 
		"""
		pass


	def loadPositive(self) -> bool:
		r"""
		returns TRUE if the positive area should be loaded 
		Returns:
			bool: 
		"""
		pass


	def loadNegative(self) -> bool:
		r"""
		returns TRUE if the negative area should be loaded 
		Returns:
			bool: 
		"""
		pass


	def includeAditionalPatterns(self) -> bool:
		r"""
		relevant for AASHTO code only: returns true if two concentrated loads per lane (LFD) or two trucks per lane (LRFD) will be used in the load pattern generation 
		Returns:
			bool: 
		"""
		pass


	def setDeterminantLength(self, determinantLength) -> None:
		r"""
		set the determinant length used o calculate a (dynamic) factor 
		Params:
			determinantLength (float): 
		Returns:
			None: 
		"""
		pass


	def getDeterminantLength(self) -> float:
		r"""
		get the determinant length used o calculate a (dynamic) factor 
		Returns:
			float: 
		"""
		pass


	def setInfluenceFactor(self, influenceFactor) -> None:
		r"""
		set the influence factor 
		Params:
			influenceFactor (float): 
		Returns:
			None: 
		"""
		pass


	def getInfluenceFactor(self) -> float:
		r"""
		get the influence factor 
		Returns:
			float: 
		"""
		pass


	def isPending(self) -> bool:
		r"""
		returns TRUE if the influence assignment is pending 
		Returns:
			bool: 
		"""
		pass


	def isForCoincidentEffect(self) -> bool:
		r"""
		returns TRUE if the influence assignment is for a coincident effect 
		Returns:
			bool: 
		"""
		pass


	def getCoincidentCmpName(self) -> str:
		r"""
		returns the name of the coincident component 
		Returns:
			str: 
		"""
		pass


	def getInfAnalysis(self) -> IFAnalysisBaseClass:
		r"""
		returns the influence analysis in which the influence assignment is assigned 
		Returns:
			IFAnalysisBaseClass: 
		"""
		pass


	def getInfType(self) -> int:
		r"""
		returns the influence type in terms of a VLO design code (i.e. moment / reaction / shear, etc) 
		Returns:
			int: 
		"""
		pass


	def isDerivedComponent(self) -> bool:
		r"""
		returns true if the result component used in the influence attribute is a derived component 
		Returns:
			bool: 
		"""
		pass


	def getAttrNameWithDescription(self) -> str:
		r"""
		returns the name of the influence attribute with description 
		Returns:
			str: 
		"""
		pass


	def hasCoincidentEffects(self) -> bool:
		r"""
		returns true if this is the primary component and it has coincident effects 
		Returns:
			bool: 
		"""
		pass


	def getCoincidentEffectEntries(self) -> list[IFVLOInfluenceAssignEntry]:
		r"""
		return the entries needed for coincident effects 
		Returns:
			array of IFVLOInfluenceAssignEntry objects: The returned array
		"""
		pass


class IFVLOInfDesignLoadcase(IFDispatch):
	"""
	VLO (Vehicle Loading Optimization) influence design loadcase It is a placeholder for TLO results grouped by Influence attribute � Sign � Design case; its results are shown in a tab in the TLO results table 
	"""

	def addInfAssignResult(self, pInfName, assignmentRank, isPositive) -> IFVLOInfAssignResult:
		r"""
		Add an influence assign result for the given influence entry 
		Params:
			pInfName (str): name of influence assigment or inf attribute (for v14.1 inf attributes)
			assignmentRank (str): not used in here but needed to comply with signature for the late binding in .Net (see function in IFTLOEnvelope)
			isPositive (bool): not used in here but needed to comply with signature for the late binding in .Net (see function in IFTLOEnvelope)
		Returns:
			IFVLOInfAssignResult: returned influence result
		"""
		pass


	def getName(self) -> str:
		r"""
		Return the name of this 
		Returns:
			str: 
		"""
		pass


class IFVLOInfAssignResult(IFDispatch):
	"""
	// VLO (Vehicle Loading Optimization): The effect calculated by TLO for a particular influence assignment, for the traffic loads in the most onerous load pattern of a design case in a design code 
	"""

	def setup(self, mainEffect, coincidentEffects, coincidentEffectCmpNames, loadPatternName, loadAttrCmdFileName) -> None:
		r"""
		Set the data from VLO 
		Params:
			mainEffect (float): the main effect (for the result entity which was optimised in VLO)
			coincidentEffects (array of float): coincident effects
			coincidentEffectCmpNames (array of str): of coincident effect component names
			loadPatternName (str): load pattern name which produced the result
			loadAttrCmdFileName (str): the name of the file containing the vbs commands to create the loading attributes and loadcases
		Returns:
			None: 
		"""
		pass


class IFTLORunBase(IFDispatch):
	"""
	Base interface for TLO Envelope Runs, VLO and RLO Runs 
	"""

	def getName(self) -> str:
		r"""
		Returns the name of this run 
		Returns:
			str: the name
		"""
		pass


	def saveRunOptions(self, longInc, transInc, vehicleDir, useRationalisedPlacement) -> None:
		r"""
		set the longitudinal increment, transverse increment and vehicle direction (used by VLOEngine) 
		Params:
			longInc (float): longitudinal increment
			transInc (float): transverse increment
			vehicleDir (int): vehicle direction (forwards/backwards/both)
			useRationalisedPlacement (bool): use rationalised placement for vehiclular traffic load
		Returns:
			None: 
		"""
		pass


	def getRunOptions(self, longInc, transInc, vehicleDir, pUseRationalisedPlacement) -> None:
		r"""
		get the longitudinal increment, transverse increment and vehicle direction (used by VLOEngine) 
		Params:
			longInc (float): longitudinal increment
			transInc (float): transverse increment
			vehicleDir (int): vehicle direction (forwards/backwards/both)
			pUseRationalisedPlacement (bool): use rationalised placement for vehiclular traffic load
		Returns:
			None: 
		"""
		pass


	def copyVLODataFrom(self, pIAotherRun) -> None:
		r"""
		Copy VLO data (that is in the VLO dialogs) from given VLO run 
		Params:
			pIAotherRun (IFTLORunBase): 
		Returns:
			None: 
		"""
		pass


	def isUsingFEAEngine(self) -> bool:
		r"""
		Returns true if FEA Engine is used for loading optimization 
		Returns:
			bool: 
		"""
		pass


	def isEnvelope(self) -> bool:
		r"""
		Returns true if this is a TLO Envelope run (VLO Envelope or RLO Envelope) 
		Returns:
			bool: 
		"""
		pass


	def isRLORun(self) -> bool:
		r"""
		Returns true if this is a RLO run or RLO Envelope Run 
		Returns:
			bool: 
		"""
		pass


	def getSearchArea(self) -> IFSearchArea:
		r"""
		Get the search area needed when assigning the load attributes created by TLO 
		Returns:
			IFSearchArea: 
		"""
		pass


	def setSearchArea(self, pISearchArea) -> None:
		r"""
		Set the search area needed when assigning the load attributes created by TLO 
		Params:
			pISearchArea (IFSearchArea): 
		Returns:
			None: 
		"""
		pass


class IFIDSettingsObj(IFDispatch):
	"""
	this object encapsulates the settings that define a renumbering scheme, functions are provided to get and set the details of the renumbering scheme contained in the object. 
	"""

	def setReferencePath(self, referencePath, first, second, third) -> None:
		r"""
		Sets the name of the reference path to which the renumbering is relative to, and the order in which axes are to be considered 
		Params:
			referencePath (str): name of the reference path
			first (str): first axis
			second (str): second axis
			third (str): third axis
		Returns:
			None: 
		"""
		pass


	def setGlobalAxes(self, first, second, third) -> None:
		r"""
		Sets the renumbering to be relative to global axes and the order in which axes are to be considered. 
		Params:
			first (str): first axis
			second (str): second axis
			third (str): third axis
		Returns:
			None: 
		"""
		pass


	def setIncrements(self, start, first, second, third) -> None:
		r"""
		Set the start value for the renumbering and the increments to be applied for each direction. 
		Params:
			start (int): start value
			first (int): first axis
			second (int): second axis
			third (int): third axis
		Returns:
			None: 
		"""
		pass


	def setRespectExisting(self, respectExisting) -> None:
		r"""
		set to respect numbering outside selection or to renumber outside the selection if required 
		Params:
			respectExisting (bool): true to respect the numbering outside the selection being renumbered false to allow those numbers to be altered if necessary
		Returns:
			None: 
		"""
		pass


	def setActOnAll(self, actOnAll) -> None:
		r"""
		if true act on all objects, if false act on selection 
		Params:
			actOnAll (bool): true to act on all objects false to act on selection only
		Returns:
			None: 
		"""
		pass


	def setActOnLOFs(self, actOnLOFs) -> None:
		r"""
		if true to include Lower Order Features in selection renumbering 
		Params:
			actOnLOFs (bool): true to include LOFs in a selection renumbering
		Returns:
			None: 
		"""
		pass


	def setAutoRenumber(self, autoRenumber) -> None:
		r"""
		Use this object (renumbering scheme) for automatic renumbering on re-mesh, this takes effect after the renumbering specified in this object has applied. auto renumbering is only applicable if all nodes or elements are selected 
		Params:
			autoRenumber (bool): true to use this object for auto renumbering on re-mesh
		Returns:
			None: 
		"""
		pass


	def setObjectTypes(self, points, lines, surfaces, volumes, nodes, elements) -> None:
		r"""
		sets the types of objects on which to act 
		Params:
			points (bool): true to renumber points
			lines (bool): true to renumber lines
			surfaces (bool): true to renumber surfaces
			volumes (bool): true to renumber volumes
			nodes (bool): true to renumber nodes
			elements (bool): true to renumber elements
		Returns:
			None: 
		"""
		pass


	def getActOnAll(self) -> bool:
		r"""
		if true act on all object, if false act on selection 
		Returns:
			bool: true means act on all objects. False means act on selection only
		"""
		pass


	def getAutoRenumber(self) -> bool:
		r"""
		is auto renumbering requested 
		Returns:
			bool: true if auto renumbering using this object is requested. Auto renumbering is only applicable if all nodes or elements are selected
		"""
		pass


	def getRespectExisting(self) -> bool:
		r"""
		get value of the option to respect numbering outside selection 
		Returns:
			bool: true to respect the numbering outside the selection being renumbered false to allow those numbers to be altered if necessary
		"""
		pass


	def getIncrements(self, start, first, second, third) -> None:
		r"""
		gets the start value of the renumbering and increments to apply in each axes direction 
		Params:
			start (int): start value
			first (int): first axis
			second (int): second axis
			third (int): third axis
		Returns:
			None: 
		"""
		pass


	def getAxes(self, first, second, third, firstSign, secondSign, thirdSign) -> None:
		r"""
		get the order and direction in which to consider axes 
		Params:
			first (int): first axis
			second (int): second axis
			third (int): third axis
			firstSign (bool): first direction true is positive
			secondSign (bool): second direction true is positive
			thirdSign (bool): third direction true is positive
		Returns:
			None: 
		"""
		pass


	def getObjectTypes(self, points, lines, surfaces, volumes, nodes, elements) -> None:
		r"""
		get the types of objects on which to act 
		Params:
			points (bool): renumber points
			lines (bool): renumber lines
			surfaces (bool): renumber surfaces
			volumes (bool): renumber volumes
			nodes (bool): renumber nodes
			elements (bool): renumber elements
		Returns:
			None: 
		"""
		pass


	def isReferencePath(self, referencePathName) -> bool:
		r"""
		return the reference path chosen. If the renumbering is global returns false 
		Params:
			referencePathName (str): name of reference path
		Returns:
			bool: true if reference path renumbering has been selected, false if global renumbering
		"""
		pass


class IFReinforcementSectionBar(IFDispatch):
	"""
	Representation of one reinforcement bar, which exists within a IFReinforcementSection attribute 
	"""

	def getFace(self) -> int:
		r"""
		Returns the face to which this bar belongs. Bars from the "additional bars" tab will return -1. 
		Returns:
			int: 
		"""
		pass


	def getLayer(self) -> int:
		r"""
		Returns the layer to which this bar belongs. Bars from the "additional bars" tab will return -1. 
		Returns:
			int: 
		"""
		pass


	def getCoords(self) -> object:
		r"""
		Returns the coordinates of this bar (0,y,z) 
		Returns:
			object: Array of 3 real numbers representing a coordinate axis in 3D space.
		"""
		pass


	def getDiameter(self) -> float:
		r"""
		Returns the diameter of this bar 
		Returns:
			float: 
		"""
		pass


	def getDiameterEquivalent(self) -> float:
		r"""
		Returns the equivalent diameter of this bar 
		Returns:
			float: 
		"""
		pass


	def getSpacingCrackWidth(self) -> float:
		r"""
		Returns the spacing for the calculation of the crack width 
		Returns:
			float: 
		"""
		pass


	def hasActualCover(self) -> bool:
		r"""
		The actual cover is the distance between the face and the outside fibre of the link. Bars from the "additional bars" tab will return false 
		Returns:
			bool: 
		"""
		pass


	def getActualCover(self) -> float:
		r"""
		Returns the distance between the face and the outside fibre of the link. 
		Returns:
			float: 
		"""
		pass


	def getNominalCover(self) -> float:
		r"""
		Returns the nominal cover, which is used to calculate crack widths 
		Returns:
			float: 
		"""
		pass


	def getBundleSize(self) -> int:
		r"""
		Returns the number of other bars in the bundle of which this bar is a member, e.g this function returns 2 if this bar is in a bundle of 3 bars 
		Returns:
			int: 
		"""
		pass


	def getBundleIndex(self, index) -> int:
		r"""
		return the index into the array of rebars of the other bar in the bundle of which this bar is a member given the index 
		Params:
			index (int): segment's index starting from 0
		Returns:
			int: 
		"""
		pass


	def getBundleCentre(self) -> object:
		r"""
		return the equivalent centre of the bundle of which this bar is a member 
		Returns:
			object: Array of 3 real numbers representing a coordinate axis in 3D space.
		"""
		pass


	def isClosestToFace(self) -> bool:
		r"""
		return true if this bar is closest to the section face 
		Returns:
			bool: 
		"""
		pass


class IFTransverseReinforcement(IFDispatch):
	"""
	Representation of transverse reinforcement, which exists within a IFReinforcementLine at a given location 
	"""

	def hasReinforcement(self, type) -> bool:
		r"""
		Indicates if transverse reinforcement is defined for the given purpose 
		Params:
			type (int): 1 for transverse in z, 2 for transverse in y, 3 for torsion
		Returns:
			bool: 
		"""
		pass


	def getNumberOfBars(self, type) -> int:
		r"""
		Returns the number of transverse bars for the given purpose 
		Params:
			type (int): 1 for transverse in z, 2 for transverse in y, 3 for torsion
		Returns:
			int: 
		"""
		pass


	def getDiameterOfBars(self, type) -> float:
		r"""
		Returns the diameter of the transverse bars for the given purpose 
		Params:
			type (int): 1 for transverse in z, 2 for transverse in y, 3 for torsion
		Returns:
			float: 
		"""
		pass


	def getSpacingOfBars(self, type) -> float:
		r"""
		Returns the spacing of the transverse bars for the given purpose 
		Params:
			type (int): 1 for transverse in z, 2 for transverse in y, 3 for torsion
		Returns:
			float: 
		"""
		pass


	def getAngleOfBars(self, type) -> float:
		r"""
		Returns the angle of the transverse bars. Not applicable for torsion 
		Params:
			type (int): 1 for transverse in z, 2 for transverse in y
		Returns:
			float: 
		"""
		pass


	def getCoverToTorsionBars(self) -> float:
		r"""
		Returns the cover to the centroid of the torsion bars. 
		Returns:
			float: 
		"""
		pass


class IFPrestressSolver(IFDispatch):
	"""
	The prestress solver 
	"""

	def solve(self, passNo, nPasses) -> IFPrestressSolver:
		r"""
		Calculate prestress losses as equivalent nodal loads on the structure. These equivalent nodal loads are not shown in the user interface (see IFAnalysis.createCopyForPrestress()). Prestress based on input estimated stresses needs to be solved only once. However, prestress based on time inputs and calculated stresses needs to be solved (at least) twice. The first pass treats all time dependent losses as zero and does not consider elastic shortening at all. Subsequent passes use the stresses computed in the previous pass to calculate the time dependent effects and elastic shortening. In practice, LUSAS recommend 2 passes. The difference in losses computed by subsequent passes is usually negligible 
		Params:
			passNo (int): 
			nPasses (int): 
		Returns:
			IFPrestressSolver: 
		"""
		pass


	def cleanUp(self) -> IFPrestressSolver:
		r"""
		Remove the effects of prestress from a model. In practice, this function is normally part of the normal operation of IFPrestressSolver.solve, but it is also necessary to call this function between removing all prestress from a model, and the next call to IFModeller:solve. Failure to do so will leave the effect of the prestress loading "lying around". 
		Returns:
			IFPrestressSolver: 
		"""
		pass


	def setAnalysis(self, analysis) -> IFPrestressSolver:
		r"""
		Sets the one and only analysis that the next call to IFPrestressSolver.solve will process. In normal use, this function is not called, and all analyses are processed. Note that calling this function will NOT mark prestress loading as "up to date" because that can only be done for the whole model. 
		Params:
			analysis (name, id, IFAnalysisBaseClass): ,  the analysis
		Returns:
			IFPrestressSolver: 
		"""
		pass


class IFDatabaseOperations(IFDatabaseMember):
	"""
	Common base class for all geometry objects (points, lines, surfaces and volumes), as well as groups, sets and selections and the main database itself. This class defines the operations that can be performed on and between such objects. In general, each function works on one or two IFDatabaseOperations object(s), and optionally also takes an IFGeometryData object in which various options and settings can be specified. All functions return a newly created IFObjectSet object which contains the objects created or modified. If no variable is created using this returned set, it (the set, not the new objects) is immediately deleted - this indicates that the script programmer is not interested in which objects have been created/modified 
	"""

	def createPoint(self, first, Y=None, Z=None) -> IFObjectSet:
		r"""
		Create a point, either from the given geometry data (which will contain the position of the point, along with any other creation options) or from the 3d position given. In the latter case, all default options are assumed 
		Params:
			first (IFGeometryData or float): 
			Y (float, optional): 
			Z (float, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def createLine(self, data=None) -> IFObjectSet:
		r"""
		Create a line passing through either the points in this object, or the coordinates in the passed in data 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def createCombinedLine(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def createSurface(self, data=None) -> IFObjectSet:
		r"""
		Create a surface passing through either the lines in this object, or the coordinates in the passed in data 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def createVolume(self, data=None) -> IFObjectSet:
		r"""
		Create a volume passing through either the surfaces in this object, or the coordinates in the passed in data 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def deleteContents(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def offset(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def extrude(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def copy(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def move(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def sweep(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def booleanUnion(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def booleanIntersection(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def trim(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def removeDegeneracies(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitLine(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitSurface(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitVolume(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def cycle(self, data=None) -> IFObjectSet:
		r"""
		Cycle definition of object(s) 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def facet(self, data) -> IFObjectSet:
		r"""
		Facet object(s) 
		Params:
			data (IFGeometryData): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitLines(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def booleanSubtraction(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def booleanSplit(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def booleanSlice(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def project(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def manifold(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def sweepAlong(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def merge(self, data) -> IFObjectSet:
		r"""
		Merge the object(s) 
		Params:
			data (IFGeometryData): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def unmerge(self, data) -> IFObjectSet:
		r"""
		Unmerge the object(s) 
		Params:
			data (IFGeometryData): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def makeMergeable(self, data=None) -> IFObjectSet:
		r"""
		Make the object(s) mergable 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def makeUnmergeable(self, data=None) -> IFObjectSet:
		r"""
		Make the object(s) unmergable 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def convertMeshToGeometry(self, data=None) -> IFObjectSet:
		r"""
		Convert mesh object(s) to the equivalent geometry object(s) 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def reverse(self, data=None) -> IFObjectSet:
		r"""
		Reverse definition of object(s) 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def cycleRelative(self, data=None) -> IFObjectSet:
		r"""
		Should only be called on an IFObjectSet object Cycle definition of all objects so as to align their axes with the object that was added first (e.g. if the set is a IFSelection, the object which was selected first)  
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def orientateLinesToCombinedLine(self, data=None) -> IFObjectSet:
		r"""
		orientate the lines defining a combined line to follow the combined line direction 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def join(self, obj, data=None) -> IFObjectSet:
		r"""
		join lower order geometry objects with straight lines to create higher order geometry 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitLinesAtPoints(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitSurfacesAtPoints(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitSurfacesAtPointPairs(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splitSurfacesAtLines(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def manifoldPoints(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def manifoldLines(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def manifoldSurfaces(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def intersectLines(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def intersectSurfaces(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def intersectVolumes(self, obj, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def angleBetweenLines(self, obj) -> IFObjectSet:
		r"""
		output the angle between the selected lines 
		Params:
			obj (IFDatabaseOperations): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def distanceBetweenPoints(self, obj) -> IFObjectSet:
		r"""
		output the distance between the selected points 
		Params:
			obj (IFDatabaseOperations): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def distanceFromPointToLine(self, obj) -> IFObjectSet:
		r"""
		output the distance between the selected points and lines 
		Params:
			obj (IFDatabaseOperations): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def separationBetweenLines(self, obj) -> IFObjectSet:
		r"""
		output the distance between the selected lines 
		Params:
			obj (IFDatabaseOperations): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def lengthOfLines(self) -> IFObjectSet:
		r"""
		output the length of the selected lines 
		Returns:
			IFObjectSet: 
		"""
		pass


	def tangentsToPointAndLine(self, obj, data=None) -> IFObjectSet:
		r"""
		create a straight line from a point tangent to a line 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def arcsTangentToLines(self, obj, data=None) -> IFObjectSet:
		r"""
		create arc line(s) tangent to lines 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def straightsTangentToLines(self, obj, data=None) -> IFObjectSet:
		r"""
		create straight line(s) tangent to lines 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def splineTangentToLines(self, obj, data=None) -> IFObjectSet:
		r"""
		create a spline tangent to lines 
		Params:
			obj (IFDatabaseOperations): 
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def modify(self, data=None) -> IFObjectSet:
		r"""
		 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def closestNodes(self) -> IFObjectSet:
		r"""
		output the distance between the closest node in the selection 
		Returns:
			IFObjectSet: 
		"""
		pass


	def getCentreofArea(self, pCentreOfAreaCoords, localCrds=None) -> int:
		r"""
		Calculate and return the coordinates of the centre of area of this set of surfaces 
		Params:
			pCentreOfAreaCoords (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			localCrds (IFLocalCoord, optional): If not given, The answer is returned in global coords
		Returns:
			int: error code 0 = success, != 0 error
		"""
		pass


	def getSectionLineLoops(self, nLinesInLoops, lineLoops, independentLines) -> int:
		r"""
		return the line loops from the geometric section 
		Params:
			nLinesInLoops (int): array of the number of lines in each loop
			lineLoops (IFLine): array of lines defining loops
			independentLines (IFLine): array of lines not defining loops or surfaces
		Returns:
			int: error code 0 = success, != 0 error
		"""
		pass


class IFObjectSet(IFDatabaseOperations):
	"""
	A generic set, which remembers a list of IFDatabaseMember objects. The list can be added to and removed from in a variety of ways at any time. A set can be regarded as a temporary group that does not have a name and does not appear in the group treeview. Within Modeller itself, all selections, visible sets, results sets, groups and even the database itself are implemented in this way. Therefore the functionality here is equally applicable to all these objects  
In its most simple usage, the script programmer can simply add, say, a surface and two lines to a set. The set can then be used, for example, to assign attributes, or as a convenient way of grouping the three items together for any other purpose.  
The real power of the sets though is their ability to interpret many forms of input, and derive a list of objects to be added or removed based on that input. For example, adding a concentrated load attribute will actually add all the objects to which that concentrated load attribute is assigned. Adding another set or group adds all the members of that set or group. So to select all the members of a group, the line 'selection.add(group)' is used. Similarly adding the element type 'HX20' will actually add all elements of type HX20.  
Additionally the input may be 'filtered' by object type, name, and ID. So, for example, 'selection.add("HX20", "volume", "1T10") will first identify all the elements of type HX20. Then it will find their parent volumes. Finally, only volumes with IDs between 1 and 10 will actually be selected.  
For complete control, all the functionality described above works for the 'add', 'remove', 'keep', 'delete', 'exists', 'count' and 'getObjects' functions in exactly the same way.  
As well as interacting with Modeller's own intrinsic set objects, the script programmer is free to create temporary set objects for any reason at any time. Use IFModeller.newObjectSet to create such a set. Note that if you create a temporary set, it is your responsibility to maintain the integrity of any objects stored in it. I.e. if you add an object to a temporary set and then delete the object, the set will still contain a reference to that deleted item, and this may cause some operations to fail. It is therefore your responsibility to remember to remove objects any temporary sets that you have created before such objects are deleted. Modeller does this job for you for the intrinsic sets that it knows about (visible, selection, groups, etc). 
	"""

	def add(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFObjectSet:
		r"""
		Adds the specified objects to this set. Note that IFObjectSet.add obeys the value of the downward associativity such that it will also add the LOFs of any items added if the downward associativity flag is set true. (Check full documentation for argument details). 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def remove(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFObjectSet:
		r"""
		Deletes the specified object(s) from this set. The specified objects will still be present in the model, and may be added to this set again at a later stage. Note that IFObjectSet.remove obeys the value of the downward associativity such that it will also remove the LOFs of any items removed if the downward associativity flag is set true. (Check full documentation for argument details). 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def keep(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFObjectSet:
		r"""
		Remove all objects from this set that do not meet the given criteria Note that IFObjectSet.keep obeys the value of the downward associativity such that it will also keep the LOFs of any items kept if the downward associativity flag is set true. (Check full documentation for argument details). 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def Delete(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFObjectSet:
		r"""
		Deletes the specified object(s) permanently from this set and from the database. The specified objects will no longer be present in the model, or this set. Modeller will automatically remove such objects from all its intrinsic sets such as groups and the selection. However as described in IFObjectSet, the deleted objects may still be present in other temporary sets that you have created - it is your responsibility to check this, preferably before executing the IFObjectSet.Delete instruction. Note that IFObjectSet.Delete obeys the value of the downward associativity such that it will also delete the unshared LOFs of any items deleted if the downward associativity flag is set true. (Check full documentation for argument details). 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def exists(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> bool:
		r"""
		Returns whether or not the given item is present in the set Note that IFObjectSet.exists ignores the value of the downward associativity such that it will return false if the requested item is not present, even if one of its LOFs is present and the downward associativity flag is set true. This function is exactly equivalent to calling IFObjectSet.getObjects() and testing to see if the length of the returned array is greater than 0. If you plan to call IFObjectSet.getObject() conditionally upon the result of a call to IFObjectSet.exists(), note that it is much more efficient to call IFObjectSet.getObjects() and check the length of the returned array instead. (Check full documentation for argument details). 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			bool: returned true if object(s) were found that matched the input criteria
		"""
		pass


	def count(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> int:
		r"""
		Returns the number of objects in the set of a particular type Note that IFObjectSet.count ignores the value of the downward associativity such that it will return 1 if the exactly one single item is requested and present, even if some of its LOFs are also present and the downward associativity flag is set true. This function is exactly equivalent to calling IFObjectSet.getObjects() and returning the length of the returned array. If you plan to call IFObjectSet.getObjects() as well as IFObjectSet.count(), note that it is much more efficient to simply examine the length of the array returned by IFObjectSet.getObjects(). (Check full documentation for argument details). 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			int: the returned number of items For further syntax examples, see IFObjectSet.add
		"""
		pass


	def getObjects(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> list[IFDatabaseMember]:
		r"""
		Fetch the specified object(s) as an array. The output array is sorted into increasing object type and increasing object ID. E.g. (regardless of the input), the output would be something like { P1, P2, P32, L1, L3, L58, S4, S34 } The array can then be looped in the normal way. (Check full documentation for argument details). 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			array of IFDatabaseMember objects: the returned array
		"""
		pass


	def getObject(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFDatabaseMember:
		r"""
		Fetch the specified object by name or ID or attribute assignment. It is an error to call this function with parameters that do not match exactly one object. If in doubt about the number of objects that might be returned, use IFObjectSet.getObjects(). If you plan to call IFObjectSet.getObject() conditionally upon the result of a call to IFObjectSet.exists(), note that it is much more efficient to call IFObjectSet.getObjects() and check the length of the returned array instead. 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFDatabaseMember: the returned object
		"""
		pass


	def getAsString(self, type) -> str:
		r"""
		As IFObjectSet.getObjects but returns objects in the form of a string e.g. "1T50I2;100" which would mean all objects with odd IDs between 1 and 50 and also 100 this string is then suitable for passing into IFObjectSet.add or IFObjectSet.remove at a later stage A type must be specified - it can either be a type code (see IFGeometry.getTypeCode) or the name of a type "point", "line" etc 
		Params:
			type (int or str): type (code or string)
		Returns:
			str: the returned string
		"""
		pass


	def addPlanarNeighbours(self, angularTolerance, externalOnly) -> IFObjectSet:
		r"""
		Adds to this set all the neighbouring objects that are in the same plane, within a given tolerance. The effect is recursive, so selecting any one surface on a sphere, and then calling this routine, will select all the surfaces on that sphere, assuming the tolerance is loose enough. 
		Params:
			angularTolerance (float): Acceptable angle between neighbours
			externalOnly (bool): If true, surfaces between two volumes will be ignored
		Returns:
			IFObjectSet: 
		"""
		pass


	def addColinearNeighbours(self, angularTolerance) -> IFObjectSet:
		r"""
		Adds to this set all the neighbouring objects that are colinear within a given tolerance. The effect is recursive, so selecting any one line on a circle, and then calling this routine, will select all the line on that circle, assuming the tolerance is loose enough. 
		Params:
			angularTolerance (float): Acceptable angle between neighbours
		Returns:
			IFObjectSet: 
		"""
		pass


	def addMatchedObjects(self, distTol) -> IFObjectSet:
		r"""
		Adds to this set all the objects within the given tolerance of each other. Operates like a pre-merge functions, shows what object would merge with the given tolerance 
		Params:
			distTol (float): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def addLOF(self, arg1=None, arg2=None) -> IFObjectSet:
		r"""
		Adds to this set all elements and lower order features of objects already in this set. Optionally the operation may be filtered to only add objects of a specific type, and with specific name(s), or that have a particular attribute assignment. (Check full documentation for argument details). 
		Params:
			arg1 (object, optional): Can be an object type 'Point', 'Line', 'Element', etc or an Attribute type such as 'Loading', 'Support', 'Material', etc. Subsequent arguments can provide specifc names or ids of the first argument type.
			arg2 (object, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def addHOF(self, arg1=None, arg2=None) -> IFObjectSet:
		r"""
		Adds to this set all higher order features of objects already in this set. Also adds parent features of any elements in the set. Optionally the operation may be filtered to only add objects of a specific type, and with specific name(s), or that have a particular attribute assignment. (Check full documentation for argument details). 
		Params:
			arg1 (object, optional): Can be an object type 'Point', 'Line', 'Element', etc or an Attribute type such as 'Loading', 'Support', 'Material', etc. Subsequent arguments can provide specifc names or ids of the first argument type.
			arg2 (object, optional): 
		Returns:
			IFObjectSet: 
		"""
		pass


	def removeLOF(self) -> IFObjectSet:
		r"""
		Removes from this set all lower order features of objects already in this set 
		Returns:
			IFObjectSet: 
		"""
		pass


	def removeHOF(self) -> IFObjectSet:
		r"""
		Removes from this set all higher order features of objects already in this set 
		Returns:
			IFObjectSet: 
		"""
		pass


	def replaceWithLOF(self) -> IFObjectSet:
		r"""
		Equivalent to calling IFObjectSet.addLOF and then removing the original contents of the set 
		Returns:
			IFObjectSet: 
		"""
		pass


	def replaceWithHOF(self) -> IFObjectSet:
		r"""
		Equivalent to calling IFObjectSet.addHOF and then removing the original contents of the set 
		Returns:
			IFObjectSet: 
		"""
		pass


	def sameContents(self, pSet) -> bool:
		r"""
		returns true if this set contains exactly the same objects as the given set, and vice versa 
		Params:
			pSet (IFObjectSet): 
		Returns:
			bool: 
		"""
		pass


	def contains(self, pSet) -> bool:
		r"""
		returns true if this set contains at least all of the objects that are in the given set. 
		Params:
			pSet (IFObjectSet): 
		Returns:
			bool: 
		"""
		pass


	def setIDs(self, pSettings) -> None:
		r"""
		perform renumbering as specified in the passed IFIDSettingsObj object 
		Params:
			pSettings (IFIDSettingsObj): 
		Returns:
			None: 
		"""
		pass


	def removeAssignments(self, attributeType) -> None:
		r"""
		Removes any assignments of the given type from the objects 
		Params:
			attributeType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def getBounds(self, minX, minY, minZ, maxX, maxY, maxZ) -> None:
		r"""
		Return the coordinates of a volume that completely encloses all members of this object set. 
		Params:
			minX (float): smallest X coord found in any member of this set
			minY (float): smallest Y coord found in any member of this set
			minZ (float): smallest Z coord found in any member of this set
			maxX (float): largest X coord found in any member of this set
			maxY (float): largest Y coord found in any member of this set
			maxZ (float): largest Z coord found in any member of this set
		Returns:
			None: 
		"""
		pass


	def getModificationTime(self) -> int:
		r"""
		Returns the number of seconds between Jan 1st 1970 and the time at which this object set was most recently modified by the additional or removal of members 
		Returns:
			int: 
		"""
		pass


class IFSelection(IFObjectSet):
	"""
	 
	"""

	pass


class IFGeometry(IFDatabaseOperations):
	"""
	 
	"""

	def isSelected(self) -> bool:
		r"""
		Returns True if object is selected 
		Returns:
			bool: 
		"""
		pass


	def isVisible(self) -> bool:
		r"""
		Returns True if object is visible 
		Returns:
			bool: 
		"""
		pass


	def getTypeCode(self) -> int:
		r"""
		Returns the type code of this object, taken from the following table: 1: IFPoint 2: IFLine 3: IFCombinedLine 4: IFSurface 5: IFVolume or IFHollowVolume Other types of IFDatabaseOperations can return the following additional type code values: 6: IFNode 7: IFEdge 8: IFFace 9: IFElement 10: IFBackgroundGrid 11: IFGroup 12: IFTextAnnotation 13: IFLineAnnotation 14: IFPolygonAnnotation 15: IFArrowAnnotation 16: IFBitmapAnnotation 17: IFSymbolAnnotation 18: IFAnnotationBlock 
		Returns:
			int: type code
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns objects ID IDs are program-generated and quite seperate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def isMemberOfGroup(self, group) -> bool:
		r"""
		Returns TRUE if this object is a member of the given group 
		Params:
			group (IFGroup): The name or ID of a group, or a pointer to a IFGroup object.
		Returns:
			bool: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns object name 
		Returns:
			str: object name
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Sets object name 
		Params:
			newName (str): 
		Returns:
			None: 
		"""
		pass


	def getAssignments(self, attributeType=None, loadset=None, andAssignedObjects=None) -> list[IFAssignment]:
		r"""
		Creates and returns an array of IFAssignment objects, each of which represents one attribute assignment made to this object. The array can be restricted by using the optional argument to specify a given attribute type, e.g. loading. If not given, all assignments are returned Note that the IFAssignment objects returned are copies of the ones in actual use - modifying them will have no effect. If you wish to modify assignment details it is necessary to re-assign the attribute to the object 
		Params:
			attributeType (object, optional): "Loading", "Support", "Material", etc
			loadset (name, id, IFLoadset, optional): , optionally only return assignments to this loadcase
			andAssignedObjects (bool, optional): default false, if true add the assigned objects to the IFAssignment objects returned
		Returns:
			array of IFAssignment objects: The returned array
		"""
		pass


	def getHOFs(self) -> list[IFDatabaseMember]:
		r"""
		Creates and returns an array of higher order features. E.g. if this object is a line, the array may contain combined lines and/or surfaces. 
		Returns:
			array of IFDatabaseMember objects: The returned array
		"""
		pass


	def getLOFs(self) -> list[IFDatabaseMember]:
		r"""
		Creates and returns an array of lower order features. E.g. if this object is a surface, the array may contain combined lines and/or lines. 
		Returns:
			array of IFDatabaseMember objects: The returned array
		"""
		pass


	def getInternalPoints(self) -> list[IFDatabaseMember]:
		r"""
		Creates and returns an array of embedded point in a surface 
		Returns:
			array of IFDatabaseMember objects: The returned array
		"""
		pass


	def haveInternalPoints(self) -> bool:
		r"""
		return ture if this surface has any embedded points 
		Returns:
			bool: 
		"""
		pass


	def countBoundaries(self) -> int:
		r"""
		return the number of boundaries in this object 
		Returns:
			int: 
		"""
		pass


	def getBoundaryLOFs(self, boundaryIndex) -> list[IFDatabaseMember]:
		r"""
		Creates and returns an array of lower order features for the given boundary index. boundaryIndex 0 = outer boundary, 1 = first hole, 2 = second hole ... etc 
		Params:
			boundaryIndex (int): 
		Returns:
			array of IFDatabaseMember objects: The returned array
		"""
		pass


	def setPen(self, penID) -> None:
		r"""
		Changes the pen which is currently used to draw this object. The pen is referred to by a numbered index into the pen library (1..20) 
		Params:
			penID (int): 
		Returns:
			None: 
		"""
		pass


	def getPen(self) -> int:
		r"""
		Returns the pen which is currently used to draw this object. The pen is referred to by a numbered index into the pen library (1..20) 
		Returns:
			int: 
		"""
		pass


	def getElements(self) -> list[IFDatabaseMember]:
		r"""
		Creates and returns an array of elements meshed on to this object. 
		Returns:
			array of IFDatabaseMember objects: The returned array
		"""
		pass


	def getNodes(self) -> list[IFDatabaseMember]:
		r"""
		Creates and returns an array of nodes meshed on to this object. 
		Returns:
			array of IFDatabaseMember objects: The returned array
		"""
		pass


	def createValue(self, varNname, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Creates a new value within this object for subsequent use. The initial value will be 0.0 until modified by a call to IFGeometry.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFGeometry.setValue and/or subsequent access with IFGeometry.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			varNname (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this object contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def setValue(self, varName, value, units=None) -> IFDispatch:
		r"""
		Sets the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): name of the value (e.g. "E")
			value (object): The type given will depend on the value specified
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValue(self, varName, units=None) -> object:
		r"""
		Returns the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): 
			units (IFUnitSet, optional): 
		Returns:
			object: The type returned will depend on the value requested
		"""
		pass


	def getValueUnits(self, varName, units=None) -> str:
		r"""
		Returns the units ("N/mm�", "m/s", etc) of the value that will be returned by IFGeometry.getValue for the given named variable. Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			varName (str): name of the value (e.g. "E")
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			str: the returned string
		"""
		pass


	def getValueNames(self) -> list[str]:
		r"""
		Allows user to inquire the names of values which are valid to be used in IFGeometry.getValue The return value is an array of strings, each of which is a valid value name. 
		Returns:
			array of strs: Returned array of names
		"""
		pass


	def getValueDescription(self, varName) -> str:
		r"""
		Returns a description or definition of the given named value. A list of valid names may be obtained by calling IFGeometry.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: the returned string
		"""
		pass


	def getValueType(self, varName) -> str:
		r"""
		Returns the type (string, real, integer, attribute etc) of value that will be returned by IFGeometry.getValue for the given named variable. In order to find the list of valid named variables, use IFAttribute.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: 
		"""
		pass


	def setValueDescription(self, name, desc, persist=None) -> IFDispatch:
		r"""
		specify a description to be used (in the report wizard) for a value previously added using IFGeometry.createValue. Note that if this function is not called, the value will not appear in the report. It is an error to call this function for any value not previously added using IFGeometry.createValue. By default, values that are added via createValue() are not persistent. That is, when the object is subsequently redefined using a call of the form db.create....(), all such data is lost, consistently with all other data. However, the persist flag may be set true to prevent this. This should only be done for data that cannot be logically invalidated by entering conflicting data in Modeller's user interface. 
		Params:
			name (str): name of the value
			desc (str): new description
			persist (bool, optional): persistence (default false)
		Returns:
			IFDispatch: 
		"""
		pass


	def getResults(self, type, entity, component, units=None, varRes1=None, varRes2=None, context=None) -> float:
		r"""
		Return the value of the specified result type and component at feature. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults
 
		Params:
			type (str): , "featureMax", "featureMin", "FeatureAbs", or "featureExt"
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			varRes1 (int, optional): The node id for nodal results or the element id (for Gauss, internal and elementNodal results) from which the returned value has been calculated
			varRes2 (int, optional): 0 for nodal results or the index (for Gauss, internal and elementNodal results) at which the returned value has been calculated
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: 
		"""
		pass


	def getResultsAt(self, attr, index, entity, component, units=None, context=None) -> list[float]:
		r"""
		Return the value(s) of the specified result type and component at the given inspection location. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system. Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults.
 Although usually the array will contain only one value, multiple values could be returned if the inspection locaton occurs at an averaging discontinuity (e.g. material boundary) 
		Params:
			attr (IFInspectionPoint): The name or ID of a inspectionlocation, or a pointer to a IFInspectionPoint object.
			index (int): index of location number within attr (corresponds to the row number in the definition dialog) (ignored for inspection locations assigned to points)
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			array of float: 
		"""
		pass


	def isMergeable(self) -> bool:
		r"""
		Returns True if object is mergeable 
		Returns:
			bool: 
		"""
		pass


class IFMeshFamily(IFDatabaseMember):
	"""
	 
	"""

	def isSelected(self) -> bool:
		r"""
		Returns True if object is selected 
		Returns:
			bool: 
		"""
		pass


	def isVisible(self) -> bool:
		r"""
		Returns True if object is visible 
		Returns:
			bool: 
		"""
		pass


	def getTypeCode(self) -> int:
		r"""
		Returns the type code of this object, taken from the following table: 6: Node 7: Element Edge 8: Element Face 9: Element 
		Returns:
			int: 
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns objects ID. IDs are program-generated and quite separate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def isMemberOfGroup(self, group) -> bool:
		r"""
		return TRUE if this object is a member of the given group 
		Params:
			group (IFGroup): The name or ID of a group, or a pointer to a IFGroup object.
		Returns:
			bool: 
		"""
		pass


	def getName(self) -> str:
		r"""
		 
		Returns:
			str: 
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		 
		Params:
			newName (str): 
		Returns:
			None: 
		"""
		pass


	def hasBuiltAttribute(self, attrType) -> bool:
		r"""
		return TRUE if this object has assembled attributes of the given type for tabulation 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			bool: 
		"""
		pass


class IFPoint(IFGeometry):
	"""
	Methods available on Point object 
	"""

	def getX(self, pDoTrans=None) -> float:
		r"""
		Get point X coordinate 
		Params:
			pDoTrans (bool, optional): TRUE (the default) to return the value in the currently active local coordinate system. FALSE to return in global coords
		Returns:
			float: X coordinate
		"""
		pass


	def getY(self, pDoTrans=None) -> float:
		r"""
		Get point Y coordinate 
		Params:
			pDoTrans (bool, optional): TRUE (the default) to return the value in the currently active local coordinate system. FALSE to return in global coords
		Returns:
			float: Y coordinate
		"""
		pass


	def getZ(self, pDoTrans=None) -> float:
		r"""
		Get point Z coordinate 
		Params:
			pDoTrans (bool, optional): TRUE (the default) to return the value in the currently active local coordinate system. FALSE to return in global coords
		Returns:
			float: Z coordinate
		"""
		pass


	def getXYZ(self, X, Y=None, Z=None, pDoTrans=None) -> None:
		r"""
		Return X,Y and Z coordinates of this point. If the first argument is given as an array of 3 doubles, the other two arguments should be omitted, and that array will be changed to contain X, Y, and Z. Otherwise the first argument will be returned as X, the second as Y, and the third as Z 
		Params:
			X (float): X coordinate
			Y (float, optional): Y coordinate
			Z (float, optional): Z coordinate
			pDoTrans (bool, optional): TRUE (the default) to return the value in the currently active local coordinate system. FALSE to return in global coords
		Returns:
			None: 
		"""
		pass


	def getTransformedPosition(self, localCoord) -> list[float]:
		r"""
		 
		Params:
			localCoord (IFLocalCoord): 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getMass(self, loadset) -> float:
		r"""
		Returns the mass of a point for a given loadcase. Only points that have both point mass elements and mass material assigned actually have mass. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the mass will be returned
		Returns:
			mass: The returned mass of a point for a given loadcase
		"""
		pass


	def distanceFromPosition(self, position) -> float:
		r"""
		 
		Params:
			position (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			float: 
		"""
		pass


	def getNearestObject(self) -> IFGeometry:
		r"""
		Find the IFGeometry object which has the closest perpendicular projection to this point 
		Returns:
			IFGeometry: 
		"""
		pass


	def getNearestObjectIn(self, set) -> IFGeometry:
		r"""
		Find the IFGeometry object which has the closest perpendicular projection to this point, limiting the search to only those objects that are in the given set 
		Params:
			set (IFDatabaseOperations): 
		Returns:
			IFGeometry: 
		"""
		pass


	def distanceFrom(self, obj, includeLofs=None, returnMinimum=None) -> float:
		r"""
		return the minimum or maximum distance from this point to the given object 
		Params:
			obj (IFGeometry): geometry object
			includeLofs (bool, optional): true to include the nearest defining object of "obj"
			returnMinimum (bool, optional): true to return the minimum distance,, false for the maximum distance
		Returns:
			float: 
		"""
		pass


	def nearestPositionOn(self, obj, includeLofs=None, returnMinimum=None) -> list[float]:
		r"""
		return the coordinates of the closest or furthest point on the given objet to this point 
		Params:
			obj (IFGeometry): geometry object
			includeLofs (bool, optional): true to include the nearest defining object of "obj"
			returnMinimum (bool, optional): true to return the minimum distance,, false for the maximum distance
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


class IFLine(IFGeometry):
	"""
	 
	"""

	def getLineTypeCode(self) -> int:
		r"""
		Return line type from the following table: 1: straight 2: arc 3: spline 4: combined line 
		Returns:
			int: line type
		"""
		pass


	def getLineLength(self) -> float:
		r"""
		Return length of line 
		Returns:
			float: line length
		"""
		pass


	def getStartPosition(self) -> list[float]:
		r"""
		Return start coordinate of line 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getEndPosition(self) -> list[float]:
		r"""
		Return end coordinate of line 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getStartPositionCoords(self) -> IF3dCoords:
		r"""
		Return start coordinate of line 
		Returns:
			IF3dCoords: The returned position
		"""
		pass


	def getEndPositionCoords(self) -> IF3dCoords:
		r"""
		Return end coordinate of line 
		Returns:
			IF3dCoords: The returned position
		"""
		pass


	def getInterpolatedPosition(self, nrmCoord) -> list[float]:
		r"""
		Return the coordinates at the given normalised coordinate, nrmCoord=0.0 at the line start nrmCoord=1.0 at the line end 
		Params:
			nrmCoord (float): normalised coord
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getInterpolatedTangent(self, nrmCoord) -> list[float]:
		r"""
		Return the tangent at the given normalised coordinate, nrmCoord=0.0 at the line start nrmCoord=1.0 at the line end 
		Params:
			nrmCoord (float): normalised coord
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getArcCentre(self) -> list[float]:
		r"""
		Return coordinate at centre of arc 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getArcCentreCoords(self) -> IF3dCoords:
		r"""
		Return coordinate at centre of arc 
		Returns:
			IF3dCoords: The returned position
		"""
		pass


	def getArcBulge(self) -> list[float]:
		r"""
		Return coordinate of the arc bulge midpoint Note: It is an error to call this function on a combined line 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getArcRadius(self) -> float:
		r"""
		Return radius of arc Note: It is an error to call this function on a combined line 
		Returns:
			float: radius of arc
		"""
		pass


	def getArcAngleDegrees(self) -> float:
		r"""
		Return subtended angle of arc in degrees Note: It is an error to call this function on a combined line 
		Returns:
			float: angle in degrees
		"""
		pass


	def getArcAngleRadians(self) -> float:
		r"""
		Return subtended angle of arc in radians Note: It is an error to call this function on a combined line 
		Returns:
			float: angle in radians
		"""
		pass


	def getClosestToVector(self, Origin, Direction, PointOnStraightLine, PointOnThisLine, IsValidSolution) -> None:
		r"""
		Given a straight line defined by a position and direction, this function returns the closest positions on the straight line and this line 
		Params:
			Origin (array of float): An array of 3 real numbers, representing 3d coordinates Any position on the straight line
			Direction (array of float): An array of 3 real numbers, representing 3d coordinates Direction vector of the straight line
			PointOnStraightLine (array of float): An array of 3 real numbers, representing 3d coordinates Returned closest position on the straight line
			PointOnThisLine (array of float): An array of 3 real numbers, representing 3d coordinates Returned closest position on this line
			IsValidSolution (int): Flag indicating validity of solutions +1 valid, -1 invalid
		Returns:
			None: 
		"""
		pass


	def getFacetCoordinates(self) -> list[float]:
		r"""
		Return an array of model space coordinates of the facet positions along this line 
		Returns:
			array of float: vector of coordinates (x1, y1, z1, ... xn, yn, zn)
		"""
		pass


	def getNormalisedCoordFromCoords(self, pCoords) -> float:
		r"""
		Return the normalised coords of the given model space coordinated on this line *pRetval=0.0 at the line start *pRetval=1.0 at the line end 
		Params:
			pCoords (array of float): An array of 3 real numbers, representing 3d coordinates any position on the straight line
		Returns:
			float: returned equivalent normalised coordinate
		"""
		pass


	def getNormalisedCoordsFromCoords(self, pCoords) -> list[float]:
		r"""
		Return the normalised coords of the given model space coordinates on this line 
		Params:
			pCoords (array of float): An array of 3 real numbers, representing 3d coordinates any position on the straight line
		Returns:
			array of float: vector of coordinates (x1, y1, z1, ... xn, yn, zn)
		"""
		pass


	def getMass(self, loadset) -> float:
		r"""
		Returns the mass of a line for a given loadcase. Only lines that have a mesh, section and density assigned actually have any mass. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the mass will be returned
		Returns:
			mass: The returned mass of a line for a given loadcase
		"""
		pass


	def getVolume(self, loadset) -> float:
		r"""
		Returns the volume of a line for a given loadcase Only lines that have a mesh and section assigned actually have any volume. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the volume will be returned
		Returns:
			mass: The returned volume of a line for a given loadcase
		"""
		pass


	def modifyFacetNumber(self, number) -> IFLine:
		r"""
		 
		Params:
			number (int): 
		Returns:
			IFLine: 
		"""
		pass


	def modifyFacetLength(self, length) -> IFLine:
		r"""
		 
		Params:
			length (float): 
		Returns:
			IFLine: 
		"""
		pass


	def modifyFacetDeviation(self, deviation) -> IFLine:
		r"""
		 
		Params:
			deviation (float): 
		Returns:
			IFLine: 
		"""
		pass


	def modifyFacetAngle(self, sngleDegrees) -> IFLine:
		r"""
		 
		Params:
			sngleDegrees (float): 
		Returns:
			IFLine: 
		"""
		pass


	def getElementAtNormalisedPosition(self, nrmCoordOnLine, nrmCoordOnElement) -> IFElement:
		r"""
		Return the element at the given normalised coordinate, nrmCoordOnLine=0.0 at the line start nrmCoordOnLine=1.0 at the line end nrmCoordOnElement=0.0 at the element start nrmCoordOnElement=1.0 at the element end 
		Params:
			nrmCoordOnLine (float): normalised coord w.r.t the line
			nrmCoordOnElement (float): returned normalised coord w.r.t the element
		Returns:
			IFElement: returning element
		"""
		pass


	def getAxesAtNrmCrds(self, nrmCrds, origin, xAxis, yAxis, zAxis) -> None:
		r"""
		Return line axes at the given normalised coords 
		Params:
			nrmCrds (float): specified normalised coord
			origin (array of float): coordinates of origin
			xAxis (array of float): coordinates of x-axis
			yAxis (array of float): coordinates of y-axis
			zAxis (array of float): coordinates of z-axis
		Returns:
			None: 
		"""
		pass


	def orientateToScreen(self) -> None:
		r"""
		Rotate the current view so that this line lies in the plane of the screen. 
		Returns:
			None: 
		"""
		pass


	def getStartPoint(self) -> IFPoint:
		r"""
		Return the line start point 
		Returns:
			IFPoint: 
		"""
		pass


	def getEndPoint(self) -> IFPoint:
		r"""
		Return the line end point 
		Returns:
			IFPoint: 
		"""
		pass


	def getClosestToVerticalAxis(self, normalisedCrd, maxAllowDeviationDegs) -> int:
		r"""
		return flag indicating which axis of the line is closest to the current vertical axis 
		Params:
			normalisedCrd (float): normalised coord w.r.t the line
			maxAllowDeviationDegs (float): maximum allowable angle between axis and line, -ve means no limit
		Returns:
			int: closest line axis flag, +1 = +ve X, -1 = -ve X, 2,3 y, z
		"""
		pass


	def getRadiusOfCurvature(self, nrmCrds, pPointOnLine, pCentreOfCurvature, pRadiusOfCurvature) -> int:
		r"""
		calculate the centre and radius of curvature at the given normalised coordinate along this line 
		Params:
			nrmCrds (float): specified normalised coord
			pPointOnLine (array of float): coordinates of the point on this line
			pCentreOfCurvature (array of float): coordinates of the centre of curvature
			pRadiusOfCurvature (float): radius of curvature
		Returns:
			int: on exit, 0 = success, -1 = very large radius, all other values = error
		"""
		pass


	def orientateDefiningLines(self) -> bool:
		r"""
		orientate the lines defining this combined line to follow the combined line direction 
		Returns:
			bool: return true if any lines reversed
		"""
		pass


class IFPolyline(IFGeometry):
	"""
	 
	"""

	def getDefn(self) -> IFPolylineDefn:
		r"""
		Return the definition of this polyline 
		Returns:
			IFPolylineDefn: 
		"""
		pass


class IFReferencePath(IFPolyline):
	"""
	Setup reference path 
	"""

	def setDistanceStartOfPath(self, distance) -> IFReferencePath:
		r"""
		Sets the distance value for the start of the path 
		Params:
			distance (float): 
		Returns:
			IFReferencePath: 
		"""
		pass


	def setTransverseDirection(self, directionType) -> IFReferencePath:
		r"""
		Specifies the transverse direction type for the path 
		Params:
			directionType (str): direction type
		Returns:
			IFReferencePath: 
		"""
		pass


	def setSkewAngle(self, angle) -> IFReferencePath:
		r"""
		Sets the skew angle for the path 
		Params:
			angle (float): angle in degrees
		Returns:
			IFReferencePath: 
		"""
		pass


	def setLocalCoord(self, localCoord) -> IFReferencePath:
		r"""
		Sets the given local coordinate set. 
		Params:
			localCoord (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
		Returns:
			IFReferencePath: 
		"""
		pass


	def updateDefinition(self) -> IFReferencePath:
		r"""
		update definition on completion of the definition 
		Returns:
			IFReferencePath: 
		"""
		pass


	def applyUnits(self, pUnits, convertToGiven) -> IFReferencePath:
		r"""
		Converts all numerical data inside this utility to represent a units conversion. If convertToGiven is TRUE, the data is converted from the units of the current model to the units specified by the first argument.  If convertToGiven is FALSE, the underlying data is converted from the given units, to the units of the current model. 
		Params:
			pUnits (IFUnitSet): 
			convertToGiven (bool): 
		Returns:
			IFReferencePath: 
		"""
		pass


class IFCombinedLine(IFLine):
	"""
	 
	"""

	pass


class IFSurface(IFGeometry):
	"""
	 
	"""

	def getSurfaceTypeCode(self) -> int:
		r"""
		Return surface type. Possible values are: 0: Affine (Planar) 1: Cylindrical 2: Spherical 3: Conical 4: NURB 5: Coon 6: Web 7: TransSweep 8: RotSweep 9: IsoParametric 10: Offset 11: Ruled 
		Returns:
			int: surface type
		"""
		pass


	def getNormal(self, X=None, Y=None, Z=None) -> list[float]:
		r"""
		returns the normal of this surface as a vector, represented by an array of three numbers. Optionally, the position (which must be on the surface) where the normal is required may also be given. If not given, the centre of the surface is used. 
		Params:
			X (object, optional): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			array of float: The returned vector as an array of three numbers
		"""
		pass


	def getArea(self) -> float:
		r"""
		Return the surface area 
		Returns:
			float: 
		"""
		pass


	def isCoveringHole(self) -> bool:
		r"""
		Return true if this surface is covering a holes in any other surface 
		Returns:
			bool: 
		"""
		pass


	def orientateToScreen(self) -> None:
		r"""
		Rotate the current view so that this surface is perpendicular to the e plane of the screen. 
		Returns:
			None: 
		"""
		pass


	def hasCentroid(self) -> bool:
		r"""
		Return true if it is possbile to calcuate the centroid of this surface 
		Returns:
			bool: 
		"""
		pass


	def getCentroid(self) -> list[float]:
		r"""
		Return the coords of the centroid of this surface 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getAxes(self, origin, xAxis, yAxis, zAxis, position=None) -> None:
		r"""
		returns the surface axes. Optionally, the position where the axes are required may also be given. If not given, the centroid of the surface is used. 
		Params:
			origin (object): Array of 3 real numbers representing a coordinate axis in 3D space. origin coords
			xAxis (object): Array of 3 real numbers representing a coordinate axis in 3D space. x axis vector
			yAxis (object): Array of 3 real numbers representing a coordinate axis in 3D space. y axis vector
			zAxis (object): Array of 3 real numbers representing a coordinate axis in 3D space. z axis vector
			position (object, optional): Array of 3 real numbers representing a coordinate axis in 3D space. optional global coords at which to calculate axes
		Returns:
			None: 
		"""
		pass


	def getMass(self, loadset) -> float:
		r"""
		Returns the mass of a surface for a given loadcase. Only surfaces that have a mesh, thickness and density assigned actually have any mass. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the mass will be returned
		Returns:
			mass: The returned mass of a surface for a given loadcase
		"""
		pass


	def getVolume(self, loadset) -> float:
		r"""
		Returns the volume of a surface for a given loadcase. Only surfaces that have a mesh and thickness assigned actually have a volume. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the volume will be returned
		Returns:
			mass: The returned volume of a surface for a given loadcase
		"""
		pass


class IFVolume(IFGeometry):
	"""
	 
	"""

	def getVolumeTypeCode(self) -> int:
		r"""
		Return volume type. Possible values are: 1: solid 2: closed hollow 3: open hollow 
		Returns:
			int: volume type
		"""
		pass


	def getVolume(self) -> float:
		r"""
		Return the volume. 
		Returns:
			float: 
		"""
		pass


	def getMass(self, loadset) -> float:
		r"""
		Returns the mass of a volume for a given loadcase. Only volumes that have a mesh and density assigned actually have mass. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the mass will be returned
		Returns:
			mass: The returned mass of a volume for a given loadcase
		"""
		pass


class IFHollowVolume(IFGeometry):
	"""
	 
	"""

	def getVolumeTypeCode(self) -> int:
		r"""
		Returns volume type. Possible values are: 1: solid 2: closed hollow 3: open hollow 
		Returns:
			int: volume type
		"""
		pass


	def getVolume(self) -> float:
		r"""
		Returns the volume 
		Returns:
			float: 
		"""
		pass


	def setClosureTolerance(self, tolerance) -> IFHollowVolume:
		r"""
		Sets the closure tolerance for this open volume 
		Params:
			tolerance (float): 
		Returns:
			IFHollowVolume: 
		"""
		pass


	def getClosureTolerance(self) -> float:
		r"""
		Returns the closure tolerance 
		Returns:
			float: 
		"""
		pass


	def setNodeMergingTolerance(self, tolerance) -> IFHollowVolume:
		r"""
		Sets the node merging tolerance for this open volume 
		Params:
			tolerance (float): 
		Returns:
			IFHollowVolume: 
		"""
		pass


	def getNodeMergingTolerance(self) -> float:
		r"""
		Returns the node merging tolerance 
		Returns:
			float: 
		"""
		pass


	def isClosed(self) -> bool:
		r"""
		Returns True if this open volume is geometrically closed 
		Returns:
			bool: 
		"""
		pass


	def isOverConnected(self) -> bool:
		r"""
		Returns True if this open volume is geometrically open with lines defining more than 2 surfaces 
		Returns:
			bool: 
		"""
		pass


	def isUnderConnected(self) -> bool:
		r"""
		Returns True if this open volume is geometrically open with lines defining fewer than 2 surfaces 
		Returns:
			bool: 
		"""
		pass


	def addLOF(self, pLof) -> IFHollowVolume:
		r"""
		Adds to given surface to the definition of this open volume 
		Params:
			pLof (IFsurface): 
		Returns:
			IFHollowVolume: 
		"""
		pass


	def removeLOF(self, pLof) -> IFHollowVolume:
		r"""
		Removes the given surface from the definition of this open volume 
		Params:
			pLof (IFsurface): 
		Returns:
			IFHollowVolume: 
		"""
		pass


class IFNode(IFMeshFamily):
	"""
	Node object used to set and extract node data 
	"""

	def getResults(self, entity, component, units=None, loadcase=None, context=None) -> float:
		r"""
		Return the value of the specified result type and component at node. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 Note that this function will raise an error if it unable to find a single value at this node - this could happen for many reasons, including asking for the reactions of an unsupported node or for an average value at a discontinuity caused by (for example) a change of material.
 Thus, it is recommended that IFNode.hasResults() is used to verify that a single value does indeed exist. If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults
 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			loadcase (IFLoadset, optional): If this variable is given, and the currently active loadcase is an envelope, the variable will be set to the results loadcase that caused the result
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: Results value
		"""
		pass


	def getResultsUnits(self, entity, component, units=None, context=None) -> str:
		r"""
		Return the units ("N/mm2", "m/s", etc) of the value that will be returned by IFNode.getResults for the given named results. In order to find the list of valid named components, use IFResultsContext.getResultsComponentNames Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			str: the returned string
		"""
		pass


	def getVectorResults(self, entity, context=None) -> list:
		r"""
		Return a 1d array of results of the specified result type at node 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			Results Array: 
		"""
		pass


	def setScriptedResults(self, val, entity, component=None, loadcase=None) -> None:
		r"""
		Specify a named result value at node Only really useful when called for all visible nodes Then allows (for example) drawing of smoothed contours of any arbitrary values. The entity may be given either as a name, or as an index previously registered using IFDatabase.addScriptedResultsEntity. If the entity is given as a string and does not already exist, it will be created. If the component does not already exist within the given entity, a new component is created within the given entity. When called as part of a .NET callback from a LUSAS module, the results component and context are known (provided) and so may be passed directly to this routine in place of the strings. This is much faster. Note that the results will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults. 
		Params:
			val (float): User results value
			entity (str or int): Name or index of results entity
			component (str, optional): Name of results component (if 'entity' is an IFScriptedResultsComponentSet, then this is expected to be an integer)
			loadcase (IFLoadcase, optional): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase in which results apply (unless given as IFScriptedResultsComponentSet in 'entity')
		Returns:
			None: 
		"""
		pass


	def getX(self) -> float:
		r"""
		Return X coordinate at node 
		Returns:
			float: X coordinate
		"""
		pass


	def getY(self) -> float:
		r"""
		Return Y coordinate at node 
		Returns:
			float: Y coordinate
		"""
		pass


	def getZ(self) -> float:
		r"""
		Return Z coordinate at node 
		Returns:
			float: Z coordinate
		"""
		pass


	def getXYZ(self, X, Y=None, Z=None) -> None:
		r"""
		Return X,Y and Z coordinates of this node. If the first argument is given as an array of 3 doubles, the other two arguments should be omitted, and that array will be changed to contain X, Y, and Z. Otherwise the first argument will be returned as X, the second as Y, and the third as Z 
		Params:
			X (float): X coordinate
			Y (float, optional): Y coordinate
			Z (float, optional): Z coordinate
		Returns:
			None: 
		"""
		pass


	def getDeformedX(self, context=None) -> float:
		r"""
		Return deformed X coordinate at node 
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: Deformed X coordinate
		"""
		pass


	def getDeformedY(self, context=None) -> float:
		r"""
		Return deformed Y coordinate at node 
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: Deformed Y coordinate
		"""
		pass


	def getDeformedZ(self, context=None) -> float:
		r"""
		Return deformed Z coordinate at node 
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: Deformed Z coordinate
		"""
		pass


	def getDeformedXYZ(self, X, Y, Z, context=None) -> None:
		r"""
		Return deformed X,Y and Z coordinates at node 
		Params:
			X (float): Deformed X coordinate
			Y (float): Deformed Y coordinate
			Z (float): Deformed Z coordinate
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			None: 
		"""
		pass


	def getAssignments(self, attributeType=None, loadset=None, andAssignedObjects=None) -> list[IFAssignment]:
		r"""
		Creates and returns an array of IFAssignment objects, each of which represents one attribute assignment made to this object. The array can be restricted by using the optional argument to specify a given attribute type, e.g. loading. If not given, all assignments are returned Note that the IFAssignment objects returned are copies of the ones in actual use - modifying them will have no effect. If you wish to modify assignment details it is necessary to re-assign the attribute to the object 
		Params:
			attributeType (object, optional): "Loading", "Support", "Material", etc
			loadset (name, id, IFLoadset, optional): , optionally only return assignments to this loadcase
			andAssignedObjects (bool, optional): default false, if true add the assigned objects to the IFAssignment objects returned
		Returns:
			array of IFAssignment objects: The returned array
		"""
		pass


	def getFreedoms(self) -> list[int]:
		r"""
		Creates and returns an array of all freedoms at this node Each item in the array is a freedom number 
		Returns:
			array of ints: The returned array
		"""
		pass


	def getActivePosition(self) -> int:
		r"""
		Returns active node index 
		Returns:
			int: active node index
		"""
		pass


	def getEdges(self) -> list[IFEdge]:
		r"""
		Returns array of IFEdge objects which define this node 
		Returns:
			array of IFEdge objects: The returned array of node objects
		"""
		pass


	def getFaces(self) -> list[IFFace]:
		r"""
		Returns array of IFFace objects which are defined by this node 
		Returns:
			array of IFFace objects: The returned array of node objects
		"""
		pass


	def getElements(self) -> list[IFElement]:
		r"""
		Creates and returns an array of all IFElement objects which are defined by this node 
		Returns:
			array of IFElement objects: The returned array
		"""
		pass


	def getMass(self, loadset) -> float:
		r"""
		Returns the mass of a node for a given loadcase. Only nodes that belong to point mass elements and have mass material assigned actually have mass. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the mass will be returned
		Returns:
			mass: The returned mass of a node for a given loadcase
		"""
		pass


	def countFreedoms(self) -> int:
		r"""
		return the number of degrees of freedom at this node 
		Returns:
			int: 
		"""
		pass


	def setPosition(self, X, Y, Z) -> None:
		r"""
		Specify new coordinates for the node, for example to update the position for locked-in deformations. 
		Params:
			X (float): New X coordinate
			Y (float): New Y coordinate
			Z (float): New Z coordinate
		Returns:
			None: 
		"""
		pass


	def isShowingResults(self, context=None) -> bool:
		r"""
		Return true if this node is a member of set of elements and nodes showing results in the current view 
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: 
		"""
		pass


	def isCalculatingResults(self, context=None) -> bool:
		r"""
		Return true if this node is a member of set of elements and nodes calculating results in the current view 
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: 
		"""
		pass


	def hasResults(self, entity, component, context=None) -> bool:
		r"""
		Return whether or not there is a single value of the specified result type and component at this node. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 This function is typically used as a safety check before calling IFNode.getResults(), because, for example, it is invalid to ask for the reactions of an unsupported node or for an average value at a discontinuity caused by (for example) a change of material 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: TRUE if the result does exist
		"""
		pass


class IFEdge(IFMeshFamily):
	"""
	 
	"""

	def getNodes(self) -> list[IFNode]:
		r"""
		Returns array of IFNode objects which define this edge 
		Returns:
			array of IFNode objects: The returned array of node objects
		"""
		pass


	def getFaces(self) -> list[IFFace]:
		r"""
		Returns array of IFFace objects which are defined by this edge 
		Returns:
			array of IFFace objects: The returned array of node objects
		"""
		pass


	def getElements(self) -> list[IFElement]:
		r"""
		Creates and returns an array of all IFElement objects which are defined by this edge 
		Returns:
			array of IFElement objects: The returned array
		"""
		pass


	def getLength(self) -> float:
		r"""
		Returns the length of this edge 
		Returns:
			float: length of this edge
		"""
		pass


class IFFace(IFMeshFamily):
	"""
	 
	"""

	def getNodes(self) -> list[IFNode]:
		r"""
		Returns array of IFNode objects which define this face 
		Returns:
			array of IFNode objects: The returned array of node objects
		"""
		pass


	def getEdges(self) -> list[IFEdge]:
		r"""
		Returns array of IFEdge objects which define this face 
		Returns:
			array of IFEdge objects: The returned array of node objects
		"""
		pass


	def getElements(self) -> list[IFElement]:
		r"""
		Creates and returns an array of all IFElement objects which are defined by this face 
		Returns:
			array of IFElement objects: The returned array
		"""
		pass


class IFElement(IFMeshFamily):
	"""
	Functions available on an element object 
	"""

	def countGaussPoints(self) -> int:
		r"""
		Returns the number of Gauss points for element Note that for most elements, there is no difference between a true Gauss point and an internal point. The difference is only apparent for beams. For example BMI21 has 1 Gauss point but 11 internal points. 
		Returns:
			int: Number of Gauss points for element
		"""
		pass


	def countInternalPoints(self) -> int:
		r"""
		Returns the number of internal results points for element Note that for most elements, there is no difference between a true Gauss point and an internal point. The difference is only apparent for beams. For example BMI21 has 1 Gauss point but 11 internal points. 
		Returns:
			int: Number of internal points for element
		"""
		pass


	def getNodes(self) -> list[IFNode]:
		r"""
		Returns array of IFNode objects which define this element 
		Returns:
			array of IFNode objects: The returned array of node objects
		"""
		pass


	def getFaces(self) -> list[IFFace]:
		r"""
		Returns array of IFFace objects which define this element 
		Returns:
			array of IFFace objects: The returned array of node objects
		"""
		pass


	def getMass(self, loadset) -> float:
		r"""
		Returns the mass of an element for a given loadcase. Only elements that have density assigned actually have mass. 
		Params:
			loadset (name, id, IFLoadset): The loadcase for which the mass will be returned
		Returns:
			mass: The returned mass of an element for a given loadcase
		"""
		pass


	def getResultsUnits(self, entity, component, units=None, context=None) -> str:
		r"""
		Return the units ("N/mm2", "m/s", etc) of the value that will be returned by IFElement.getGaussResults and IFElement.getNodeResults for the given named results. In order to find the list of valid named components, use IFResultsContext.getResultsComponentNames Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			str: the returned string
		"""
		pass


	def getGaussResults(self, iGauss, entity, component, units=None, loadcase=None, context=None) -> float:
		r"""
		Return result value of specified type and component at Gauss point for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 Note that for most elements, there is no difference between a true Gauss point and an internal point. The difference is only apparent for beams. For example BMI21 as 1 Gauss point but 11 internal points.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			iGauss (int): Gauss point index
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			loadcase (IFLoadset, optional): If this variable is given, and the currently active loadcase is an envelope, the variable will be set to the results loadcase that caused the result
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: results value
		"""
		pass


	def hasGaussResults(self, iGauss, entity, component, context=None) -> bool:
		r"""
		As IFElement.getGaussResults, but returns true (results available) or false (not available) to allow a programmer to inquire, in advance, whether IFElement.getGaussResults would return an error 
		Params:
			iGauss (int): Gauss point index
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: true if results available
		"""
		pass


	def getInternalResults(self, iPoint, entity, component, units=None, loadcase=None, context=None) -> float:
		r"""
		Return result value of specified type and component at internal point for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 Note that for most elements, there is no difference between a true Gauss point and an internal point. The difference is only apparent for beams. For example BMI21 as 1 Gauss point but 11 internal points.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			iPoint (int): internal point index
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			loadcase (IFLoadset, optional): If this variable is given, and the currently active loadcase is an envelope, the variable will be set to the results loadcase that caused the result
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: results value
		"""
		pass


	def hasInternalResults(self, iPoint, entity, component, context=None) -> bool:
		r"""
		As IFElement.getInternalResults, but returns true (results available) or false (not available) to allow a programmer to inquire, in advance, whether IFElement.getInternalResults would return an error 
		Params:
			iPoint (int): internal point index
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: true if results available
		"""
		pass


	def getGaussResultsArray(self, entity, component, units=None, context=None) -> list:
		r"""
		Return result values of specified type and component at all Gauss points for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a set of values using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same values again will yield two different sets of values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 Note that for most elements, there is no difference between a true Gauss point and an internal point. The difference is only apparent for beams. For example BMI21 as 1 Gauss point but 11 internal points.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			array: returned array
		"""
		pass


	def getInternalResultsArray(self, entity, component, units=None, context=None) -> list:
		r"""
		Return result values of specified type and component at all internal points for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a set of values using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same values again will yield two different sets of values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 Note that for most elements, there is no difference between a true Gauss point and an internal point. The difference is only apparent for beams. For example BMI21 as 1 Gauss point but 11 internal points.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			array: returned array
		"""
		pass


	def setGaussScriptedResults(self, iGauss, val, entity, component=None, loadcase=None) -> None:
		r"""
		Specify a named result value at one Gauss point of this element Only really useful when called for all Gauss points of all visible elements Note that for most elements, there is no difference between a true Gauss point and an internal point. The difference is only apparent for beams. For example BMI21 as 1 Gauss point but 11 internal points. The entity may be given either as a name, or as an index previously registered using IFDatabase.addScriptedResultsEntity. If the entity is given as a string and does not already exist, it will be created. If the component does not already exist within the given entity, a new component is created within the given entity. When called as part of a .NET callback from a LUSAS module, the results component and context are known (provided) and so may be passed directly to this routine in place of the strings. This is much faster. Note that the results will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			iGauss (int): Gauss point index
			val (float): Results value
			entity (str int or IFScriptedResultsComponentSet): Name or index of results entity, or object in which to store results
			component (str, optional): Name of results component (if 'entity' is an IFScriptedResultsComponentSet, then this is expected to be an integer)
			loadcase (IFLoadcase, optional): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase in which results apply (unless given as IFScriptedResultsComponentSet in 'entity')
		Returns:
			None: 
		"""
		pass


	def setInternalScriptedResults(self, iPoint, val, entity, component=None, loadcase=None) -> None:
		r"""
		Specify a named result value at one internal point of this element Only really useful when called for all internal points of all visible elements Then allows (for example) drawing of beam contours and diagrams of any arbitary values. Note that for most elements, there is no difference between a "Gauss" point and an "internal" point. The difference is only apparent for beams. For example BMI21 as 1 Gauss point (at which the element yields) but 11 internal points (for drawing diagrams and contours) The entity may be given either as a name, or as an index previously registered using IFDatabase.addScriptedResultsEntity. If the entity is given as a string and does not already exist, it will be created. If the component does not already exist within the given entity, a new component is created within the given entity. When called as part of a .NET callback from a LUSAS module, the results component and context are known (provided) and so may be passed directly to this routine in place of the strings. This is much faster. Note that the results will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			iPoint (int): internal point index
			val (float): Results value
			entity (str int or IFScriptedResultsComponentSet): Name or index of results entity, or object in which to store results
			component (str, optional): Name of results component (if 'entity' is an IFScriptedResultsComponentSet, then this is expected to be an integer)
			loadcase (IFLoadcase, optional): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase in which results apply (unless given as IFScriptedResultsComponentSet in 'entity')
		Returns:
			None: 
		"""
		pass


	def getGaussVectorResults(self, iGauss, entity, context=None) -> list:
		r"""
		Return vector of results values of specified type at Gauss point for element 
		Params:
			iGauss (int): Gauss point index
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			Results Array: 
		"""
		pass


	def getInternalVectorResults(self, iPoint, entity, context=None) -> list:
		r"""
		Return vector of results values of specified type at internal point for element 
		Params:
			iPoint (int): internal point index
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			Results Array: 
		"""
		pass


	def getNodeResults(self, node, entity, component, units=None, loadcase=None, context=None) -> float:
		r"""
		Return results values of specified type at node for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			node (int or IFNode): local node (0..nNodes-1) or node pointer
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			loadcase (IFLoadset, optional): If this variable is given, and the currently active loadcase is an envelope, the variable will be set to the results loadcase that caused the result
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: results value
		"""
		pass


	def hasNodeResults(self, node, entity, component, context=None) -> bool:
		r"""
		
		Params:
			node (int or IFNode): local node (0..nNodes-1) or node pointer
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: true if results available
		"""
		pass


	def getAveragedNodeResults(self, node, entity, component, units=None, loadcase=None, context=None) -> float:
		r"""
		Return results values of specified type at node for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a value using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same value again will yield two different values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 The returned value will include contributions from any neighbouring elements that are present in the results calculation set, bearing in mind any discontinuities that may exist.
 If an IFUnitSet object (or its name) is given, the value will be returned.
 in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			node (int or IFNode): local node (0..nNodes-1) or node pointer
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			loadcase (IFLoadset, optional): If this variable is given, and the currently active loadcase is an envelope, the variable will be set to the results loadcase that caused the result
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			float: results value
		"""
		pass


	def getNodeResultsArray(self, entity, component, units=None, context=None) -> list:
		r"""
		Return results values of specified type at all nodes for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a set of values using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same values again will yield two different sets of values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			array: returned array
		"""
		pass


	def getAveragedNodeResultsArray(self, entity, component, units=None, context=None) -> list:
		r"""
		Return results values of specified type at all nodes for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead.
 Asking for a set of values using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same values again will yield two different sets of values - except in some very specific circumstances that are explained in IFResultsComponentSet.
 The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object.
 The component may be specified as a string ("Fx", "DX", etc) or as an integer component number. Component numbers may be obtained using IFResultsComponentSet.getComponentNumber and are faster to process than component names.
 The returned values will include contributions from any neighbouring elements that are present in the results calculation set, bearing in mind any discontinuities that may exist.
 If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system.
 Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
			units (IFUnitSet, optional): 
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			array: returned array
		"""
		pass


	def setNodeScriptedResults(self, node, val, entity, component=None, loadcase=None) -> None:
		r"""
		Specify a named result value at one node of this element Only really useful when called for all nodes of all visible elements Then allows (for example) drawing of unsmoothed contours of any arbitrary values. The entity may be given either as a name, or as an index previously registered using IFDatabase.addScriptedResultsEntity. If the entity is given as a string and does not already exist, it will be created. If the component does not already exist within the given entity, a new component is created within the given entity. When called as part of a .NET callback from a LUSAS module, the results component and context are known (provided) and so may be passed directly to this routine in place of the strings. This is much faster. Note that the results will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			node (int or IFNode): local node (0..nNodes-1) or node pointer
			val (float): User results value
			entity (str int or IFScriptedResultsComponentSet): Name or index of results entity, or object in which to store results
			component (str, optional): Name of results component (if 'entity' is an IFScriptedResultsComponentSet, then this is expected to be an integer)
			loadcase (IFLoadcase, optional): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase in which results apply (unless given as IFScriptedResultsComponentSet in 'entity')
		Returns:
			None: 
		"""
		pass


	def setAveragedScriptedResults(self, node, val, entity, component=None, loadcase=None) -> None:
		r"""
		Specify a named averaged result value at one node of this element Only really useful when called for all nodes of all visible elements Then allows (for example) drawing of smoothed contours of any arbitrary values, respecting averaging discontinuities. Note that Modeller will not perform any additional averaging on the numbers given, rather it is assumed that the numbers have been computed from averaged raw results obtained from IFElement.getAveragedNodeResults. The name "averaged" in this function name, therefore, refers only to the word used to present the component in the user interface. The entity may be given either as a name, or as an index previously registered using IFDatabase.addScriptedResultsEntity. If the entity is given as a string and does not already exist, it will be created. If the component does not already exist within the given entity, a new component is created within the given entity. When called as part of a .NET callback from a LUSAS module, the results component and context are known (provided) and so may be passed directly to this routine in place of the strings. This is much faster. Note that the results will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults 
		Params:
			node (int or IFNode): local node (0..nNodes-1) or node pointer
			val (float): User results value
			entity (str int or IFScriptedResultsComponentSet): Name or index of results entity, or object in which to store results
			component (str, optional): Name of results component (if 'entity' is an IFScriptedResultsComponentSet, then this is expected to be an integer)
			loadcase (IFLoadcase, optional): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase in which results apply (unless given as IFScriptedResultsComponentSet in 'entity')
		Returns:
			None: 
		"""
		pass


	def getNodeVectorResults(self, node, entity, context=None) -> list:
		r"""
		Return a vector of results values of specified type for element. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead. Asking for a set of values using this function, subsequently changing a setting in the context (e.g. active loadcase or transformation), and then asking for the same values again will yield two different sets of values - except in some very specific circumstances that are explained in IFResultsComponentSet. The entity may be specified as a string ("displacement", "strain", etc) or as an IFResultsComponentSet object. 
		Params:
			node (int or IFNode): local node (0..nNodes-1) or node pointer
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			Results Array: 
		"""
		pass


	def getFeature(self) -> IFGeometry:
		r"""
		Return feature object which created element 
		Returns:
			IFGeometry: feature
		"""
		pass


	def getNodeAxes(self, iNode, origin, xAxis, yAxis, zAxis) -> None:
		r"""
		Return element axes at the given node 
		Params:
			iNode (int): specified local node index
			origin (coordarray): coordinates of origin
			xAxis (coordarray): coordinates of x-axis
			yAxis (coordarray): coordinates of y-axis
			zAxis (coordarray): coordinates of z-axis
		Returns:
			None: 
		"""
		pass


	def getGaussAxes(self, iGauss, origin, xAxis, yAxis, zAxis) -> None:
		r"""
		Return element axes at the given Gauss point 
		Params:
			iGauss (int): specified local Gauss point index
			origin (coordarray): coordinates of origin
			xAxis (coordarray): coordinates of x-axis
			yAxis (coordarray): coordinates of y-axis
			zAxis (coordarray): coordinates of z-axis
		Returns:
			None: 
		"""
		pass


	def getInternalAxes(self, iPoint, origin, xAxis, yAxis, zAxis) -> None:
		r"""
		Return element axes at the given internal point 
		Params:
			iPoint (int): specified local internal point index
			origin (coordarray): coordinates of origin
			xAxis (coordarray): coordinates of x-axis
			yAxis (coordarray): coordinates of y-axis
			zAxis (coordarray): coordinates of z-axis
		Returns:
			None: 
		"""
		pass


	def getAxes(self, origin, xAxis, yAxis, zAxis) -> None:
		r"""
		Return element axes at the element centroid 
		Params:
			origin (coordarray): coordinates of origin
			xAxis (coordarray): coordinates of x-axis
			yAxis (coordarray): coordinates of y-axis
			zAxis (coordarray): coordinates of z-axis
		Returns:
			None: 
		"""
		pass


	def getAxesAtNrmCrds(self, nrmCrds, origin, xAxis, yAxis, zAxis) -> None:
		r"""
		Return element axes at the given normalised coords 
		Params:
			nrmCrds (coordarray): specified normalised coords
			origin (coordarray): coordinates of origin
			xAxis (coordarray): coordinates of x-axis
			yAxis (coordarray): coordinates of y-axis
			zAxis (coordarray): coordinates of z-axis
		Returns:
			None: 
		"""
		pass


	def getAssignments(self, attributeType=None, loadset=None, andAssignedObjects=None) -> list[IFAssignment]:
		r"""
		Creates and returns an array of IFAssignment objects, each of which represents one attribute assignment made to this object. The array can be restricted by using the optional argument to specify a given attribute type, e.g. loading. If not given, all assignments are returned Note that the IFAssignment objects returned are copies of the ones in actual use - modifying them will have no effect. If you wish to modify assignment details it is necessary to re-assign the attribute to the object 
		Params:
			attributeType (object, optional): "Loading", "Support", "Material", etc
			loadset (name, id, IFLoadset, optional): , optionally only return assignments to this loadcase
			andAssignedObjects (bool, optional): default false, if true add the assigned objects to the IFAssignment objects returned
		Returns:
			array of IFAssignment objects: The returned array
		"""
		pass


	def getVariable(self, varName) -> int:
		r"""
		Return specified element variable 
		Params:
			varName (str): elementVariable
		Returns:
			int: value of specified element variable
		"""
		pass


	def getElementTypeCode(self) -> int:
		r"""
		Return element type code - e.g. 1 = HX8, 2 = HX20 
		Returns:
			int: Element type code
		"""
		pass


	def getElementType(self) -> str:
		r"""
		Return element type name - e.g. "HX20" 
		Returns:
			str: Element type name
		"""
		pass


	def getStressType(self) -> str:
		r"""
		Return stress type (sometimes called MDLR) name - e.g. "Solid", "Thick Shell" 
		Returns:
			str: Element stress type
		"""
		pass


	def getDomainDimension(self) -> int:
		r"""
		Returns 1 for line elements (e.g. beams), 2 for surface elements (e.g. plates/shells) and 3 for volume elements (e.g. solids) Note that axisymmetric elements will return the lower code - so an axisymmetric shell will return 1 and an axisymmetric volume will return 2. 
		Returns:
			int: The returned dimension
		"""
		pass


	def getResultsMaterialID(self) -> int:
		r"""
		Return material ID from results file 
		Returns:
			int: material ID
		"""
		pass


	def getResultsGeometryID(self) -> int:
		r"""
		Return geometric properties ID from results file 
		Returns:
			int: geometric ID
		"""
		pass


	def getAttributeValue(self, attrType, varName, loadcase=None, units=None, errorFlag=None, singleLoadcase=None) -> object:
		r"""
		Retrieves element-wide attribute values such as material properties Not to be used for properties that might vary across an element or nodal attribute values such as support conditions 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			varName (str): 
			loadcase (IFUnitSet, optional): 
			units (IFUnitSet, optional): 
			errorFlag (bool, optional): If provided, and an error occurs (e.g. attribute not assigned), this flag is set true, and no error is reported
			singleLoadcase (bool, optional): if T process just the given loadcase, if F descend the loadcases, default true
		Returns:
			object: The type of value returned will depend on what was requested
		"""
		pass


	def getNodeAttributeValue(self, node, attrType, varName, loadcase=None, units=None, errorFlag=None, singleLoadcase=None) -> object:
		r"""
		Retrieves attribute values that might vary across an element, like geometric thickness, or nodal attribute values such as support conditions Not to be used for properties that must be fixed across an element (such as material properties) 
		Params:
			node (IFNode): The name or ID of a node, or a pointer to a IFNode object. local node  (0..nNodes-1) or node pointer
			attrType (object): "Loading", "Support", "Material", etc
			varName (str): 
			loadcase (IFUnitSet, optional): 
			units (IFUnitSet, optional): 
			errorFlag (bool, optional): If provided, and an error occurs (e.g. attribute not assigned), this flag is set true, and no error is reported
			singleLoadcase (bool, optional): if T process just the given loadcase, if F descend the loadcases, default true
		Returns:
			object: The type of value returned will depend on what was requested
		"""
		pass


	def getAttributeValueAtU(self, u, attrType, varName, loadcase=None, units=None, errorFlag=None, singleLoadcase=None) -> object:
		r"""
		As IFElement.getAttributeValue, but only works for beam elements and returns the value corresponding to the given distance along the beam, e.g. calculating variations, and interpolating for tapered beams as necessary 
		Params:
			u (float): distance along beam (0..1)
			attrType (object): "Loading", "Support", "Material", etc
			varName (str): 
			loadcase (IFUnitSet, optional): 
			units (IFUnitSet, optional): 
			errorFlag (bool, optional): If provided, and an error occurs (e.g. attribute not assigned), this flag is set true, and no error is reported
			singleLoadcase (bool, optional): if T process just the given loadcase, if F descend the loadcases, default true
		Returns:
			object: The type of value returned will depend on what was requested
		"""
		pass


	def getInterpolatedPosition(self, pNrmCrdsIn, pMdlCrdsOut) -> None:
		r"""
		Interpolate model space coordinates at the given normalised local coordinates 
		Params:
			pNrmCrdsIn (array of float): An array of 3 real numbers, representing 3d coordinates normalised coordinates, range (0.0 to 1.0)
			pMdlCrdsOut (array of float): An array of 3 real numbers, representing 3d coordinates interpolated model space coordinates
		Returns:
			None: 
		"""
		pass


	def getLength(self) -> float:
		r"""
		return the length of this element, only meaningful for beam type elements 
		Returns:
			float: 
		"""
		pass


	def getArea(self) -> float:
		r"""
		return the area of this element, only meaningful for shell and membrane type elements 
		Returns:
			float: 
		"""
		pass


	def getVolume(self) -> float:
		r"""
		return the volume of this element, only meaningful for solid elements 
		Returns:
			float: 
		"""
		pass


	def isStartFreedomReleased(self, dof, fixityValue=None) -> bool:
		r"""
		return true if the given freedom is released at the start node of this beam element 
		Params:
			dof (str): degree of freedom "u", "v", etc
			fixityValue (float, optional): fixity value for partial fixity end release types
		Returns:
			bool: 
		"""
		pass


	def isEndFreedomReleased(self, dof, fixityValue=None) -> bool:
		r"""
		return true if the given freedom is released at the end node of this beam element 
		Params:
			dof (str): degree of freedom "u", "v", etc
			fixityValue (float, optional): fixity value for partial fixity end release types
		Returns:
			bool: 
		"""
		pass


	def isActive(self, context=None) -> bool:
		r"""
		Return true if this element is activated (as opposed to deactivated) in the current view. This will depend on the assignments of IFActivate and IFDeactivate that have been made to the parent geometry of this element, and the currently activated loadcase in the view, but has nothing to do with visibility etc  
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: 
		"""
		pass


	def isShowingResults(self, context=None) -> bool:
		r"""
		Return true if this element is a member of set of elements showing results in the current view 
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: 
		"""
		pass


	def isCalculatingResults(self, context=None) -> bool:
		r"""
		Return true if this element is a member of set of elements calculating results in the current view 
		Params:
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			bool: 
		"""
		pass


	def solverGeometricValueNames(self) -> list[str]:
		r"""
		Retrieves the names of the geometric properties that will actually be used by LUSAS Solver for this element. E.g for a BAR, Solver uses A, for a 2d beam Solver uses A, Izz, Asy and ey, etc. This is often only a small subset of the full list of properties available. These names can be passed into (for example) IFElement.getAttributeValue 
		Returns:
			array of strs: The names of values used
		"""
		pass


	def shouldUseInternalPoints(self) -> bool:
		r"""
		Returns true for those elements that should normally use 'internal points' in results computations (this means beams) and false for those elements that should normally use 'Gauss points' in results computations (this means everything except beams). Really, this function just saves you the effort of trying to work out whether or not an element is a beam 
		Returns:
			bool: 
		"""
		pass


	def isStartRigidZone(self) -> bool:
		r"""
		Return true if this element is in the line start rigid zone 
		Returns:
			bool: 
		"""
		pass


	def isEndRigidZone(self) -> bool:
		r"""
		Return true if this element is in the line end rigid zone 
		Returns:
			bool: 
		"""
		pass


	def isJoint(self) -> bool:
		r"""
		Return true if this element is a joint element 
		Returns:
			bool: 
		"""
		pass


	def hasCentroid(self) -> bool:
		r"""
		Return true if it is possbile to calcuate the centroid of this element 
		Returns:
			bool: 
		"""
		pass


	def getCentroid(self) -> list[float]:
		r"""
		Return the coords of the centroid of this element 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def getActivationLoadcase(self, loadcaseOfInterest=None) -> object:
		r"""
		Return the loadcase in which this element was "born" - i.e. the loadcase in which an activate attribute was most recently assigned. Note that it is possible for an element to be "born", "die", and be "born again" any number of times if multiple IFDeactivate and IFActivate assignments are made. In such cases, it will be necessary to pass in the loadcase of interest. This function will track backwards in time from that point, looking for the most recent activation. If the element is inactive in the loadcase of interest, an error is generated. If no activation exists, the first loadcase is returned (the element is assumed to be always active). 
		Params:
			loadcaseOfInterest (IFLoadcase, optional): The name or ID of a loadcase, or a pointer to a IFLoadcase object. The "time" at which to start looking. If not given, the current loadcase is assumed
		Returns:
			IFLoadcase: The returned loadcase
		"""
		pass


class IFGroup(IFObjectSet):
	"""
	A group of IFDatabaseMember objects. Groups are created purely for user convenience. You can add or remove any objects at any time from a group. Groups may overlap - i.e. they may contain some or all of the same members as other groups 
	"""

	def getTypeCode(self) -> int:
		r"""
		Returns the type code of this object, which will have the value 11, meaning group 
		Returns:
			int: 
		"""
		pass


	def getGroupTypeCode(self, isTopGroupOfType=None) -> int:
		r"""
		Returns the type of this group from the following table: 0: Normal group 1: Not currently used 2: Intrinsic structure group (e.g. "groups", "slices") 3: Slice (post processing) 4: Thermal surface (post processing) 5: Slideline master (post processing) 6: Slideline slave (post processing) 7: Composite layer (post processing) 8: Storey group 
		Params:
			isTopGroupOfType (bool, optional): set true if this group is a sub-section group
		Returns:
			int: 
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns objects ID IDs are program-generated and quite separate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def isMemberOfGroup(self, group) -> bool:
		r"""
		return TRUE if this object is a member of the given group 
		Params:
			group (IFGroup): The name or ID of a group, or a pointer to a IFGroup object.
		Returns:
			bool: 
		"""
		pass


	def getHighestParentGroup(self) -> IFGroup:
		r"""
		Returns the outermost group, equivalent to the whole database 
		Returns:
			IFGroup: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns the name of 'this' group 
		Returns:
			str: 
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Changes the name of 'this' group 
		Params:
			newName (str): 
		Returns:
			None: 
		"""
		pass


	def getAssignments(self, attributeType=None, loadset=None, andAssignedObjects=None) -> list[IFAssignment]:
		r"""
		Creates and returns an array of IFAssignment objects, each of which represents one attribute assignment made to this object. The array can be restricted by using the optional argument to specify a given attribute type, e.g. loading. If not given, all assignments are returned Note that the IFAssignment objects returned are copies of the ones in actual use - modifying them will have no effect. If you wish to modify assignment details it is necessary to re-assign the attribute to the object 
		Params:
			attributeType (object, optional): "Loading", "Support", "Material", etc
			loadset (name, id, IFLoadset, optional): , optionally only return assignments to this loadcase
			andAssignedObjects (bool, optional): default false, if true add the assigned objects to the IFAssignment objects returned
		Returns:
			array of IFAssignment objects: The returned array extras
		"""
		pass


	def setCurrent(self) -> None:
		r"""
		Makes 'this' group the current one. That is to say, all newly created objects automatically become members of 'this' group 
		Returns:
			None: 
		"""
		pass


	def ungroup(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def createValue(self, varNname, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Creates a new value within this object for subsequent use. The initial value will be 0.0 until modified by a call to IFGroup.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFGroup.setValue and/or subsequent access with IFGroup.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			varNname (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this object contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def setValue(self, varName, value, units=None) -> IFDispatch:
		r"""
		Sets the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): name of the value (e.g. "E")
			value (object): The type given will depend on the value specified
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValue(self, varName, units=None) -> object:
		r"""
		Returns the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): 
			units (IFUnitSet, optional): 
		Returns:
			object: The type returned will depend on the value requested
		"""
		pass


	def getValueUnits(self, varName, units=None) -> str:
		r"""
		Returns the units ("N/mm�", "m/s", etc) of the value that will be returned by IFGroup.getValue for the given named variable. Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			varName (str): name of the value (e.g. "E")
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			str: the returned string
		"""
		pass


	def getValueNames(self) -> list[str]:
		r"""
		Allows user to inquire the names of values which are valid to be used in IFGroup.getValue The return value is an array of strings, each of which is a valid value name. 
		Returns:
			array of strs: Returned array of names
		"""
		pass


class IFBackgroundGrid(IFDatabaseMember):
	"""
	 
	"""

	def isSelected(self) -> bool:
		r"""
		Returns True if object is selected 
		Returns:
			bool: 
		"""
		pass


	def isVisible(self) -> bool:
		r"""
		Returns True if object is visible 
		Returns:
			bool: 
		"""
		pass


	def getTypeCode(self) -> int:
		r"""
		Returns the type code of this object, which will have the value 10, meaning background grid 
		Returns:
			int: 
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns objects ID IDs are program-generated and quite separate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def isMemberOfGroup(self, group) -> bool:
		r"""
		Returns TRUE if this object is a member of the given group 
		Params:
			group (IFGroup): The name or ID of a group, or a pointer to a IFGroup object.
		Returns:
			bool: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns object name 
		Returns:
			str: Name
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Sets object name 
		Params:
			newName (str): Name extras
		Returns:
			None: 
		"""
		pass


class IFLayoutGrid(IFGeometry):
	"""
	Base interface for the IFLayoutGridRectangular and IFLayoutGridCircular 
	"""

	def setOrigin(self, X, Y=None, Z=None) -> IFLayoutGrid:
		r"""
		Sets the origin of the grid. 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (Y-coord, optional): 
			Z (Z-coord, optional): 
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getOrigin(self) -> list[float]:
		r"""
		Returns the origin of the grid 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def setPlane(self, plane) -> IFLayoutGrid:
		r"""
		Sets grid's plane 
		Params:
			plane (str): "XY", "XZ", "YZ" plane
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getPlane(self) -> str:
		r"""
		Returns grid's plane 
		Returns:
			str: The returned plane
		"""
		pass


	def setRotation(self, rotation) -> IFLayoutGrid:
		r"""
		Sets the rotation angle of the grid 
		Params:
			rotation (float): The rotation
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getRotation(self) -> float:
		r"""
		Returns the rotation angle of the grid 
		Returns:
			float: The returned rotation
		"""
		pass


	def setDrawingStyle(self, drawingStyle) -> IFLayoutGrid:
		r"""
		Sets grid drawing style for this to be drawn with lines, dots or both with lines and dots. 
		Params:
			drawingStyle (str): "lines", "dots", "lines and dots"
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getDrawingStyle(self) -> str:
		r"""
		Returns grid's drawing style 
		Returns:
			str: The returned drawing style
		"""
		pass


	def setFirstLabelU(self, label) -> IFLayoutGrid:
		r"""
		Sets the first label in local u direction. 
		Params:
			label (str): "3", "4", "7", "11" etc
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getFirstLabelU(self) -> str:
		r"""
		Returns the first label in local u direction. 
		Returns:
			str: The returned label
		"""
		pass


	def setFirstLabelV(self, label) -> IFLayoutGrid:
		r"""
		Sets the first label in local v direction. 
		Params:
			label (str): "A", "D", "AA", "ACA" etc
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getFirstLabelV(self) -> str:
		r"""
		Returns the first label in local v direction. 
		Returns:
			str: The returned label
		"""
		pass


	def setLabelPosU(self, pos, inReverse) -> IFLayoutGrid:
		r"""
		Sets the labels positioning in local u direction. 
		Params:
			pos (str): "Left", "Right", "Both", "None"
			inReverse (bool): true to reverse the lableing direction
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getLabelPosU(self) -> str:
		r"""
		Returns the labels positioning in local u direction. 
		Returns:
			str: The returned label position, "Left", "Right", "Both", "None"
		"""
		pass


	def setLabelPosV(self, pos, inReverse) -> IFLayoutGrid:
		r"""
		Sets the labels positioning in local v direction. 
		Params:
			pos (str): "Top", "Bottom", "Both", "None"
			inReverse (bool): true to reverse the lableing direction
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getLabelPosV(self) -> str:
		r"""
		Returns the labels positioning in local v direction. 
		Returns:
			str: The returned label position, "Left", "Right", "Both", "None"
		"""
		pass


	def setLabelUFlatToScreen(self, flat) -> None:
		r"""
		If set to True then the labels in the u direction will always be drawn flat to screen; otherwise they will be drawn in grid's plane 
		Params:
			flat (bool): 
		Returns:
			None: 
		"""
		pass


	def isLabelUFlatToScreen(self) -> bool:
		r"""
		Returns True if the labels in the u direction are always flat to screen; False if they are drawn in grid's plane 
		Returns:
			bool: 
		"""
		pass


	def setLabelVFlatToScreen(self, flat) -> None:
		r"""
		If set to True then the labels in the v direction will always be drawn flat to screen; otherwise they will be drawn in grid's plane 
		Params:
			flat (bool): 
		Returns:
			None: 
		"""
		pass


	def isLabelVFlatToScreen(self) -> bool:
		r"""
		Returns True if the labels in the v direction are always flat to screen; False if they are drawn in grid's plane 
		Returns:
			bool: 
		"""
		pass


	def setVisible(self, visible) -> IFLayoutGrid:
		r"""
		Shows or hides the grid. Applies to all views 
		Params:
			visible (bool): True for visible
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def setAbsoluteU(self, isAbsolute) -> IFLayoutGrid:
		r"""
		Determines if the values that will be passed in function IFLayoutGrid.setCustomSpacingU will be absolute distances from the origin or incremental. 
		Params:
			isAbsolute (bool): The absolute flag
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def isAbsoluteU(self) -> bool:
		r"""
		Returns True if the values that may retrieved from function IFLayoutGrid.getCustomSpacingU will be absolute distances from the origin and not incremental. 
		Returns:
			bool: True for the absolute flag
		"""
		pass


	def setAbsoluteV(self, isAbsolute) -> IFLayoutGrid:
		r"""
		Determines if the values that will be passed in function IFLayoutGrid.setCustomSpacingV will be absolute distances(angles for Circular grids) from the origin or incremental. 
		Params:
			isAbsolute (bool): The absolute flag
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def isAbsoluteV(self) -> bool:
		r"""
		Returns True if the values that may retrieved from function IFLayoutGrid.getCustomSpacingV will be absolute distances from the origin and not incremental. 
		Returns:
			bool: True for the absolute flag
		"""
		pass


	def setFixedSpacingU(self, numberOfLines, spacing) -> IFLayoutGrid:
		r"""
		Sets a fixed spacing between the grid lines in local u direction. 
		Params:
			numberOfLines (int): Number of lines
			spacing (float): spacing
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getNumberOfLinesU(self) -> int:
		r"""
		Returns the number of lines in local u direction. 
		Returns:
			int: The number of lines
		"""
		pass


	def getFixedSpacingU(self) -> float:
		r"""
		Returns the spacing in local u direction if this is fixed. 
		Returns:
			float: The spacing
		"""
		pass


	def setFixedSpacingV(self, numberOfLines, spacing) -> IFLayoutGrid:
		r"""
		Sets a fixed spacing between the grid lines in local v direction. 
		Params:
			numberOfLines (int): Number of lines
			spacing (float): spacing
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getNumberOfLinesV(self) -> int:
		r"""
		Returns the number of lines in local v direction. 
		Returns:
			int: The number of lines
		"""
		pass


	def getFixedSpacingV(self) -> float:
		r"""
		Returns the spacing in local v direction if this is fixed. 
		Returns:
			float: The spacing
		"""
		pass


	def setCustomSpacingU(self, spacing) -> IFLayoutGrid:
		r"""
		Sets a custom spacing between the grid lines in local u direction. See also IFLayoutGrid.setAbsoluteU. 
		Params:
			spacing (array of floats): 
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getCustomSpacingU(self) -> list[float]:
		r"""
		Returns the spacing between the grid lines in local u direction if this is custom. 
		Returns:
			array of floats: 
		"""
		pass


	def setCustomSpacingV(self, spacing) -> IFLayoutGrid:
		r"""
		Sets a custom spacing between the grid lines in local v direction. See also IFLayoutGrid.setAbsoluteV. 
		Params:
			spacing (array of floats): 
		Returns:
			IFLayoutGrid: grid object
		"""
		pass


	def getCustomSpacingV(self) -> list[float]:
		r"""
		Returns the spacing between the grid lines in local v direction if this is custom. 
		Returns:
			array of floats: 
		"""
		pass


	def createCopy(self) -> IFLayoutGrid:
		r"""
		Creates a clone of this grid 
		Returns:
			IFLayoutGrid: the new grid that has been created
		"""
		pass


	def applyUnits(self, pUnits, convertToGiven) -> IFLayoutGrid:
		r"""
		Converts all numerical data inside the grid to represent a units conversion. If convertToGiven is TRUE, the data is converted from the units of the current model to the units specified by the first argument.  If convertToGiven is FALSE, the underlying data is converted from the given units, to the units of the current model. 
		Params:
			pUnits (IFUnitSet): 
			convertToGiven (bool): 
		Returns:
			IFLayoutGrid: 
		"""
		pass


class IFLayoutGridRectangular(IFLayoutGrid):
	"""
	Rectangular layout grid interface 
	"""

	def setSkewAngles(self, uAngleDegs, vAngleDegs) -> IFLayoutGridRectangular:
		r"""
		Sets the skew angles of the grid. 
		Params:
			uAngleDegs (float): angle from grid u towards grid v
			vAngleDegs (float): angle from grid v towards gridu
		Returns:
			IFLayoutGridRectangular: grid object
		"""
		pass


	def getSkewAngleU(self) -> float:
		r"""
		Returns the grid u skew angle, angle from grid u towards grid v 
		Returns:
			float: grid object
		"""
		pass


	def getSkewAngleV(self) -> float:
		r"""
		Returns the grid v skew angle, angle from grid v towards grid u 
		Returns:
			float: grid object
		"""
		pass


class IFLayoutGridCircular(IFLayoutGrid):
	"""
	Circular layout grid interface 
	"""

	def setMinRadius(self, radius) -> IFLayoutGridCircular:
		r"""
		Sets the minimum radius of the grid. 
		Params:
			radius (float): The minimum radious
		Returns:
			IFLayoutGridCircular: grid object
		"""
		pass


	def getMinRadius(self) -> float:
		r"""
		Returns the minimum radius of the grid. 
		Returns:
			float: The minimum radious
		"""
		pass


	def setCircumStraight(self, isStraight) -> IFLayoutGridCircular:
		r"""
		Sets the circumferential line type 
		Params:
			isStraight (bool): true for straight lines, false for arc lines
		Returns:
			IFLayoutGridCircular: grid object
		"""
		pass


	def getCircumStraight(self) -> bool:
		r"""
		Returns the circumferential line type, true for straight lines, false for arc lines 
		Returns:
			bool: The circumferential line type
		"""
		pass


class IFLayoutGridByOffset(IFLayoutGrid):
	"""
	Offset from reference path layout grid interface 
	"""

	def setReferencePath(self, refPath) -> IFLayoutGridByOffset:
		r"""
		Sets the reference path for the grid 
		Params:
			refPath (IFReferencePath): The name or ID of a referncepath, or a pointer to a IFReferencePath object.
		Returns:
			IFLayoutGridByOffset: grid object
		"""
		pass


	def defineFromLines(self, pLines) -> IFLayoutGridByOffset:
		r"""
		Define the grid from a connected set of lines 
		Params:
			pLines (IFObjectSet): set of lines
		Returns:
			IFLayoutGridByOffset: grid object
		"""
		pass


	def addStraightDefn(self, start, end) -> IFLayoutGridByOffset:
		r"""
		add straight line to the grid 
		Params:
			start (array of float): An array of 3 real numbers, representing 3d coordinates start of line
			end (array of float): An array of 3 real numbers, representing 3d coordinates end of line
		Returns:
			IFLayoutGridByOffset: grid object
		"""
		pass


	def addArcDefn(self, centre, hori, vert, sweptAngleDegs) -> IFLayoutGridByOffset:
		r"""
		add arc line to the grid 
		Params:
			centre (array of float): An array of 3 real numbers, representing 3d coordinates centre of arc
			hori (array of float): An array of 3 real numbers, representing 3d coordinates vector from centre to start
			vert (array of float): An array of 3 real numbers, representing 3d coordinates vector from centre in the +ve swept angle direction
			sweptAngleDegs (float): swept angle in degrees
		Returns:
			IFLayoutGridByOffset: grid object
		"""
		pass


	def addSplineDefn(self, nCoords, degree, isRational, knots, multiplicity, coords, weights) -> IFLayoutGridByOffset:
		r"""
		add spline line to the grid 
		Params:
			nCoords (int): number of coordinates, 2 if 2d, 3 if 3d
			degree (int): degree of the spline
			isRational (bool): true if rational, false if non-rational
			knots (float): knot array
			multiplicity (float): knot multiplicity array
			coords (array of float): An array of 3 real numbers, representing 3d coordinates control point coordinates
			weights (float): weights if spline is rational
		Returns:
			IFLayoutGridByOffset: grid object
		"""
		pass


class IFObjsToDrape(IFDatabaseMember):
	"""
	 
	"""

	def isSelected(self) -> bool:
		r"""
		Returns True if object is selected 
		Returns:
			bool: 
		"""
		pass


	def isVisible(self) -> bool:
		r"""
		Returns True if object is visible 
		Returns:
			bool: 
		"""
		pass


	def getTypeCode(self) -> int:
		r"""
		Returns the type code of this object, which will have the value 10, meaning background grid 
		Returns:
			int: 
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns objects ID IDs are program-generated and quite separate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def isMemberOfGroup(self, group) -> bool:
		r"""
		Returns TRUE if this object is a member of the given group 
		Params:
			group (IFGroup): The name or ID of a group, or a pointer to a IFGroup object.
		Returns:
			bool: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns object name 
		Returns:
			str: Name
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Sets object name 
		Params:
			newName (str): Name
		Returns:
			None: 
		"""
		pass


	def add(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFObjsToDrape:
		r"""
		Adds the specified objects to this set. see "IFObjectSet.add" 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFObjsToDrape: 
		"""
		pass


	def remove(self, arg1, arg2=None, arg3=None, arg4=None, arg5=None) -> IFObjsToDrape:
		r"""
		Removes the specified objects to this set. see "IFObjectSet.remove" 
		Params:
			arg1 (object): Can be an object type, object or array of objects. Can be an attribute type, element type or stress model. Subsequent arguments can provide specifc names or ids to further filter the first argument.
			arg2 (object, optional): 
			arg3 (object, optional): 
			arg4 (object, optional): 
			arg5 (object, optional): 
		Returns:
			IFObjsToDrape: 
		"""
		pass


class IFDatabase(IFGroup):
	"""
	Methods available on Database object 
	"""

	def setReadOnly(self, readOnly) -> None:
		r"""
		Sets a database as being read-only, preventing modification of data 
		Params:
			readOnly (bool): The new read-only status
		Returns:
			None: 
		"""
		pass


	def beginCommandBatch(self, label, isUndoable=None) -> None:
		r"""
		Scriptable dialogs should use this call, together with IFDatabase.closeCommandBatch(), to group together all commands generated by a single user click, for example the OK or Apply buttons. The effect of these commands is to batch the commands together for undo/redo purposes, to show a wait (hourglass) cursor and also to temporarily disable the tree views during processing.
  Modeller will automatically capture any definition commands between the call to begin and the call to end, and automatically reproduce them in the session file and undo mechanism. Note however that cosmetic commands such as rotations, selections, and colour changes, will not be captured. If this is necessary, you must use IFModeller.createUndoableEvent() to specify exactly which commands should be used 
		Params:
			label (str): label to be used for undo and redo buttons
			isUndoable (str, optional): "undoable", "not undoable", "ignored for undo", or "not redoable"
		Returns:
			None: 
		"""
		pass


	def getModificationDate(self, resFile=None) -> str:
		r"""
		Returns the date on which this database, or the specified results file, was last saved to disk. Note that opening a file and modifying it does not change this date until the file is actually saved back to disk. 
		Params:
			resFile (int, optional): default = 0
		Returns:
			str: the returned date
		"""
		pass


	def closeCommandBatch(self) -> None:
		r"""
		Closes the event started using IFDatabase.beginCommandBatch. See IFDatabase.beginCommandBatch for details 
		Returns:
			None: 
		"""
		pass


	def getDBFilename(self) -> str:
		r"""
		Returns fully qualified absolute pathname where this model is saved, e.g. "C:\temp\myModel.mdl" In almost all circumstances it is better to use the standard tokens "%ModelLocn%" and "%ModelName%" in place of calling this function. E.g. use IFView.savePicture("%ModelLocn%\%ModelName%.bmp") All of modeller's file handling functions expect and expand tokens of this form automatically 
		Returns:
			str: 
		"""
		pass


	def getDBFilenameNoExtension(self) -> str:
		r"""
		Returns Model filename without extension, e.g. if model is saved as "C:\temp\myModel.mdl", this function returns "C:\temp\myModel" Callers may safely add file extensions such as ".mrs" that are not related to any particular analysis. For files associated with analyses (e.g. dat files and mys files), see IFAnalysisBaseClass.getFilenameNoExtension. In almost all circumstances it is better to use the standard tokens "%ModelLocn%" and "%ModelName%" in place of calling this function. E.g. use IFView.savePicture("%ModelLocn%\%ModelName%.bmp") All of modeller's file handling functions expect and expand tokens of this form automatically 
		Returns:
			str: Model name (without extension)
		"""
		pass


	def setModelTitle(self, title) -> None:
		r"""
		Sets model title 
		Params:
			title (str): Title
		Returns:
			None: 
		"""
		pass


	def getModelTitle(self) -> str:
		r"""
		Returns model title 
		Returns:
			str: Title
		"""
		pass


	def getCreationVersion(self) -> int:
		r"""
		Returns model creation version as a six digit packed integer E.g. 140203 = 14.2-3 
		Returns:
			int: Title
		"""
		pass


	def getModificationVersion(self) -> int:
		r"""
		Returns model modification version as a six digit packed integer E.g. 140203 = 14.2-3 
		Returns:
			int: Title
		"""
		pass


	def setModelNotes(self, title) -> None:
		r"""
		Sets the multi-line notes for this model, as shown in model properties 
		Params:
			title (str): Title
		Returns:
			None: 
		"""
		pass


	def getModelNotes(self) -> str:
		r"""
		Returns the multi-line notes for this model, as shown in model properties 
		Returns:
			str: Title
		"""
		pass


	def setModelUnits(self, units) -> None:
		r"""
		Set the units for this database. This function should only be called before any data has been entered, and should only be called once per new database. Once a value is entered, its numeric value never changes, therefore if the units change, for example, from m to mm, any value already in the database would correspondingly change - e.g. from 1m to 1mm. 
		Params:
			units (name or object): Units to set current
		Returns:
			None: 
		"""
		pass


	def getModelUnits(self) -> IFUnitSet:
		r"""
		Return the units for this database. The returned object can then be queried for conversion factors, unit names, etc. 
		Returns:
			IFUnitSet: the current set of units
		"""
		pass


	def setTimescaleUnits(self, timeUnits) -> None:
		r"""
		Set the timescale units for this database. 
		Params:
			timeUnits (str): "Seconds", "Minutes", "Hours" or "Days"
		Returns:
			None: 
		"""
		pass


	def getTimescaleUnits(self) -> str:
		r"""
		Return the timescale units for this database. 
		Returns:
			str: "Seconds", "Minutes", "Hours" or "Days"
		"""
		pass


	def specifyAfterMeshScript(self, filename) -> None:
		r"""
		Specify the file location of the script to be run each time the model is meshed. Allows (for example) node/element renumbering according to a custom algorithm 
		Params:
			filename (str): name of script to be run
		Returns:
			None: 
		"""
		pass


	def setObjectIDs(self, type, nums) -> None:
		r"""
		Force the IDs of all objects of the given type Notes: You must supply an ID for every object of the given type. The IDs will be applied to objects in increasing numerical order (i.e. the first number will be given to the object that currently has the lowest numbered ID and so on). Conveniently, the function IFObjectSet.getObjects() will provide this order for you. 
		Params:
			type (str): type of objects to change
			nums (array): array of IDs
		Returns:
			None: 
		"""
		pass


	def getNextGroupName(self) -> str:
		r"""
		Returns a name suitable to be to a new group, i.e. a name guaranteed not to already be in use. The name will be created by starting with "New group", and then appending "(1)" "(2)" etc until one is found that is not already in use Warning: This function should not be called in a loop, as the implementation must search all existing names - thus the loop would become n-squared and very slow. 
		Returns:
			str: 
		"""
		pass


	def createNode(self, x, y, z, data=None) -> IFNode:
		r"""
		create a new node from the given global coordinates 
		Params:
			x (float): 
			y (float): 
			z (float): 
			data (IFElementDataObj, optional): 
		Returns:
			IFNode: 
		"""
		pass


	def createElement(self, lusasElementName, nodes, elementData=None, unused=None) -> IFElement:
		r"""
		Build a new element from an array of nodes or an array of nodes and an array of faces. If only the nodes are specified then they must be in element topology order, and new edges and faces will be created automatically were necessary. If the faces are specified then the nodes will be reordered to the correct element topology order. Optionally, an additional object may be specified to pass in more details about the element, including information specific to only certain kinds of element, such as beam end release information 
		Params:
			lusasElementName (str): element name e.g BMS3, HX20 etc
			nodes (array of IFNode objects): 
			elementData (IFElementDataObj, optional): 
			unused (array, optional): Not currently used
		Returns:
			IFElement: 
		"""
		pass


	def checkLineOpenLoopOrder(self, lineArray, reverseArray) -> bool:
		r"""
		Return true if lines define a continuous open loop 
		Params:
			lineArray (array of IFLine objects): On input, the lines can be given in any order. On output they will have been reordered such that they are in sequence. The input order will be disturbed as little as possible to achieve this.
			reverseArray (array of bool): This array is created and returned by the function. There will be one entry for each line. Each entry will be false if the corresponding line's direction is logically the same as the sense of the returned sequence, and will be true if they are opposite. E.g. Given two lines, 1, and 2, who share a common point, and where both line directions point towards the common point. If the returned array contains lines [1,2], the reverse array will contain [0,1] because line 1's direction is consistent with the direction [1,2]. However if the returned line array were to contain [2,1], the reverse array would contain [1,0] because now line 2's direction is consistent with the direction [2,1]
		Returns:
			bool: 
		"""
		pass


	def createReport(self, reportName, reportTitle, units, nSigFig, trailingZeros=None) -> IFReport:
		r"""
		Create an empty report 
		Params:
			reportName (str): report name
			reportTitle (str): report title
			units (name or object): Units in which to present the report
			nSigFig (int): number of significant figures
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			IFReport: 
		"""
		pass


	def deleteReport(self, report) -> None:
		r"""
		Deletes a report The report may be specified by name, by ID, or as an object 
		Params:
			report (IFReport): The name or ID of a report, or a pointer to a IFReport object.
		Returns:
			None: 
		"""
		pass


	def getReport(self, report) -> IFReport:
		r"""
		gets a report; the report may be specified by name or by ID 
		Params:
			report (IFReport): The name or ID of a report, or a pointer to a IFReport object.
		Returns:
			IFReport: 
		"""
		pass


	def createGroup(self, groupName, featureList=None) -> IFGroup:
		r"""
		Create a new group. All currently selected items will automatically be added to the group 
		Params:
			groupName (str): 
			featureList (array of IFDatabaseMember objects, optional): array of members for the new group
		Returns:
			IFGroup: 
		"""
		pass


	def createEmptyGroup(self, groupName, groupTypeStr=None) -> IFGroup:
		r"""
		Create a new empty group. 
		Params:
			groupName (str): 
			groupTypeStr (str, optional): defining the group type
		Returns:
			IFGroup: 
		"""
		pass


	def getLargestPointID(self) -> int:
		r"""
		Return the ID of the point whose ID is numerically highest of all points 
		Returns:
			int: 
		"""
		pass


	def getLargestLineID(self) -> int:
		r"""
		Return the ID of the line or combined line whose ID is numerically highest of all lines 
		Returns:
			int: 
		"""
		pass


	def getLargestSurfaceID(self) -> int:
		r"""
		Return the ID of the surface whose ID is numerically highest of all surfaces 
		Returns:
			int: 
		"""
		pass


	def getLargestVolumeID(self) -> int:
		r"""
		Return the ID of the volume whose ID is numerically highest of all volumes 
		Returns:
			int: 
		"""
		pass


	def getLargestNodeID(self) -> int:
		r"""
		Return the ID of the volume whose ID is numerically highest of all volumes 
		Returns:
			int: 
		"""
		pass


	def getLargestElementID(self) -> int:
		r"""
		Return the ID of the volume whose ID is numerically highest of all volumes 
		Returns:
			int: 
		"""
		pass


	def getLargestAttributeID(self, pAttr) -> int:
		r"""
		Return the ID of the attribute of the specified type whose ID is numerically highest of all attributes of that type 
		Params:
			pAttr (object): "Loading", "Support", "Material", etc
		Returns:
			int: 
		"""
		pass


	def getNextAvailableAttributeID(self, pAttr) -> int:
		r"""
		Return the next unique available ID of the attribute of the specified type 
		Params:
			pAttr (object): "Loading", "Support", "Material", etc
		Returns:
			int: 
		"""
		pass


	def getNextAttributeUniqueID(self, pAttr) -> int:
		r"""
		Return the next unique available ID of the attribute of the specified type 
		Params:
			pAttr (object): "Loading", "Support", "Material", etc
		Returns:
			int: 
		"""
		pass


	def getNextAvailableLoadcaseID(self) -> int:
		r"""
		Return the next unique available ID of a loadcase 
		Returns:
			int: 
		"""
		pass


	def getLargestLoadsetID(self) -> int:
		r"""
		Return the ID of the loadset whose ID is numerically highest of all loadsets 
		Returns:
			int: 
		"""
		pass


	def getSmallestLoadsetID(self) -> int:
		r"""
		Return the ID of the loadset whose ID is numerically lowest of all loadsets 
		Returns:
			int: 
		"""
		pass


	def countLoadsets(self, IDs, resFiles=None, eigens=None, harms=None) -> int:
		r"""
		Returns the number of loadsets matching the given criteria  
		Params:
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			int: The returned number
		"""
		pass


	def deleteLoadsets(self, IDs, resFiles=None, eigens=None, harms=None) -> None:
		r"""
		Deletes all the specified loadsets  
		Params:
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			None: 
		"""
		pass


	def getLoadsets(self, IDs, resFiles=None, eigens=None, harms=None) -> list[IFLoadset]:
		r"""
		Creates and returns an array of specified loadsets - may be loadcases, load curves, combinations, envelopes etc.  
		Params:
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			array of IFLoadset objects: The returned array
		"""
		pass


	def renumberLoadsets(self, startingValue) -> None:
		r"""
		Renumbers all the loadcases and load curves within this database to start with the given ID number. Analyses will be processed in alphabetical order, branches will be descended into 
		Params:
			startingValue (int): 
		Returns:
			None: 
		"""
		pass


	def renumberAttributes(self, startingValue, type=None) -> None:
		r"""
		Renumbers all the attributes within this database to start with the given ID number. If the type is not given, each type of attributes will be processed separately and independently 
		Params:
			startingValue (int): 
			type (str or int, optional): dataset type(e.g mesh/material, etc) or DatasetType enum
		Returns:
			None: 
		"""
		pass


	def renumberUtilities(self, startingValue, type=None) -> None:
		r"""
		Renumbers all the utilities within this database to start with the given ID number. If the type is not given, each type of utilities will be processed separately and independently 
		Params:
			startingValue (int): 
			type (str or int, optional): dataset type(e.g mesh/material, etc) or DatasetType enum
		Returns:
			None: 
		"""
		pass


	def renumberPostProcessingLoadsets(self, type, startingValue) -> None:
		r"""
		Renumbers the post-processing loadsets (combinations and envelopes) within this database to start with the given ID number. Note that the given ID is updated such that on return it is suitable for passing to another call to renumber another group or analysis 
		Params:
			type (str): "structural" "thermal".or "hygro"
			startingValue (int): first new ID to use, reset on exit
		Returns:
			None: 
		"""
		pass


	def associateSelnDownwards(self, isDownwards) -> None:
		r"""
		Set or clear the flag that controls whether or not to select LOFs when selecting. E.g. If true, selecting a surface also selects the lines and points that define it. If false, selecting the same surface selects only the surface 
		Params:
			isDownwards (bool): 
		Returns:
			None: 
		"""
		pass


	def resetChangeFlag(self) -> None:
		r"""
		Force the internal 'needs saving' flag to false. This can be useful in customisation scripts. Call this function after making changes (e.g. setting up initial attributes) such that if the user immediately exits, LUSAS will not ask if he wants to save his changes. Use with care! 
		Returns:
			None: 
		"""
		pass


	def specifyResultsUpdateScript(self, filename, entity, component=None) -> None:
		r"""
		Specify the file location of the script to be run for the given named component each time either the loadcase changes, or the set of elements used for results averaging changes. The entity may be given either as a name, or as an index previously registered using IFDatabase.addScriptedResultsEntity. If the entity is given as a string and does not already exist, it will be created. If the component does not already exist within the given entity, a new component is created within the given entity. 
		Params:
			filename (str): Name of script to be run
			entity (str or int): Name or index of results entity
			component (str, optional): Name of results component
		Returns:
			None: 
		"""
		pass


	def existsScriptedResults(self, entity, component=None) -> bool:
		r"""
		returns true if the given named component exists within the scripted results 
		Params:
			entity (str or int): Name or index of results entity
			component (str, optional): Name of results component
		Returns:
			bool: 
		"""
		pass


	def flushScriptedResults(self, entity=None, component=None) -> None:
		r"""
		Remove all numerical results previously stored using IFNode.setScriptedResults(), IFElement.setNodeScriptedResults or similar. It will subsequently be an error to request a value for such results.
 Additionally, this routine cleans up all memory used to cache results that have been accessed in the current script using IFNode.getResults(), or any of the corresponding IFElement routines. This can be useful when writing scripts for large models, which might otherwise run out of memory. By default, LUSAS Modeller caches any results that have been asked for until the end of the script, in case they are asked for again. Once this function has been called, a further attempt to access the same results again will simply cause a re-calculation of those results. It is an error to flush results that do not exist - check first with IFDatabase.existsScriptedResults Note that this routine does not delete the entity name or component names added with functions like IFDatabase.createScriptedResults. If you want to permanently remove an entity/component, use IFDatabase.deleteScriptedResults 
		Params:
			entity (str or int, optional): Name or index of results entity. If not specified, all user results will be flushed
			component (str, optional): Name of results component
		Returns:
			None: 
		"""
		pass


	def deleteScriptedResults(self, entity, component=None) -> None:
		r"""
		Permanently remove all knowledge of the given results from the program, including removing the name of the entity and component, as well as all numerical values. 
		Params:
			entity (str or IFPrimaryScriptedResultsComponentSet): Results entity
			component (str, optional): Name of results component. Not used if an object is given as the first argument
		Returns:
			None: 
		"""
		pass


	def initialiseScriptedResults(self, entity, component=None, packedDim=None, unitSet=None, denominatatorUnitSet=None) -> None:
		r"""
		Set a value of 0.0 for every node, element node, and element Gauss point. This is useful if you don't want to receive an error message when asking for scripted results that have not yet been set - instead the answer will be 0.0. The entity may be given either as a name, or as an index previously registered using IFDatabase.addScriptedResultsEntity. If the entity is given as a string and does not already exist, it will be created. If the component does not already exist within the given entity, a new component is created within the given entity. If you do not wish to initialise all values to 0.0, but still wish to create a component and assign its dimensionality and units, use IFDatabase.createScriptedResults instead 
		Params:
			entity (str or int): Name or index of results entity
			component (str, optional): Name of results component
			packedDim (int, optional): Dimensionality of the component
			unitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for this result - default is database units
			denominatatorUnitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for the optional extra 'per length/area' denominator - default is database units
		Returns:
			None: 
		"""
		pass


	def createScriptedResults(self, entity, component=None, packedDim=None, unitSet=None, denominatatorUnitSet=None) -> IFPrimaryScriptedResultsComponentSet:
		r"""
		As IFDatabase.initialiseScriptedResults but leaves the result for each node, element node and element Gauss point marked internally as 'not available'. This allows you, for example, to specify results only for a subset of elements (or nodes) and then draw contours - the contours will only appear where results have actually been specified. Note - the returned object will represent the "primary" results. These are the results that will be used if you do not specify an update script, and if you do not respond to updateScriptedResults() in a LUSAS module. However, if you do specify an update script, or do respond to updateScriptedResults() then a different, temporary, IFScriptedResultsCallbackComponent object will be created specially for the purpose and you must use that temporary object in preference to the primary object. In this mode of operation, the primary object is only used for registration / configuration purposes. 
		Params:
			entity (str or int): Name or index of results entity
			component (str, optional): Name of results component
			packedDim (int, optional): Dimensionality of the component
			unitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for this result - default is database units
			denominatatorUnitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for the optional extra 'per length/area' denominator - default is database units
		Returns:
			IFPrimaryScriptedResultsComponentSet: object which will hold results
		"""
		pass


	def setScriptedResultsEntityVisible(self, entity, visible) -> None:
		r"""
		Allows you to state whether or not a scripted results entity is invisible in the user interface Visible entities respect the visibility state of each component within them. Invisible entities ignore the visibility state of all components within them (they are all also invisible) 
		Params:
			entity (str or int): Name or index of results entity
			visible (bool): default true.
		Returns:
			None: 
		"""
		pass


	def setScriptedResultsEntity(self, name, index=None) -> None:
		r"""
		There is a special results entity (by default called "Scripted") which allows the calculation and storage of arbitrary results for later plotting. Without an optional argument (or if 0 is given), this function changes the name of that entity to the name given. That name then appears in the properties dialog of results layers such as contours. By default there is only one such entity. However, by calling IFDatabase.addScriptedResultsEntity, you can add as many as you need and use this function to subsequently change their names too. Note that the results will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults. 
		Params:
			name (str): 
			index (int, optional): default 0. If non-zero, sets up additional scripted results entities
		Returns:
			None: 
		"""
		pass


	def addScriptedResultsEntity(self, name) -> int:
		r"""
		There is a special results entity (by default called "Scripted") which allows the calculation and storage of arbitrary results for later plotting. This function allows you to add additional names for the same purpose. The given name then appears in the properties dialog of results layers such as contours. The returned index uniquely identifies the new entity to the system, such that you can modify the name at any future stage by calling IFDatabase.setScriptedResultsEntity. You can also use this index (if you wish) in place of the entity name in many other functions. It is not an error to repeatedly call this function with the same entity name - second and subsequent calls will simply retrieve the index of the entity which is already present. Note that the results will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults. 
		Params:
			name (str): Name to add
		Returns:
			int: Index which may be used to subsequently change the name
		"""
		pass


	def addUserDefinedResultsEntity(self, name, mdlr) -> int:
		r"""
		User defined results are normally added to one of Modeller's standard entities (like Displacement or Stress). However this function allows you to create your own named entity, into which you can add user defined results 
		Params:
			name (str): Name to add
			mdlr (str): Stress model (e.g. "Thick Beam" or "Solid"). Use of "All" indicates that this entity is nodal, and not tied to one particular stress model
		Returns:
			int: Index which may be used to subsequently change the name
		"""
		pass


	def getResultsComponentSet(self, entity, component, locn, context=None) -> IFResultsComponentSet:
		r"""
		Return object which will hold results values of specified type. All options (loadcase, transformation, active fibre, active composite layer, etc) will be taken from the given context. If a context is not given, the current view will be used for all those options and settings instead. Note that for efficiency the requested results are cached and will not be removed from the system (and so will potentially use a large amount of memory) until explicitly removed with a call to IFDatabase.flushScriptedResults. Changes to the context, after the call to IFDatabase.getResultsComponentSet, are IGNORED. Thus, the results cached within the IFResultsComponentSet are orphaned and isolated from the view, once the object has been created. If you need to respect such changes, you should create a new IFResultsComponentSet 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			locn (str): "nodal", "elementNodal", "Gauss"/"Internal"
			context (IFResultsContext, optional): If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
		Returns:
			IFResultsComponentSet: object holding results values
		"""
		pass


	def startUsingScriptedResults(self) -> None:
		r"""
		Register an on-going interest in LPI results, e.g. from IFNode.getResults. This allows the program to cache results between calls for faster operation. Note that this is only necessary for window-less LUSAS extension modules or .NET dialogs that are not derived from LusasModuleDialog. By default, non-interactive VBScript files cache results for the lifetime of the script. TFM dialogs and LUSAS Module .NET dialogs both cache results for all the time that the dialog is displayed. Note that it is a very serious error to call this function without subsequently calling IFDatabase.stopUsingScriptedResults 
		Returns:
			None: 
		"""
		pass


	def stopUsingScriptedResults(self) -> None:
		r"""
		clear the cache previously created by IFDatabase.startUsingScriptedResults 
		Returns:
			None: 
		"""
		pass


	def openResults(self, filename, analysis=None, useActualFile=None, iArch=None, reportError=None, setActiveLoadcase=None) -> None:
		r"""
		Open results file on top of current model 
		Params:
			filename (str): Results filename
			analysis (str, optional): Name of analysis to connect results to (if not given, this is assumed from the filename)
			useActualFile (bool, optional): Only appropriate for the first mys file loaded on top of a model, for subsequent files the flag is ignored. The default is FALSE, which is the right value for most circumstances. If FALSE, LUSAS Modeller will make a temporary copy of the results file, and interact with that. This ensures that the copy on disk is never modified, and therefore can not be corrupted. If TRUE, the actual file will be used which has an efficiency benefit. However, Modeller can only use the actual file if it is the first file opened, and if the file has the same version number as this copy of modeller.
			iArch (int, optional): The default 0 means 'auto-detect'. 32 means '32 bit file'. 64 means '64 bit file'. No other values are currently supported
			reportError (bool, optional): Default true. Report an error if the file does not exist or cannot be loaded. Can be set to false if you just want to try to load every possible file, and don't care which ones are not valid
			setActiveLoadcase (bool, optional): Default true. Change the active loadcase to be the first one in this file? If false, the active loadcase will be unchanged
		Returns:
			None: 
		"""
		pass


	def solveAllAnalyses(self, ignoreModified=None) -> int:
		r"""
		Tabulate and solve all analyses that need it, in the order that LUSAS believes best. If you set ignoreModified to be true, then LUSAS's internal knowledge is ignored, and all analyses will be solved whether LUSAS thinks it necessary or not. Returns 0 if all analyses solved successfully. If one or more analyses fail to solve, a failure code from LUSAS solver will be returned from the first to fail. 
		Params:
			ignoreModified (bool, optional): default false. Can be set true to ignore the modification state of each analysis
		Returns:
			int: 
		"""
		pass


	def openAllResults(self, scanOutputFiles=None, skipOutOfDate=None) -> None:
		r"""
		Open all results for all analyses Optionally (default true) skip any results that LUSAS considers to be out of date 
		Params:
			scanOutputFiles (bool, optional): default true. Can be set false to skip parsing output files and repeating errors and warnings into the text output window
			skipOutOfDate (bool, optional): default true. Can be set false to force LUSAS to load results files it believes to be out of date
		Returns:
			None: 
		"""
		pass


	def deleteAllSolverFiles(self, datFileToo=None) -> None:
		r"""
		Delete all of the files created by solver for all analyses Typically, this is dat, mys, out, log, his, dtf and rst files 
		Params:
			datFileToo (bool, optional): default true. Can be set false to skip deleting the dat file (it is often desirable to keep this one file)
		Returns:
			None: 
		"""
		pass


	def updateResultsFile(self, filename, doBackup=None) -> None:
		r"""
		Update results file with given name to the current version of the software, optionally making a backup. Note - this command will first close any results files that may already be open 
		Params:
			filename (str): Results filename
			doBackup (bool, optional): default TRUE
		Returns:
			None: 
		"""
		pass


	def closeResults(self, filename) -> None:
		r"""
		Close results file 
		Params:
			filename (str): Results filename
		Returns:
			None: 
		"""
		pass


	def closeAllResults(self) -> None:
		r"""
		Close all results files 
		Returns:
			None: 
		"""
		pass


	def resetResultsFileIDs(self) -> None:
		r"""
		flush the internal map of filenames and results file IDs. This should be followed to calls to IFDatabase.setResultsFileID. The map is used in the definition of combinations and envelopes 
		Returns:
			None: 
		"""
		pass


	def removeFromPostProc(self, ID, resFile=None, eigen=None, harm=None) -> None:
		r"""
		remove all traces of the given loadset from other post-processing loadsets such as envelopes and combinations. Useful to call when deleting a loadset. 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name. // -1 means 'all loadcases'
			resFile (int, optional): default = 0   //
			eigen (int, optional): default = -1  // -1 means 'not an eigenvalue'
			harm (int, optional): default = -1  // -1 means 'not a harmonic'
		Returns:
			None: 
		"""
		pass


	def removeFromPostProcBatch(self, IDs, resFiles=None, eigens=None, harms=None) -> None:
		r"""
		remove all traces of the given loadset from other post-processing loadsets such as envelopes and combinations. Useful to call when deleting an analysis or something else with loats of loadcases in it. 
		Params:
			IDs (object): array of loadcase ids
			resFiles (object, optional): array of result file ids
			eigens (object, optional): array of eigenvalues ids
			harms (object, optional): array of harmonic ids
		Returns:
			None: 
		"""
		pass


	def setResultsFileID(self, analysis, filename, id) -> None:
		r"""
		set the internal map between the given filename and results file ID. You should generally call IFDatabase.resetResultsFileIDs before calling here. The map is used in the definition of combinations and envelopes 
		Params:
			analysis (str): Analysis name
			filename (str): Results filename
			id (int): Results file ID
		Returns:
			None: 
		"""
		pass


	def setSaveSafety(self, safe) -> None:
		r"""
		 
		Params:
			safe (bool): 
		Returns:
			None: 
		"""
		pass


	def setVerticalDir(self, axisName) -> None:
		r"""
		Sets vertical axis 
		Params:
			axisName (str): Axis name "X", "Y" or "Z"
		Returns:
			None: 
		"""
		pass


	def getVerticalDir(self) -> str:
		r"""
		Returns vertical axis 
		Returns:
			str: Axis name "X", "Y" or "Z"
		"""
		pass


	def sliceVertical(self, x, createAnnot=None) -> None:
		r"""
		Cut a slice in a solid model. The plane of the slice will be vertical and perpendicular to the plane of the screen. 
		Params:
			x (float): Given in rotated model units, this is the location of the plane as a distance from the vertical origin
			createAnnot (bool, optional): create annotation to feedback the location of the slice?
		Returns:
			None: 
		"""
		pass


	def sliceHorizontal(self, y, createAnnot=None) -> None:
		r"""
		Cut a slice in a solid model. The plane of the slice will be horizontal and perpendicular to the plane of the screen. 
		Params:
			y (float): Given in rotated model units, this is the location of the plane as a distance from the horizontal origin
			createAnnot (bool, optional): create annotation to feedback the location of the slice?
		Returns:
			None: 
		"""
		pass


	def sliceAtObject(self, pObj) -> None:
		r"""
		Cut a slice in a solid model. The plane of the slice will be taken from the given object, which must either be a planar surface or a planar polygon annotation 
		Params:
			pObj (IFDatabaseMember): 
		Returns:
			None: 
		"""
		pass


	def addDeformations(self, factor) -> None:
		r"""
		Add the nodal deformations from the currently active loadcase to all nodes. A factor can be applied to the deformations (typically -1). Note that this will close any and all open results, and will invalidate any results previously calculated for this model (as the model has been changed) 
		Params:
			factor (float): factor to be applied
		Returns:
			None: 
		"""
		pass


	def createLoadcase(self, name, analysisName=None, forceID=None, keepAnalysisAssignments=None) -> IFLoadcase:
		r"""
		Creates loadcase 
		Params:
			name (str): Loadcase name
			analysisName (str, optional): Name of analysis in which to create the new loadcase
			forceID (int, optional): The desired ID of the new loadcase.
			keepAnalysisAssignments (bool, optional): if T keep first loadcase analysis assigmments if loadcase exists
		Returns:
			IFLoadcase: 
		"""
		pass


	def createEnvelope(self, name, analysisType=None, forceIDMax=None, forceIDMin=None) -> IFEnvelope:
		r"""
		Creates envelope 
		Params:
			name (str): Enevlope name
			analysisType (str, optional): "structural" "thermal".or "hygro"
			forceIDMax (int, optional): The desired ID of the max part of the new loadcase.
			forceIDMin (int, optional): The desired ID of the min part of the new loadcase.
		Returns:
			IFEnvelope: 
		"""
		pass


	def createCombinationBasic(self, name, analysisType=None, forceID=None) -> IFBasicCombination:
		r"""
		Creates basic combination 
		Params:
			name (str): Combination name
			analysisType (str, optional): "structural" "thermal".or "hygro"
			forceID (int, optional): The desired ID of the new loadcase.
		Returns:
			IFBasicCombination: 
		"""
		pass


	def createCombinationSmart(self, name, analysisType=None, forceIDMax=None, forceIDMin=None) -> IFSmartCombination:
		r"""
		Creates smart combination 
		Params:
			name (str): Combination name
			analysisType (str, optional): "structural" "thermal".or "hygro"
			forceIDMax (int, optional): The desired ID of the max part of the new loadcase.
			forceIDMin (int, optional): The desired ID of the min part of the new loadcase.
		Returns:
			IFSmartCombination: 
		"""
		pass


	def createFatigue(self, name, forceID=None) -> IFFatigue:
		r"""
		Creates fatigue loadset 
		Params:
			name (str): Loadset name
			forceID (int, optional): The desired ID of the new loadset.
		Returns:
			IFFatigue: 
		"""
		pass


	def createIMD(self, name, forceID=None) -> IFIMD:
		r"""
		Creates IMD loadset 
		Params:
			name (str): Loadset name
			forceID (int, optional): The desired ID of the new loadset.
		Returns:
			IFIMD: 
		"""
		pass


	def createLoadsetResultsContainer(self, name, analysisType=None, forceID=None) -> IFScriptedLoadsetResultsContainer:
		r"""
		Creates a generic results container loadset 
		Params:
			name (str): Loadset name
			analysisType (str, optional): "structural" "thermal".or "hygro"
			forceID (int, optional): The desired ID of the new loadset.
		Returns:
			IFScriptedLoadsetResultsContainer: 
		"""
		pass


	def createRCDesignResultsContainer(self, name, analysisType=None, forceID=None) -> IFRCDesignResultsContainer:
		r"""
		Creates a results container loadset for RC design 
		Params:
			name (str): Loadset name
			analysisType (str, optional): "structural" "thermal".or "hygro"
			forceID (int, optional): The desired ID of the new loadset.
		Returns:
			IFRCDesignResultsContainer: 
		"""
		pass


	def createSlabDesignResultsContainer(self, name, analysisType=None, forceID=None) -> IFSlabDesignResultsContainer:
		r"""
		Creates a results container loadset for slab design 
		Params:
			name (str): Loadset name
			analysisType (str, optional): "structural" "thermal".or "hygro"
			forceID (int, optional): The desired ID of the new loadset.
		Returns:
			IFSlabDesignResultsContainer: 
		"""
		pass


	def createLoadsetTargetValues(self, name, forceID=None) -> IFLoadsetTargetValues:
		r"""
		Creates target value loadset 
		Params:
			name (str): Loadset name
			forceID (int, optional): The desired ID of the new loadcase.
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def createAnalysisCableTuning(self, name, forceID=None) -> IFCableTuningAnalysis:
		r"""
		Creates cable tuning analysis 
		Params:
			name (str): Analysis name
			forceID (int, optional): The desired ID of the analysis results loadcase.
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def createAnalysisStaticMovingLoad(self, name) -> IFStaticMovingLoadAnalysis:
		r"""
		Creates static moving load analysis 
		Params:
			name (str): Analysis name
		Returns:
			IFStaticMovingLoadAnalysis: 
		"""
		pass


	def createAnalysisBranchStaticMovingLoad(self, loadcase, name, linear) -> IFStaticMovingLoadAnalysis:
		r"""
		Creates a static moving load analysis as a branch within the given stage 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			name (str): Cable tuning analysis name
			linear (bool): true for a linear branch, false to continue the parent analysis (NL / transient)
		Returns:
			IFStaticMovingLoadAnalysis: 
		"""
		pass


	def createAnalysisPedestrianMovingLoad(self, name) -> IFPedestrianMovingLoadAnalysis:
		r"""
		Creates pedestrian moving load analysis 
		Params:
			name (str): Analysis name
		Returns:
			IFPedestrianMovingLoadAnalysis: 
		"""
		pass


	def createAnalysisBranchPedestrianMovingLoad(self, loadcase, name) -> IFPedestrianMovingLoadAnalysis:
		r"""
		Creates a pedestrian moving loadanalysis as a branch within the given stage 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			name (str): Cable tuning analysis name
		Returns:
			IFPedestrianMovingLoadAnalysis: 
		"""
		pass


	def createAnalysisBranchCableTuning(self, loadcase, name, forceID=None) -> IFCableTuningAnalysis:
		r"""
		Creates a cable tuning analysis as a branch within the given stage 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			name (str): Cable tuning analysis name
			forceID (int, optional): The desired ID of the analysis results loadcase.
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def createCableTuningLoadcase(self, name, analysisName, forceID=None) -> IFCableTuningLoadcase:
		r"""
		Creates cable tuning loadcase 
		Params:
			name (str): Cable tuning loadcase name
			analysisName (str): 
			forceID (int, optional): The ID of the cable tuning loadcase.
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def createLoadCurveStandard(self, name, curveType, analysisName=None, forceID=None) -> IFLoadCurve:
		r"""
		Creates load curve based on standard shape. Call IFLoadCurve.setStandardLoadCurve() on the returned object to complete its initialisation 
		Params:
			name (str): Load curve name
			curveType (str): Curve type "Cosine", "Sine", "Square"
			analysisName (str, optional): Name of analysis in which to create the new load curve
			forceID (int, optional): The desired ID of the new loadcase
		Returns:
			IFLoadCurve: 
		"""
		pass


	def createLoadCurveVariation(self, name, activationValue, terminationValue, incrementValue, assignmentFactor, variation, analysisName=None, forceID=None) -> IFLoadCurve:
		r"""
		Creates load curve based on variation 
		Params:
			name (str): Load curve name
			activationValue (float): Activation time/increment
			terminationValue (float): Termination time/increment
			incrementValue (float): Segment size
			assignmentFactor (float): Amplitude factor
			variation (IFVariationAttr): The name or ID of a variation, or a pointer to a IFVariationAttr object.
			analysisName (str, optional): Name of analysis in which to create the new load curve
			forceID (int, optional): The desired ID of the new loadcase
		Returns:
			IFLoadCurve: 
		"""
		pass


	def createLoadCurveTable(self, name, activationValue, assignmentFactor, analysisName=None, forceID=None) -> IFLoadCurve:
		r"""
		Creates user defined load curve with tabular input. Use addTableRow for each data pair in curve. 
		Params:
			name (str): Load curve name
			activationValue (float): Activation time/increment
			assignmentFactor (float): Amplitude factor
			analysisName (str, optional): Name of analysis in which to create the new load curve
			forceID (int, optional): The desired ID of the new loadcase
		Returns:
			IFLoadCurve: 
		"""
		pass


	def countResultsFiles(self) -> int:
		r"""
		Returns number of currently open results files 
		Returns:
			int: Number of currently open results files
		"""
		pass


	def getResultsFilename(self, i) -> str:
		r"""
		Returns the name of the results file indicated 
		Params:
			i (int): 0..IFDatabase.countResultsFiles()-1
		Returns:
			str: file name
		"""
		pass


	def getResultsFileID(self, i) -> int:
		r"""
		Returns the ID of the results file indicated The ID is not necessarily the same as the index passed in 
		Params:
			i (int): 0..IFDatabase.countResultsFiles()-1
		Returns:
			int: file ID
		"""
		pass


	def existsLoadset(self, ID, resFile=None, eigen=None, harm=None) -> bool:
		r"""
		Returns true if a loadset exists with the given specification  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			bool: 
		"""
		pass


	def getLoadset(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Returns the loadset with the given specification. It is an error for the loadset to not be found  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


	def deleteLoadset(self, ID, resFile=None, eigen=None, harm=None) -> None:
		r"""
		Delete the specified loadset. Note that it is not possible to delete results loadcases (close the file instead) or the last remaining pre-processing loadcase.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			None: 
		"""
		pass


	def setAutoGravity(self, isGravity, analysis=None) -> None:
		r"""
		change the state of automatic gravity for all structural loadcases to that given. Note that this function will automatically skip any loadcases that inherit gravity from a previous loadcase by way of automatic incrementation. If an analysis is given, only that analysis will receive the change. 
		Params:
			isGravity (bool): on or off
			analysis (IFAnalysis, optional): The name of a analysis, or a pointer to a IFAnalysis object.
		Returns:
			None: 
		"""
		pass


	def meshSelected(self) -> IFDatabase:
		r"""
		Forces a remesh of only the selected items when Mesh lock is on. 
		Returns:
			IFDatabase: 
		"""
		pass


	def updateMesh(self, data=None) -> IFDatabase:
		r"""
		Invokes the mesher to apply mesh assignments to geometry. Will only process those geometry and assignments that have changed since the last call to updateMesh. To force a complete remesh, call IFDatabase.resetMesh first 
		Params:
			data (IFGeometryData, optional): 
		Returns:
			IFDatabase: 
		"""
		pass


	def resetMesh(self) -> IFDatabase:
		r"""
		Removes all elements and nodes created as a result of previous meshing operations. To cause a complete remesh, call IFDatabase.updateMesh after calling resetMesh 
		Returns:
			IFDatabase: 
		"""
		pass


	def isMeshLocked(self) -> bool:
		r"""
		Returns TRUE if a previous call to IFDatabase.setMeshLock is in effect, or if any results files are currently open (which also prevents automatic mesh updates). FALSE otherwise. 
		Returns:
			bool: 
		"""
		pass


	def setMeshLock(self, locked) -> IFDatabase:
		r"""
		Call with locked=TRUE to suspend meshing updates until further notice. This is useful if several changes are to be made to the mesh, as it prevents LUSAS Modeller from remeshing each change individually. By default the mesh is not locked, and any change in geometry, mesh definition or mesh assignment will be immediately processed. Turning mesh lock off again automatically updates the mesh. 
		Params:
			locked (bool): 
		Returns:
			IFDatabase: 
		"""
		pass


	def setPen(self, index, r, g, b, style, width) -> None:
		r"""
		Set pen attributes for a specified pen in the pen library 
		Params:
			index (int): Colour index
			r (int): Red (0-255)
			g (int): Green (0-255)
			b (int): Blue (0-255)
			style (int): Style
			width (int): Width of line (pixels)
		Returns:
			None: 
		"""
		pass


	def getPen(self, index, r, g, b, style, width) -> None:
		r"""
		Get pen attributes for a specified pen in the pen library 
		Params:
			index (int): Colour index
			r (int): Red (0-255)
			g (int): Green (0-255)
			b (int): Blue (0-255)
			style (int): Style
			width (int): Width of line (pixels)
		Returns:
			None: 
		"""
		pass


	def countPens(self) -> int:
		r"""
		return the number of pens in the pen library 
		Returns:
			int: Number of pens
		"""
		pass


	def changeFeaturePen(self, type, pen) -> None:
		r"""
		Changes the pen for all existing features of the given type 
		Params:
			type (str or int): "point", "line", "surface", or "volume", or the equivalent integer code
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setDefaultPen(self, type, pen) -> None:
		r"""
		Changes the pen for new features (not yet created) of the given type 
		Params:
			type (str or int): "point", "line", "combined line", "surface", or "volume", or the equivalent integer code
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def createBackgroundGrid(self, nameStr, pointsList) -> IFBackgroundGrid:
		r"""
		Creates a background grid for use in automatic meshing 
		Params:
			nameStr (str): 
			pointsList (array of IFPoint objects): Array of points
		Returns:
			IFBackgroundGrid: 
		"""
		pass


	def createBackgroundGridTopology(self, nameStr, pointsList, elementTopology) -> IFBackgroundGrid:
		r"""
		Creates background grid topology for automatic meshing 
		Params:
			nameStr (str): 
			pointsList (array of IFPoint objects): Array of point objects
			elementTopology (array of ints): Matrix defining the topology of the grid
		Returns:
			IFBackgroundGrid: 
		"""
		pass


	def setActiveLocalCoord(self, localCoords) -> None:
		r"""
		Sets active the given local coordinate set. As a special case, calling this function with an empty string sets active the default global cartesian set 
		Params:
			localCoords (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
		Returns:
			None: 
		"""
		pass


	def getActiveLocalCoord(self) -> IFLocalCoord:
		r"""
		Returns the currently active local coordinate set. A valid object is always returned, even if the currently active set is the default global cartesian set 
		Returns:
			IFLocalCoord: 
		"""
		pass


	def isGlobalCoordSystem(self) -> bool:
		r"""
		Returns true if the currently active local coordinate set is the default global cartesian set, false if any attribute has been set active. (Note, this function will return false even if you create and set active an attribute which is numerically identical to the global cartesian set) 
		Returns:
			bool: 
		"""
		pass


	def deleteAllNoGroups(self) -> int:
		r"""
		 
		Returns:
			int: 
		"""
		pass


	def createAnnotationLine(self, name=None) -> IFLineAnnotation:
		r"""
		Creates annotation line 
		Params:
			name (str, optional): user defined name for the annotation
		Returns:
			IFLineAnnotation: 
		"""
		pass


	def createAnnotationPolygon(self, name=None) -> IFPolygonAnnotation:
		r"""
		Creates annotation polygon 
		Params:
			name (str, optional): user defined name for the annotation
		Returns:
			IFPolygonAnnotation: 
		"""
		pass


	def createAnnotationText(self, name=None) -> IFTextAnnotation:
		r"""
		Creates annotation text 
		Params:
			name (str, optional): user defined name for the annotation
		Returns:
			IFTextAnnotation: 
		"""
		pass


	def createAnnotationArrow(self, name=None) -> IFArrowAnnotation:
		r"""
		Creates annotation arrow 
		Params:
			name (str, optional): user defined name for the annotation
		Returns:
			IFArrowAnnotation: 
		"""
		pass


	def createAnnotationBitmap(self, name=None) -> IFBitmapAnnotation:
		r"""
		Creates annotation bitmap 
		Params:
			name (str, optional): user defined name for the annotation
		Returns:
			IFBitmapAnnotation: 
		"""
		pass


	def createAnnotationSymbol(self, name=None) -> IFSymbolAnnotation:
		r"""
		Creates annotation symbol 
		Params:
			name (str, optional): user defined name for the annotation
		Returns:
			IFSymbolAnnotation: 
		"""
		pass


	def createAnnotationKey(self, name=None) -> IFKeyAnnotation:
		r"""
		Creates a new empty annotation key 
		Params:
			name (str, optional): user defined name for the annotation
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def exportSolver(self, data, options=None) -> int:
		r"""
		Tabulates the model to the given file in LUSAS solver format 
		Params:
			data (IFTabulateDataObj or str): data object for the solver datafile tabulation, or just the filename
			options (IFLusasRunOptionsObj, optional): 
		Returns:
			int: return code, non-zero indicates error
		"""
		pass


	def exportFile(self, data) -> int:
		r"""
		Exports the model in the format defined by the data object 
		Params:
			data (IFExportDataObj or str): data object for the export, or just the filename
		Returns:
			int: return code, non-zero indicates error
		"""
		pass


	def importFile(self, data, type=None) -> int:
		r"""
		Imports data from file 
		Params:
			data (IFImportDataObj or str): data object for the export, or just the filename
			type (str, optional): "IGS", "DXF", "CMD" etc. If not specified, type assumed from options object or filename extension
		Returns:
			int: 
		"""
		pass


	def options(self) -> IFOptions:
		r"""
		 
		Synonyms:
			getOptions
		Returns:
			IFOptions: 
		"""
		pass


	def getOptions(self) -> IFOptions:
		r"""
		 
		Returns:
			IFOptions: 
		"""
		pass


	def facetLineDensityFactor(self, factor) -> IFDatabase:
		r"""
		Sets facet density on line 
		Params:
			factor (float): 
		Returns:
			IFDatabase: 
		"""
		pass


	def facetSurfaceDensityFactor(self, factor) -> IFDatabase:
		r"""
		Sets facet density on surface 
		Params:
			factor (float): 
		Returns:
			IFDatabase: 
		"""
		pass


	def getNodeFromPosition(self, position) -> IFNode:
		r"""
		 
		Params:
			position (int): 
		Returns:
			IFNode: 
		"""
		pass


	def getAnalysisUI(self) -> str:
		r"""
		Fetches which of the three user interface modes (Structural, Thermal, or Coupled) the model is currently using. This will be based on the presence and absence of structural and thermal analyses within the model (coupled means both are present) 
		Returns:
			str: Returned analysis type. "Structural", "Thermal", or "Coupled"
		"""
		pass


	def createAnalysisBranch(self, loadcase, branchName=None, createInitialLoadcase=None, type=None) -> IFAnalysis:
		r"""
		Create an empty branch, within a stage, ready to receive loadcases 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			branchName (str, optional): Branch name; if empty or not given, a default name will be generated
			createInitialLoadcase (bool, optional): True (default) to create an initial loadcase. False to create an empty (and thus temporarily invalid) analysis
			type (str, optional): "general" (default), "linear", "eigenvalue", "phi-c", "staged"
		Returns:
			IFAnalysis: Created analysis
		"""
		pass


	def createAnalysisStructural(self, analysisName=None, createInitialLoadcase=None, type=None) -> IFAnalysis:
		r"""
		Create new structural analysis 
		Params:
			analysisName (str, optional): Analysis name; if empty or not given, a default name will be generated
			createInitialLoadcase (bool, optional): True (default) to create an initial loadcase. False to create an empty (and thus temporarily invalid) analysis
			type (str, optional): "general" (default), "linear", "eigenvalue", "phi-c", "staged"
		Returns:
			IFAnalysis: Created analysis
		"""
		pass


	def createAnalysisThermal(self, analysisName=None, createInitialLoadcase=None, type=None) -> IFAnalysis:
		r"""
		Create new thermal analysis 
		Params:
			analysisName (str, optional): Analysis name; if empty or not given, a default name will be generated
			createInitialLoadcase (bool, optional): True (default) to create an initial loadcase. False to create an empty (and thus temporarily invalid) analysis
			type (str, optional): "general" (default), "linear", "eigenvalue", "phi-c", "staged"
		Returns:
			IFAnalysis: Created analysis
		"""
		pass


	def createAnalysisHygro(self, analysisName=None, createInitialLoadcase=None, type=None) -> IFAnalysis:
		r"""
		Create new hygro analysis 
		Params:
			analysisName (str, optional): Analysis name; if empty or not given, a default name will be generated
			createInitialLoadcase (bool, optional): True (default) to create an initial loadcase. False to create an empty (and thus temporarily invalid) analysis
			type (str, optional): "general" (default), "linear", "eigenvalue", "phi-c", "staged"
		Returns:
			IFAnalysis: Created analysis
		"""
		pass


	def getAnalysis(self, name) -> IFAnalysisBaseClass:
		r"""
		Return analysis 
		Params:
			name (str): Analysis name to search for
		Returns:
			IFAnalysisBaseClass: Returned analysis
		"""
		pass


	def getAnalyses(self, includeBranches=None) -> list:
		r"""
		Return an array of all currently defined analyses. The items in the array will all be of type IFAnalysisBaseClass 
		Params:
			includeBranches (bool, optional): True to include branches within the array. False (default) to include only top level analyses
		Returns:
			array of analyses: Returned array
		"""
		pass


	def existsAnalysis(self, name) -> bool:
		r"""
		Return true if an analysis with this name exists 
		Params:
			name (str): Analysis name to search for
		Returns:
			bool: 
		"""
		pass


	def deleteAnalysis(self, analysis) -> None:
		r"""
		Deletes the given analysis The analysis may be specified by name or as an object 
		Params:
			analysis (IFAnalysis): The name of a analysis, or a pointer to a IFAnalysis object. Analysis
		Returns:
			None: 
		"""
		pass


	def existsSavedArray(self, name) -> bool:
		r"""
		Returns true if an array has previously been saved with the given name using IFDatabase.saveStrArray or IFDatabase.saveIntArray or IFDatabase.saveDblArray, false otherwise 
		Params:
			name (str): 
		Returns:
			bool: 
		"""
		pass


	def deleteSavedArray(self, name) -> None:
		r"""
		Deletes a named array previously saved with IFDatabase.saveStrArray or IFDatabase.saveIntArray or IFDatabase.saveDblArray Data of all types is permanently deleted. If you wish to remove data of only one type, call (for example) IFDatabase.saveStrArray with a zero-sized array. 
		Params:
			name (str): unique name for the array
		Returns:
			None: 
		"""
		pass


	def createAnalysisDirectMethodInf(self, analysisName=None) -> IFDirectMethodInfAnalysis:
		r"""
		Create new Direct Method Influence Analysis 
		Params:
			analysisName (str, optional): Analysis name; if empty or not given, a default name will be generated
		Returns:
			IFDirectMethodInfAnalysis: Return created direct method influence analysis
		"""
		pass


	def createAnalysisBranchDirectMethodInf(self, loadcase, analysisName=None) -> IFDirectMethodInfAnalysis:
		r"""
		Create new Direct Method Influence Analysis as a branch within the given stage 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			analysisName (str, optional): Analysis name; if empty or not given, a default name will be generated
		Returns:
			IFDirectMethodInfAnalysis: Return created direct method influence analysis
		"""
		pass


	def createAnalysisRailDMI(self, analysisName=None) -> IFRailDMIAnalysis:
		r"""
		Create new Rail Direct Method Influence Analysis 
		Params:
			analysisName (str, optional): Analysis name; if empty or not given, a default name will be generated
		Returns:
			IFRailDMIAnalysis: Return created direct method influence analysis
		"""
		pass


	def createAnalysisBranchRailDMI(self, loadcase, analysisName=None) -> IFRailDMIAnalysis:
		r"""
		Create new Rail Direct Method Influence Analysis as a branch within the given stage 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			analysisName (str, optional): Analysis name; if empty or not given, a default name will be generated
		Returns:
			IFRailDMIAnalysis: Return created direct method influence analysis
		"""
		pass


	def createVLORun(self, runName, analysisName=None, informPanel=None) -> IFVLORun:
		r"""
		Create a new run of VLO (and, if necessary, the analysis to contain it). VLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			runName (str): Name of this run of VLO, if empty string given then a default name will be generated
			analysisName (str, optional): Name of containing analysis, if empty or not given then a default name will be generated
			informPanel (bool, optional): if TRUE (default), the new run will appear in the loadcase panel
		Returns:
			IFVLORun: Return created VLO analysis
		"""
		pass


	def createVLOBranch(self, loadcase, runName, analysisName=None, informPanel=None) -> IFVLORun:
		r"""
		Create a new run of VLO (and, if necessary, the analysis to contain it) as a branch within the given stage. VLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			runName (str): Name of this run of VLO, if empty string given then a default name will be generated
			analysisName (str, optional): Name of containing analysis, if empty or not given then a default name will be generated
			informPanel (bool, optional): if TRUE (default), the new run will appear in the loadcase panel
		Returns:
			IFVLORun: Return created VLO analysis
		"""
		pass


	def createRLORun(self, runName, analysisName=None, informPanel=None) -> IFVLORun:
		r"""
		Create a new run of VLO (and, if necessary, the analysis to contain it). VLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			runName (str): Name of this run of VLO, if empty string given then a default name will be generated
			analysisName (str, optional): Name of containing analysis, if empty or not given then a default name will be generated
			informPanel (bool, optional): if TRUE (default), the new run will appear in the loadcase panel
		Returns:
			IFVLORun: Return created VLO analysis
		"""
		pass


	def createTLOEnvelopeRun(self, runName, isRLO, informPanel=None) -> IFTLOEnvelopeRun:
		r"""
		Create a new envlope run of TLO (and, if necessary, the analysis to contain it). TLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			runName (str): Name of the TLO envelope Run, if empty string given then a default name will be generated
			isRLO (bool): if TRUE, an RLO Envelope Run is created
			informPanel (bool, optional): if TRUE (default), the new run will appear in the loadcase panel
		Returns:
			IFTLOEnvelopeRun: Return created VLO analysis
		"""
		pass


	def createTLOEnvelopeRunBranch(self, loadcase, runName, isRLO, informPanel=None) -> IFTLOEnvelopeRun:
		r"""
		Create a new envlope run of TLO (and, if necessary, the analysis to contain it). TLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			runName (str): Name of the TLO envelope Run, if empty string given then a default name will be generated
			isRLO (bool): if TRUE, an RLO Envelope Run is created
			informPanel (bool, optional): if TRUE (default), the new run will appear in the loadcase panel
		Returns:
			IFTLOEnvelopeRun: Return created TLO Envelope branch
		"""
		pass


	def createRLOBranch(self, loadcase, runName, analysisName=None, informPanel=None) -> IFVLORun:
		r"""
		Create a new run of RLO (and, if necessary, the analysis to contain it) as a branch within the given stage. RLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			loadcase (IFLoadcase): The name of a loadcase, or a pointer to a IFLoadcase object. Stage within which to create this branch
			runName (str): Name of this run of VLO, if empty string given then a default name will be generated
			analysisName (str, optional): Name of containing analysis, if empty or not given then a default name will be generated
			informPanel (bool, optional): if TRUE (default), the new run will appear in the loadcase panel
		Returns:
			IFVLORun: Return created VLO analysis
		"""
		pass


	def getVLORun(self, runName) -> IFVLORun:
		r"""
		Return an existing run of VLO. VLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			runName (str): Name to search for
		Returns:
			IFVLORun: 
		"""
		pass


	def getTLOEnvelopeRun(self, runName) -> IFTLOEnvelopeRun:
		r"""
		Return an existing TLO Envelope Run 
		Params:
			runName (str): Name to search for
		Returns:
			IFTLOEnvelopeRun: 
		"""
		pass


	def existsVLORun(self, name) -> bool:
		r"""
		Return true if an run of VLO exists with the given name. 
		Params:
			name (str): Name to search for
		Returns:
			bool: 
		"""
		pass


	def existsTLOEnvelopeRun(self, name) -> bool:
		r"""
		Return true if a TLO envelope run exists with the given name. 
		Params:
			name (str): Name to search for
		Returns:
			bool: 
		"""
		pass


	def deleteVLORun(self, name) -> None:
		r"""
		Deletes a VLO run with the name given. VLO run names need to be unique, it is not possible to have two runs with the same name, even if they are in different analyses 
		Params:
			name (str): Name of VLO run
		Returns:
			None: 
		"""
		pass


	def deleteTLOEnvelopeRun(self, name) -> None:
		r"""
		Deletes a TLO envelope run with the name given. TLO envelope run names are unique 
		Params:
			name (str): Name of TLO envelope run
		Returns:
			None: 
		"""
		pass


	def deleteTLORun(self, pIRun) -> None:
		r"""
		Deletes the given TLO run (TLO run or TLO Envelope run) 
		Params:
			pIRun (IFTLORunBase): TLO run
		Returns:
			None: 
		"""
		pass


	def saveStrArray(self, name, array) -> None:
		r"""
		Preserves a named array of strings in this database LUSAS will not examine the strings, or use them in any way, but it will preserve them in the mdl file for later retrieval using IFDatabase.loadStrArray Note that it is permitted to call saveDblArray with the same name as previously used in IFDatabase.saveIntArray or IFDatabase.saveDblArray as data of other types is not lost or modified. 
		Params:
			name (str): unique name for the array
			array (array of strs): The array of strings to save
		Returns:
			None: 
		"""
		pass


	def saveIntArray(self, name, array) -> None:
		r"""
		Preserves a named array of integers in this database LUSAS will not examine the integers, or use them in any way, but it will preserve them in the mdl file for later retrieval using IFDatabase.loadIntArray Note that it is permitted to call saveDblArray with the same name as previously used in IFDatabase.saveStrArray or IFDatabase.saveDblArray as data of other types is not lost or modified. 
		Params:
			name (str): unique name for the array
			array (array of ints): The array of integers to save
		Returns:
			None: 
		"""
		pass


	def saveDblArray(self, name, array) -> None:
		r"""
		Preserves a named array of strings in this database LUSAS will not examine the strings, or use them in any way, but it will preserve them in the mdl file for later retrieval using IFDatabase.loadStrArray Note that it is permitted to call saveDblArray with the same name as previously used in IFDatabase.saveStrArray or IFDatabase.saveIntArray, as data of other types is not lost or modified. 
		Params:
			name (str): unique name for the array
			array (array of float): The array of real numbers to save
		Returns:
			None: 
		"""
		pass


	def loadStrArray(self, name) -> list[str]:
		r"""
		Retrieves an array saved previously using IFDatabase.saveStrArray. If array doesn't exist a null array is returned. 
		Params:
			name (str): name to search for
		Returns:
			array of strs: The returned array of strings
		"""
		pass


	def loadIntArray(self, name) -> list[int]:
		r"""
		Retrieves an array saved previously using IFDatabase.saveIntArray. If array doesn't exist a null array is returned. 
		Params:
			name (str): name to search for
		Returns:
			array of ints: The returned array of integers
		"""
		pass


	def loadDblArray(self, name) -> list[float]:
		r"""
		Retrieves an array saved previously using IFDatabase.saveDblArray. If array doesn't exist a null array is returned. 
		Params:
			name (str): name to search for
		Returns:
			array of float: The returned array of real numbers
		"""
		pass


	def createGeometryMap(self, data) -> IFDatabase:
		r"""
		 
		Params:
			data (IFGeometryData): 
		Returns:
			IFDatabase: 
		"""
		pass


	def deleteGeometryMap(self, data) -> IFDatabase:
		r"""
		 
		Params:
			data (IFGeometryData): 
		Returns:
			IFDatabase: 
		"""
		pass


	def deleteAllGeometryMaps(self) -> IFDatabase:
		r"""
		 
		Returns:
			IFDatabase: 
		"""
		pass


	def checkLineOrder(self, lineSelection, checkDirections, pErrMsg) -> bool:
		r"""
		Given a string containing multiple line IDs in format "1;3;5T8", this function returns true if the lines form either a closed loop or a continuous line 
		Params:
			lineSelection (str): string containing the line IDs that need to be checked. This string will be modified such that the lines are in order
			checkDirections (bool): if TRUE, an error is returned if the lines' individual directions are not consistent. If FALSE, the individual lines' order is ignored.
			pErrMsg (str): error message describing why it failed
		Returns:
			bool: true if the lines form a closed loop or continuous line
		"""
		pass


	def findLinePaths(self, inputLines, linePaths, lineDirections=None, isClosedLoop=None) -> int:
		r"""
		Given a selection of lines, this function finds groups of lines linked together 
		Params:
			inputLines (array of IFLine): 
			linePaths (array of array of IFLine): linked together
			lineDirections (array of arrays of bools, optional): representing line directions for lines in a path
			isClosedLoop (array of bools, optional): one for each line path (true if the lines in a path form a closed loop, false for open)
		Returns:
			int: number of closed line paths
		"""
		pass


	def setIDAllocationStyle(self, attrType, method) -> None:
		r"""
		Specifies the manner by which attribute IDs are automatically allocated. Two techniques are available "fromEnd", which behaves like V13, and gives each new attribute an index calculated as one higher than the current highest. Conversely "fillgaps" will reuse IDs where attributes have been deleted. 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			method (str): "fillgaps", "fromend"
		Returns:
			None: 
		"""
		pass


	def getIDAllocationStyle(self, attrType) -> str:
		r"""
		Returns the manner by which attribute IDs are automatically allocated. Two techniques are available "fromEnd", which behaves like V13, and gives each new attribute an index calculated as one higher than the current highest. Conversely "fillgaps" will reuse IDs where attributes have been deleted. 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
		Returns:
			str: "fillgaps", "fromend"
		"""
		pass


	def deleteAttribute(self, attr) -> None:
		r"""
		Deletes the given attribute/utility The attribute may be specified by name, by ID, or as an object. It is an error to call this function if the attribute is assigned (you may wish to call IFAttribute.deassignFrom("All") first). It is an error to call this function if the given info is not unique. For example, deleteAttribute("fred") is OK if there is only one attribute in your model called "fred". However, it is possible to create attributes with the same name, as long as they have different types. So if you create both a load and support with the same name, this function cannot be used to delete by name - use getAttribute() to get the object, and then pass the object to this function. 
		Params:
			attr (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object.
		Returns:
			None: 
		"""
		pass


	def setAsDefault(self, attrType, attribute) -> None:
		r"""
		Sets the specified attribute as the default attribute for this type. This means that all new objects will automatically receive an assignment to this attribute. This function is also used to remove the default attribute (if any) of the given type - use (for example) setAsDefault("material", "none") 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object.
		Returns:
			None: 
		"""
		pass


	def getAttribute(self, attrType, attributeName) -> IFAttribute:
		r"""
		Returns the attribute/utility of the given type with the name/ID given 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			attributeName (str or int): name or ID of the attribute
		Returns:
			IFAttribute: 
		"""
		pass


	def deleteAttributes(self, attrType, arg2=None, reportError=None) -> int:
		r"""
		Deletes all attributes/utilities of the specified type Optionally, output can be restricted to only those with the given name(s) and/or in the given range of IDs. Delete is only possible if the attribute is not assigned. Returns the number actually deleted - so you may check that the operation was successful by first calling IFDatabase.getAttributes and comparing the number of objects returned by that function with the return value of this one.  
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			arg2 (str, optional): names and/or IDs of attributes, e.g. "bob;1T5" (default all)
			reportError (bool, optional): flag to indicate if an error should be reported when the attribute type is unrecognised (default = True)
		Returns:
			int: the number of attributes successfully deleted
		"""
		pass


	def getAttributes(self, attrType, arg2=None) -> list[IFAttribute]:
		r"""
		Fetches all attributes/utilities of the given type as an array. The array can then be looped in the normal way. Note that if only a results file is loaded (i.e. without the corresponding model) only attribute IDs will be in the array. Otherwise the array will be filled with attribute objects Optionally, output can be restricted to only those with the given name(s) and/or in the given range of IDs. The array can then be looped in the normal way. 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			arg2 (str, optional): names and/or IDs of attributes, e.g. "bob;1T5" (default all)
		Returns:
			array of IFAttribute objects: the returned array
		"""
		pass


	def existsAttribute(self, attributeType, attributeName) -> bool:
		r"""
		Returns true if an attribute/utility exists with the type and name/ID given false otherwise 
		Params:
			attributeType (object): "Loading", "Support", "Material", etc
			attributeName (str or int): name or ID of the attribute
		Returns:
			bool: true if it exists
		"""
		pass


	def countAttributes(self, attrType, names=None) -> int:
		r"""
		Returns the number of attribute/utility objects of the given type. You may optionally pass in a string such as "1-10" to discover how many attributes exist with that range of IDs. 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			names (str, optional): e.g. "Bob;1-10" (default all)
		Returns:
			int: the number
		"""
		pass


	def hasAssignments(self, attrType) -> bool:
		r"""
		Returns whether or not any attribute/utility objects of the given type are actually assigned 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
		Returns:
			bool: true if assigned
		"""
		pass


	def resetAttributes(self) -> IFDatabase:
		r"""
		Deletes all the stored visualisation/tabulation data for all defined attributes. Generally this function is not needed, but it can be useful for large models to release memory between pre- and post- processing. 
		Returns:
			IFDatabase: 
		"""
		pass


	def createPointMeshAttr(self, attrName, elementSize, firstStretch, firstVector, secondStretch, secondVector) -> IFPointSpacingMeshAttr:
		r"""
		Creates a point mesh attribute 
		Params:
			attrName (str): name of attribute
			elementSize (float): Element size
			firstStretch (float): 
			firstVector (array of float): An array of 3 real numbers, representing 3d coordinates
			secondStretch (float): 
			secondVector (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFPointSpacingMeshAttr: 
		"""
		pass


	def createPointMeshSizeAttr(self, attrName, elementSize) -> IFPointSpacingMeshAttr:
		r"""
		 
		Params:
			attrName (str): name of attribute
			elementSize (float): Element size
		Returns:
			IFPointSpacingMeshAttr: 
		"""
		pass


	def createPointMeshElementAttr(self, attrName, elementName) -> IFPointElementMeshAttr:
		r"""
		 
		Params:
			attrName (str): name of attribute
			elementName (str): 
		Returns:
			IFPointElementMeshAttr: 
		"""
		pass


	def createMeshLine(self, attrName) -> IFMeshLine:
		r"""
		Creates a line mesh attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMeshLine: Newly created attribute
		"""
		pass


	def createMeshSurface(self, attrName) -> IFMeshSurface:
		r"""
		Creates a surface mesh attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMeshSurface: Newly created attribute
		"""
		pass


	def createMeshVolume(self, attrName) -> IFMeshVolume:
		r"""
		Create a volume mesh attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMeshVolume: Newly created attribute
		"""
		pass


	def createMeshPhreatic(self, attrName) -> IFMeshPhreatic:
		r"""
		Create a phreatic surface mesh attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMeshPhreatic: Newly created attribute
		"""
		pass


	def createLocalCartesianXYAttr(self, attrName, angle, origin) -> IFPlanarRotationCartLocalAttr:
		r"""
		Creates a local Cartesian coordinate set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationCartLocalAttr: 
		"""
		pass


	def createLocalCylindricalXYAttr(self, attrName, angle, origin) -> IFPlanarRotationCylLocalAttr:
		r"""
		Creates a local cylindrical coordinate set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationCylLocalAttr: 
		"""
		pass


	def createLocalSphericalXYAttr(self, attrName, angle, origin) -> IFPlanarRotationSphLocalAttr:
		r"""
		Creates a local spherical set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationSphLocalAttr: 
		"""
		pass


	def createLocalCartesianXZAttr(self, attrName, angle, origin) -> IFPlanarRotationCartLocalAttr:
		r"""
		Creates a local Cartesian coordinate set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationCartLocalAttr: 
		"""
		pass


	def createLocalCylindricalXZAttr(self, attrName, angle, origin) -> IFPlanarRotationCylLocalAttr:
		r"""
		Creates a local cylindrical coordinate set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationCylLocalAttr: 
		"""
		pass


	def createLocalSphericalXZAttr(self, attrName, angle, origin) -> IFPlanarRotationSphLocalAttr:
		r"""
		Creates a local spherical set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationSphLocalAttr: 
		"""
		pass


	def createLocalCartesianYZAttr(self, attrName, angle, origin) -> IFPlanarRotationCartLocalAttr:
		r"""
		Creates a local Cartesian coordinate set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationCartLocalAttr: 
		"""
		pass


	def createLocalCylindricalYZAttr(self, attrName, angle, origin) -> IFPlanarRotationCylLocalAttr:
		r"""
		Creates a local cylindrical coordinate set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationCylLocalAttr: 
		"""
		pass


	def createLocalSphericalYZAttr(self, attrName, angle, origin) -> IFPlanarRotationSphLocalAttr:
		r"""
		Creates a local spherical set 
		Params:
			attrName (str): name of attribute
			angle (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationSphLocalAttr: 
		"""
		pass


	def createLocalCartesianAttr(self, attrName, offset, matrixCol0, matrixCol1, matrixCol2) -> IFGenRotationCartLocalAttr:
		r"""
		Creates a local Cartesian coordinate set 
		Params:
			attrName (str): name of attribute
			offset (array of float): An array of 3 real numbers, representing 3d coordinates Offset of the coordinate system
			matrixCol0 (array of float): An array of 3 real numbers, representing 3d coordinates first column of 3x3 array of real numbers
			matrixCol1 (array of float): An array of 3 real numbers, representing 3d coordinates second column of 3x3 array of real numbers
			matrixCol2 (array of float): An array of 3 real numbers, representing 3d coordinates third column of 3x3 array of real numbers
		Returns:
			IFGenRotationCartLocalAttr: 
		"""
		pass


	def createLocalCylindricalAttr(self, attrName, offset, matrixCol0, matrixCol1, matrixCol2) -> IFGenRotationCylLocalAttr:
		r"""
		Creates a local cylindrical coordinate set 
		Params:
			attrName (str): name of attribute
			offset (array of float): An array of 3 real numbers, representing 3d coordinates Offset of the coordinate system
			matrixCol0 (array of float): An array of 3 real numbers, representing 3d coordinates first column of 3x3 array of real numbers
			matrixCol1 (array of float): An array of 3 real numbers, representing 3d coordinates second column of 3x3 array of real numbers
			matrixCol2 (array of float): An array of 3 real numbers, representing 3d coordinates third column of 3x3 array of real numbers
		Returns:
			IFGenRotationCylLocalAttr: 
		"""
		pass


	def createLocalSphericalAttr(self, attrName, offset, matrixCol0, matrixCol1, matrixCol2) -> IFGenRotationSphLocalAttr:
		r"""
		Creates a local spherical set 
		Params:
			attrName (str): name of attribute
			offset (array of float): An array of 3 real numbers, representing 3d coordinates Offset of the coordinate system
			matrixCol0 (array of float): An array of 3 real numbers, representing 3d coordinates first column of 3x3 array of real numbers
			matrixCol1 (array of float): An array of 3 real numbers, representing 3d coordinates second column of 3x3 array of real numbers
			matrixCol2 (array of float): An array of 3 real numbers, representing 3d coordinates third column of 3x3 array of real numbers
		Returns:
			IFGenRotationSphLocalAttr: 
		"""
		pass


	def createLocalCartesianAttrFrom2Points(self, attrName, originPoint, XaxisPoint) -> IFGenRotationCartLocalAttr:
		r"""
		Creates a local Cartesian coordinate set 
		Params:
			attrName (str): name of attribute
			originPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XaxisPoint (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFGenRotationCartLocalAttr: 
		"""
		pass


	def createLocalCylindricalAttrFrom2Points(self, attrName, originPoint, XaxisPoint) -> IFGenRotationCylLocalAttr:
		r"""
		Creates a local cylindrical coordinate set 
		Params:
			attrName (str): name of attribute
			originPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XaxisPoint (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFGenRotationCylLocalAttr: 
		"""
		pass


	def createLocalSphericalAttrFrom2Points(self, attrName, originPoint, XaxisPoint) -> IFGenRotationSphLocalAttr:
		r"""
		Creates a local spherical set 
		Params:
			attrName (str): name of attribute
			originPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XaxisPoint (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFGenRotationSphLocalAttr: 
		"""
		pass


	def createLocalCartesianAttrFrom3Points(self, attrName, OriginPoint, XaxisPoint, XYplanePoint) -> IFGenRotationCartLocalAttr:
		r"""
		Creates a local Cartesian coordinate set 
		Params:
			attrName (str): name of attribute
			OriginPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XaxisPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XYplanePoint (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFGenRotationCartLocalAttr: 
		"""
		pass


	def createLocalCylindricalAttrFrom3Points(self, attrName, OriginPoint, XaxisPoint, XYplanePoint) -> IFGenRotationCylLocalAttr:
		r"""
		Creates a local cylindrical coordinate set 
		Params:
			attrName (str): name of attribute
			OriginPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XaxisPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XYplanePoint (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFGenRotationCylLocalAttr: 
		"""
		pass


	def createLocalSphericalAttrFrom3Points(self, attrName, OriginPoint, XaxisPoint, XYplanePoint) -> IFGenRotationSphLocalAttr:
		r"""
		Creates a local spherical set 
		Params:
			attrName (str): name of attribute
			OriginPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XaxisPoint (array of float): An array of 3 real numbers, representing 3d coordinates
			XYplanePoint (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFGenRotationSphLocalAttr: 
		"""
		pass


	def createLocalCartesianScaleAttr(self, attrName, origin, scales) -> IFScaleCartLocalAttr:
		r"""
		Creates a local Cartesian coordinate set 
		Params:
			attrName (str): name of attribute
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
			scales (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFScaleCartLocalAttr: 
		"""
		pass


	def createLocalCylindricalScaleAttr(self, attrName, origin, scales) -> IFScaleCylLocalAttr:
		r"""
		Creates a local cylindrical coordinate set 
		Params:
			attrName (str): name of attribute
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
			scales (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFScaleCylLocalAttr: 
		"""
		pass


	def createLocalSphericalScaleAttr(self, attrName, origin, scales) -> IFScaleSphLocalAttr:
		r"""
		Creates a local spherical set 
		Params:
			attrName (str): name of attribute
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
			scales (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFScaleSphLocalAttr: 
		"""
		pass


	def createLocalSurfaceAxesAttr(self, attrName) -> IFSurfaceAxesLocalAttr:
		r"""
		Creates local coordinate set normal to assigned surface 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSurfaceAxesLocalAttr: 
		"""
		pass


	def createTranslationTransAttr(self, attrName, translation) -> IFTranslationTransAttr:
		r"""
		Creates translation transformation attribute 
		Params:
			attrName (str): name of attribute
			translation (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFTranslationTransAttr: 
		"""
		pass


	def createXYRotationTransAttr(self, attrName, angleDegrees, origin) -> IFPlanarRotationTransAttr:
		r"""
		Creates rotation transformation attribute 
		Params:
			attrName (str): name of attribute
			angleDegrees (float): angle in degrees
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationTransAttr: 
		"""
		pass


	def createYZRotationTransAttr(self, attrName, angleDegrees, origin) -> IFPlanarRotationTransAttr:
		r"""
		Creates rotation transformation attribute 
		Params:
			attrName (str): name of attribute
			angleDegrees (float): angle in degrees
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationTransAttr: 
		"""
		pass


	def createXZRotationTransAttr(self, attrName, angleDegrees, origin) -> IFPlanarRotationTransAttr:
		r"""
		Creates rotation transformation attribute 
		Params:
			attrName (str): name of attribute
			angleDegrees (float): 
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
		Returns:
			IFPlanarRotationTransAttr: 
		"""
		pass


	def createRotationTransAttr(self, attrName, axis0, axis1, matrixCol1, matrixCol2, matrixCol3) -> IFGenRotationTransAttr:
		r"""
		Creates rotation transformation attribute 
		Params:
			attrName (str): name of attribute
			axis0 (array of float): An array of 3 real numbers, representing 3d coordinates
			axis1 (array of float): An array of 3 real numbers, representing 3d coordinates
			matrixCol1 (array of float): An array of 3 real numbers, representing 3d coordinates
			matrixCol2 (array of float): An array of 3 real numbers, representing 3d coordinates
			matrixCol3 (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFGenRotationTransAttr: 
		"""
		pass


	def createScaleTransAttr(self, attrName, origin, scales) -> IFScaleTransAttr:
		r"""
		Creates scale transformation attribute 
		Params:
			attrName (str): name of attribute
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Origin of the coordinate system
			scales (array of float): An array of 3 real numbers, representing 3d coordinates
		Returns:
			IFScaleTransAttr: 
		"""
		pass


	def createRotationTransAttrFrom2Points(self, attrName, OriginPoint, XaxisPoint) -> IFGenRotationTransAttr:
		r"""
		Creates rotation transformation attribute 
		Params:
			attrName (str): name of attribute
			OriginPoint (IFPoint): 
			XaxisPoint (IFPoint): 
		Returns:
			IFGenRotationTransAttr: 
		"""
		pass


	def createRotationTransAttrFrom3Points(self, attrName, OriginPoint, XaxisPoint, XYplanePoint) -> IFGenRotationTransAttr:
		r"""
		Creates rotation transformation attribute 
		Params:
			attrName (str): name of attribute
			OriginPoint (IFPoint): 
			XaxisPoint (IFPoint): 
			XYplanePoint (IFPoint): 
		Returns:
			IFGenRotationTransAttr: 
		"""
		pass


	def createMirrorPlaneTransAttr(self, attrName, planeEquation) -> IFMirrorPlaneTransAttr:
		r"""
		Creates mirror transformation attribute 
		Params:
			attrName (str): name of attribute
			planeEquation (array of 4 float): Array defining the coefficients of the plane equation
		Returns:
			IFMirrorPlaneTransAttr: 
		"""
		pass


	def createMirrorPlaneTransAttrFrom2Points(self, attrName, OriginPoint, XaxisPoint) -> IFMirrorPlaneTransAttr:
		r"""
		Creates mirror transformation attribute 
		Params:
			attrName (str): name of attribute
			OriginPoint (IFPoint): 
			XaxisPoint (IFPoint): 
		Returns:
			IFMirrorPlaneTransAttr: 
		"""
		pass


	def createMirrorPlaneTransAttrFrom3Points(self, attrName, OriginPoint, XaxisPoint, XYplanePoint) -> IFMirrorPlaneTransAttr:
		r"""
		Creates mirror transformation attribute 
		Params:
			attrName (str): name of attribute
			OriginPoint (IFPoint): 
			XaxisPoint (IFPoint): 
			XYplanePoint (IFPoint): 
		Returns:
			IFMirrorPlaneTransAttr: 
		"""
		pass


	def createScreenMirrorTransAttr(self, attrName) -> IFScreenMirrorTransAttr:
		r"""
		Creates mirror transformation attribute that works perpendicular to the current screen rotation The screen rotation is obtained at the time the attribute is used, not at the time it is defined. Thus the same attribute can be used for any number of different screen rotations. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFScreenMirrorTransAttr: 
		"""
		pass


	def createCompoundTransAttr(self, attrName, TranAttrs) -> IFCompoundTransAttr:
		r"""
		Creates compound transformation attribute 
		Params:
			attrName (str): name of attribute
			TranAttrs (array of IFTransformationAttr objects): Array, in the order in which they should be applied
		Returns:
			IFCompoundTransAttr: 
		"""
		pass


	def createDataset(self, attrName) -> IFDataset:
		r"""
		Creates a holder for a named generic array of values. This array of values is typically used for graphing, but could potentially have other uses. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDataset: newly created attribute
		"""
		pass


	def getDataset(self, graphName) -> IFDataset:
		r"""
		Returns a dataset object by searching for the given name/ID The returned dataset object may then be interrogated for size, values, etc 
		Params:
			graphName (str or int): name or ID of the graph to be examined
		Returns:
			IFDataset: returned graph dataset
		"""
		pass


	def createPSD(self, attrName) -> IFPSD:
		r"""
		Creates a PSD dataset attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPSD: newly created attribute
		"""
		pass


	def createPedestrianLoadDefinition(self, attrName) -> IFPedestrianLoadDefinition:
		r"""
		Creates a Pedestrian Load Definition attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPedestrianLoadDefinition: newly created attribute
		"""
		pass


	def createSpectralCurve(self, attrName) -> IFSpectralCurve:
		r"""
		Creates a spectral response dataset attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSpectralCurve: newly created attribute
		"""
		pass


	def createVariationField(self, attrName) -> IFVariationField:
		r"""
		Creates a field variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFVariationField: newly created attribute
		"""
		pass


	def createVariationLine(self, attrName) -> IFVariationLine:
		r"""
		Creates a line variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFVariationLine: newly created attribute
		"""
		pass


	def createInterpolationVariation(self, attrName, type, function) -> IFInterpolationVariation:
		r"""
		Creates an interpolation variation 
		Params:
			attrName (str): 
			type (str): "Actual" or "Parametric"
			function (str): 
		Returns:
			IFInterpolationVariation: 
		"""
		pass


	def createInterpolationVariationUnequal(self, attrName, type, distance, function) -> IFInterpolationVariation:
		r"""
		Creates an unequal interpolation variation 
		Params:
			attrName (str): name of attribute
			type (str): "Actual" or "Parametric"
			distance (float): 
			function (str): 
		Returns:
			IFInterpolationVariation: 
		"""
		pass


	def createInterpolationVariationOrder(self, attrName, order, type, function) -> IFInterpolationVariation:
		r"""
		 
		Params:
			attrName (str): name of attribute
			order (str): "Constant", "Linear", "Quadratic", or "Cubic"
			type (str): "Actual" or "Parametric"
			function (str): 
		Returns:
			IFInterpolationVariation: 
		"""
		pass


	def createInterpolationVariationOrderUnequal(self, attrName, order, type, distance, function) -> IFInterpolationVariation:
		r"""
		 
		Params:
			attrName (str): name of attribute
			order (str): "Constant", "Linear", "Quadratic", or "Cubic"
			type (str): "Actual" or "Parametric"
			distance (float): 
			function (str): 
		Returns:
			IFInterpolationVariation: 
		"""
		pass


	def createVariationSurface(self, attrName) -> IFVariationSurface:
		r"""
		Creates a surface variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFVariationSurface: newly created attribute
		"""
		pass


	def createVariationBoundary(self, attrName) -> IFVariationBoundary:
		r"""
		Creates a surface boundary variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFVariationBoundary: newly created attribute
		"""
		pass


	def createVariationGrid(self, attrName) -> IFVariationGrid:
		r"""
		Creates a surface grid variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFVariationGrid: newly created attribute
		"""
		pass


	def createVariationFactored(self, attrName) -> IFVariationFactored:
		r"""
		Creates a factored variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFVariationFactored: newly created attribute
		"""
		pass


	def createVariationLineProfile(self, attrName) -> IFInterpolationVariation:
		r"""
		Creates a line profile variation for use in defining a profile set variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFInterpolationVariation: newly created attribute
		"""
		pass


	def createVariationProfileSet(self, attrName) -> IFProfileVariation:
		r"""
		Creates a profile set variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFProfileVariation: newly created attribute
		"""
		pass


	def createVariationCylinProfileSet(self, attrName) -> IFProfileVariation:
		r"""
		Creates a cylindrical profile set variation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFProfileVariation: newly created attribute
		"""
		pass


	def createGeometricSurface(self, attrName) -> IFGeometricSurface:
		r"""
		Creates a surface geometric properties attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFGeometricSurface: newly created attribute
		"""
		pass


	def createGeometricJoint(self, attrName) -> IFGeometricJoint:
		r"""
		Creates a joint geometric properties attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFGeometricJoint: newly created attribute
		"""
		pass


	def createThermalGeometricLink(self, attrName) -> IFGeometricThermalLink:
		r"""
		Creates a thermal link geometric properties attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFGeometricThermalLink: newly created attribute
		"""
		pass


	def createGeometricLine(self, attrName) -> IFGeometricLine:
		r"""
		Creates a beam geometric properties attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFGeometricLine: newly created attribute
		"""
		pass


	def createActivate(self, attrName) -> IFActivate:
		r"""
		Creates an activate attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFActivate: newly created attribute
		"""
		pass


	def createDeactivate(self, attrName, percent=None, stiffness=None) -> IFDeactivate:
		r"""
		Creates a deactivate attribute 
		Params:
			attrName (str): name of attribute
			percent (float, optional): percentage reduction factor
			stiffness (float, optional): stiffness reduction factor
		Returns:
			IFDeactivate: 
		"""
		pass


	def createDamping(self, attrName) -> IFDamping:
		r"""
		Creates a structural or viscous damping attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDamping: newly created attribute
		"""
		pass


	def createResetDeformation(self, attrName) -> IFResetDeformation:
		r"""
		Creates a reset deformation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFResetDeformation: newly created attribute
		"""
		pass


	def createDimensionLines(self, attrName) -> IFDimensionLines:
		r"""
		Creates a dimension lines attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDimensionLines: newly created attribute
		"""
		pass


	def createGeomBeamOptimPool(self, attrName) -> IFGeomBeamOptimPool:
		r"""
		Creates a geometric section optimisation pool utility 
		Params:
			attrName (str): name of attribute
		Returns:
			IFGeomBeamOptimPool: newly created utility
		"""
		pass


	def createGeomBeamOptimUtil(self, attrName) -> IFGeomBeamOptimUtil:
		r"""
		Creates a geometric section optimisation utility 
		Params:
			attrName (str): name of attribute
		Returns:
			IFGeomBeamOptimUtil: newly created utility
		"""
		pass


	def createEquivalence(self, attrName) -> IFEquivalence:
		r"""
		Creates an equivalence attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFEquivalence: newly created attribute
		"""
		pass


	def createAge(self, attrName) -> IFAge:
		r"""
		Creates an age attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFAge: newly created attribute
		"""
		pass


	def createSurfaceRadiation(self, attrName) -> IFSurfaceRadiation:
		r"""
		Creates a radiation surface attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSurfaceRadiation: newly created attribute
		"""
		pass


	def createSearchArea(self, attrName) -> IFSearchArea:
		r"""
		Creates a search area attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSearchArea: 
		"""
		pass


	def createSlideline(self, attrName, slideType, slideRigidType, slideGeometryType, numberOfPasses, preContact, contactCushion, primaryScale, secondaryScale, coulombFriction, zonalContactDetection, slidelineExtension, closeContactDetection, temperature) -> IFSlide:
		r"""
		Creates a slideline attribute 
		Params:
			attrName (str): name of attribute
			slideType (str): "Friction", "No Friction", "Null", "Sliding" or "Tied"
			slideRigidType (str): "Non-rigid slideline surface", "Rigid slideline master surface" or "Rigid slideline slave surface"
			slideGeometryType (str): "Linear or bilinear slideline surface" or "Quadratic slideline surface"
			numberOfPasses (int): 
			preContact (bool): 
			contactCushion (bool): 
			primaryScale (float): 
			secondaryScale (float): 
			coulombFriction (float): 
			zonalContactDetection (float): 
			slidelineExtension (float): 
			closeContactDetection (float): 
			temperature (float): 
		Returns:
			IFSlide: 
		"""
		pass


	def createThermalSurfaceGap(self, attrName) -> IFThermalSurfaceGap:
		r"""
		Creates a thermal gap attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFThermalSurfaceGap: newly created attribute
		"""
		pass


	def createThermalSurface(self, attrName) -> IFThermalSurface:
		r"""
		Creates a thermal surface attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFThermalSurface: newly created attribute
		"""
		pass


	def createSupportThermal(self, attrName) -> IFSupportThermal:
		r"""
		Creates a thermal support attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSupportThermal: newly created attribute
		"""
		pass


	def createSupportStructural(self, attrName) -> IFSupportStructural:
		r"""
		Creates a structural support attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSupportStructural: newly created attribute
		"""
		pass


	def createLoadingBeamDistributed(self, attrName) -> IFLoadingBeamDistributed:
		r"""
		Creates a beam distributed loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingBeamDistributed: newly created attribute
		"""
		pass


	def createLoadingBeamPoint(self, attrName) -> IFLoadingBeamPoint:
		r"""
		Creates a beam point loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingBeamPoint: newly created attribute
		"""
		pass


	def createLoadingConcentrated(self, attrName) -> IFLoadingConcentrated:
		r"""
		Creates a concentrated structural loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingConcentrated: newly created attribute
		"""
		pass


	def createLoadingBody(self, attrName) -> IFLoadingBody:
		r"""
		Creates a body force loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingBody: newly created attribute
		"""
		pass


	def createLoadingGravity(self, attrName) -> IFLoadingGravity:
		r"""
		Creates a body force loading specifically to represent gravity 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingGravity: newly created attribute
		"""
		pass


	def createLoadingTemperature(self, attrName) -> IFLoadingTemperature:
		r"""
		Creates a temperature loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingTemperature: newly created attribute
		"""
		pass


	def createLoadingStressStrain(self, attrName) -> IFLoadingStressStrain:
		r"""
		Creates an initial stress/strain loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingStressStrain: newly created attribute
		"""
		pass


	def createLoadingFace(self, attrName) -> IFLoadingFace:
		r"""
		Creates a face loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingFace: newly created attribute
		"""
		pass


	def createFieldFaceLoading(self, attrName, flux=None) -> IFFieldFaceLoading:
		r"""
		Creates a field face loading attribute 
		Params:
			attrName (str): name of attribute
			flux (IFVariationAttr or float, optional): 
		Returns:
			IFFieldFaceLoading: 
		"""
		pass


	def createHygroFaceLoading(self, attrName) -> IFFieldFaceLoading:
		r"""
		Creates a hygro-thermal face loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFFieldFaceLoading: 
		"""
		pass


	def createLoadingGlobalDistributed(self, attrName) -> IFLoadingGlobalDistributed:
		r"""
		Creates a global distributed loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingGlobalDistributed: newly created attribute
		"""
		pass


	def createLoadingLocalDistributed(self, attrName) -> IFLoadingLocalDistributed:
		r"""
		Creates a local distributed loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingLocalDistributed: newly created attribute
		"""
		pass


	def createPrescribedDisplacementLoad(self, attrName, type) -> IFPrescribedDisplacementLoad:
		r"""
		Creates a prescribed displacement loading attribute 
		Params:
			attrName (str): name of attribute
			type (str): "Total" or "Incremental"
		Returns:
			IFPrescribedDisplacementLoad: 
		"""
		pass


	def createInitialAccelerationLoad(self, attrName) -> IFInitialAccelerationLoad:
		r"""
		Creates an initial acceleration loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFInitialAccelerationLoad: 
		"""
		pass


	def createPrescribedAccelerationLoad(self, attrName) -> IFPrescribedAccelerationLoad:
		r"""
		Creates a prescribed acceleration loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPrescribedAccelerationLoad: 
		"""
		pass


	def createInitialVelocityLoad(self, attrName) -> IFInitialVelocityLoad:
		r"""
		Creates an initial velocity loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFInitialVelocityLoad: 
		"""
		pass


	def createPrescribedVelocityLoad(self, attrName) -> IFPrescribedVelocityLoad:
		r"""
		Creates a prescribed velocity loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPrescribedVelocityLoad: 
		"""
		pass


	def createLoadingFlux(self, attrName) -> IFLoadingFlux:
		r"""
		Creates a concentrated flux loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingFlux: newly created attribute
		"""
		pass


	def createLoadingPrescribedTemperature(self, attrName) -> IFPrescribedTemperatureLoad:
		r"""
		Creates a prescribed temperature loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPrescribedTemperatureLoad: 
		"""
		pass


	def createLoadingInitialTemperature(self, attrName) -> IFLoadingInitialTemperature:
		r"""
		Creates an initial temperature loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingInitialTemperature: 
		"""
		pass


	def createLoadingEnvironmental(self, attrName) -> IFLoadingEnvironmental:
		r"""
		Creates an environmental loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingEnvironmental: newly created attribute
		"""
		pass


	def createLoadingInternalHeat(self, attrName) -> IFInternalHeatLoading:
		r"""
		Creates an internal heat loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFInternalHeatLoading: 
		"""
		pass


	def createInternalHeatUserLoading(self, attrName, UserDataArray, temperature) -> IFInternalHeatUserLoading:
		r"""
		Creates an internal heat user attribute 
		Params:
			attrName (str): name of attribute
			UserDataArray (array of realvariation): 
			temperature (float): 
		Returns:
			IFInternalHeatUserLoading: 
		"""
		pass


	def createLoadingDiscretePoint(self, attrName) -> IFLoadingDiscretePoint:
		r"""
		Creates a discrete point loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingDiscretePoint: newly created attribute
		"""
		pass


	def createLoadingFluxPoint(self, attrName) -> IFDiscreteFluxPointLoading:
		r"""
		Creates a discrete flux point loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDiscreteFluxPointLoading: newly created attribute
		"""
		pass


	def createLoadingHeatPoint(self, attrName) -> IFDiscreteHeatPointLoading:
		r"""
		Creates a discrete internal heat point loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDiscreteHeatPointLoading: newly created attribute
		"""
		pass


	def createLoadingDiscretePatch(self, attrName) -> IFLoadingDiscretePatch:
		r"""
		Creates a discrete patch loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingDiscretePatch: newly created attribute
		"""
		pass


	def createLoadingENVTpatch(self, attrName) -> IFDiscreteENVTLoading:
		r"""
		Creates a discrete ENVT patch loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDiscreteENVTLoading: newly created attribute
		"""
		pass


	def createLoadingFluxPatch(self, attrName) -> IFDiscreteFluxPatchLoading:
		r"""
		Creates a discrete flux patch loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDiscreteFluxPatchLoading: newly created attribute
		"""
		pass


	def createLoadingHeatPatch(self, attrName) -> IFDiscreteHeatPatchLoading:
		r"""
		Creates a discrete internal heat patch loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDiscreteHeatPatchLoading: newly created attribute
		"""
		pass


	def createLoadingDiscreteCompound(self, attrName) -> IFDiscreteCompoundLoading:
		r"""
		Creates a discrete compound loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDiscreteCompoundLoading: newly created attribute
		"""
		pass


	def createLoadingConcreteHydration(self, attrName) -> IFLoadingConcreteHydration:
		r"""
		Creates a load to represent heat of concrete hydration 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingConcreteHydration: newly created attribute
		"""
		pass


	def createSurfaceDistributedLoad(self, attrName) -> IFSurfDistrLoading:
		r"""
		Creates a surface distributed loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSurfDistrLoading: newly created attribute
		"""
		pass


	def createLoadingTemperatureProfile(self, attrName) -> IFTemperatureProfileLoad:
		r"""
		Creates a temperature profile loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFTemperatureProfileLoad: newly created attribute
		"""
		pass


	def createLoadingStrainProfile(self, attrName) -> IFStrainProfileLoad:
		r"""
		Creates a strain profile loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFStrainProfileLoad: newly created attribute
		"""
		pass


	def createLoadingWaterPressureDistr(self, attrName) -> IFWaterPressureDistrLoad:
		r"""
		Creates a water pressure distribution loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFWaterPressureDistrLoad: newly created attribute
		"""
		pass


	def createConstraintConstant(self, attrName) -> IFConstraintConstant:
		r"""
		Creates a constant constraint equation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFConstraintConstant: newly created attribute
		"""
		pass


	def createCyclicRotationConstraint(self, attrName, Primary, Secondary) -> IFConstraintCyclic:
		r"""
		Creates a cyclic rotation constraint attribute 
		Params:
			attrName (str): name of attribute
			Primary (float): ordinate
			Secondary (float): ordinate
		Returns:
			IFConstraintCyclic: 
		"""
		pass


	def createCyclicRotationConstraintVals(self, attrName, primaryX, primaryY, primaryZ, secondaryX, secondaryY, secondaryZ) -> IFConstraintCyclic:
		r"""
		Creates a cyclic rotation constraint attribute 
		Params:
			attrName (str): name of attribute
			primaryX (float): 
			primaryY (float): 
			primaryZ (float): 
			secondaryX (float): 
			secondaryY (float): 
			secondaryZ (float): 
		Returns:
			IFConstraintCyclic: 
		"""
		pass


	def createCyclicTranslationConstraint(self, attrName, Primary, Secondary) -> IFCyclicTranslation:
		r"""
		Creates a cyclic translation constraint attribute 
		Params:
			attrName (str): name of attribute
			Primary (float): ordinate
			Secondary (float): ordinate
		Returns:
			IFCyclicTranslation: 
		"""
		pass


	def createCyclicTranslationConstraintVals(self, attrName, primaryX, primaryY, primaryZ, secondaryX, secondaryY, secondaryZ) -> IFCyclicTranslation:
		r"""
		Creates a cyclic translation constraint attribute 
		Params:
			attrName (str): name of attribute
			primaryX (float): 
			primaryY (float): 
			primaryZ (float): 
			secondaryX (float): 
			secondaryY (float): 
			secondaryZ (float): 
		Returns:
			IFCyclicTranslation: 
		"""
		pass


	def createNormalTiedMeshConstraint(self, attrName) -> IFNormalTiedMeshConstraint:
		r"""
		Creates a normal tied mesh constraint attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFNormalTiedMeshConstraint: 
		"""
		pass


	def createConstraintPath(self, attrName) -> IFConstraintPath:
		r"""
		Creates a path constraint equation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFConstraintPath: newly created attribute
		"""
		pass


	def createPlanarSurfaceConstraint(self, attrName) -> IFPlanarSurfaceConstraint:
		r"""
		Creates a planar surface constraint attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPlanarSurfaceConstraint: 
		"""
		pass


	def createRigidDisplacementConstraint(self, attrName) -> IFRigidDisplacementConstraint:
		r"""
		Creates a rigid displacement constraint attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFRigidDisplacementConstraint: 
		"""
		pass


	def createRigidLinkConstraint(self, attrName) -> IFRigidLinkConstraint:
		r"""
		Creates a rigid link constraint attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFRigidLinkConstraint: 
		"""
		pass


	def createConstraintEquation(self, attrName) -> IFConstraintEquation:
		r"""
		Creates a specified constraint equation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFConstraintEquation: newly created attribute
		"""
		pass


	def createConstraintTied(self, attrName) -> IFConstraintTied:
		r"""
		Creates a specified tied mesh constraint equation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFConstraintTied: newly created attribute
		"""
		pass


	def createStraightLineConstraint(self, attrName) -> IFStraightLineConstraint:
		r"""
		Create a straight line constraint attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFStraightLineConstraint: 
		"""
		pass


	def createRigidFloorConstraint(self, attrName) -> IFRigidFloorConstraintEqu:
		r"""
		Creates a rigid floor constraint equation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFRigidFloorConstraintEqu: newly created attribute
		"""
		pass


	def createRetainedStructural(self, attrName) -> IFRetainedStructural:
		r"""
		Creates a structural retained freedom attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFRetainedStructural: newly created attribute
		"""
		pass


	def createRetainedThermal(self, attrName) -> IFRetainedThermal:
		r"""
		Creates a thermal retained freedom attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFRetainedThermal: newly created attribute
		"""
		pass


	def createIsotropicMaterial(self, attrName, Young, Poisson, Density, alpha=None, massDamping=None, stiffDamping=None, temp=None) -> IFMaterialIsotropic:
		r"""
		Creates an isotropic material attribute 
		Params:
			attrName (str): name of attribute
			Young (IFVariationAttr or float): Young's modulus
			Poisson (IFVariationAttr or float): Poisson's ratio
			Density (IFVariationAttr or float): density
			alpha (IFVariationAttr or float, optional): coefficient of thermal expansion
			massDamping (IFVariationAttr or float, optional): Mass Rayleigh damping constant
			stiffDamping (IFVariationAttr or float, optional): Stiffness Rayleigh damping constant
			temp (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def createOrthotropicPlaneStressMaterial(self, attrName, YoungX, YoungY, ShearXY, PoissonXY, Angle, Density, temperature=None, defnPageType=None) -> IFMaterialOrthotropic:
		r"""
		Creates an orthotropic material attribute 
		Params:
			attrName (str): name of attribute
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			ShearXY (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float, optional): temperature
			defnPageType (str, optional): "Plane stress", "Axisymmetric shell"
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def createOrthotropicPlaneStrainMaterial(self, attrName, YoungX, YoungY, YoungZ, ShearXY, PoissonXY, PoissonYZ, PoissonXZ, Angle, Density, temperature=None) -> IFMaterialOrthotropic:
		r"""
		Creates an orthotropic plane strain material attribute 
		Params:
			attrName (str): name of attribute
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			YoungZ (IFVariationAttr or float): Young's modulus in Z
			ShearXY (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			PoissonYZ (IFVariationAttr or float): Poisson's ratio in YZ
			PoissonXZ (IFVariationAttr or float): Poisson's ratio in XZ
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float, optional): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def createOrthotropicSheetMaterial(self, attrName, YoungX, YoungY, PoissonXY, Angle, Density, temperature=None) -> IFMaterialOrthotropic:
		r"""
		Creates an orthotropic sheet material attribute 
		Params:
			attrName (str): name of attribute
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float, optional): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def createOrthotropicThickMaterial(self, attrName, YoungX, YoungY, ShearXY, ShearYZ, ShearXZ, PoissonXY, Angle, Density, temperature=None) -> IFMaterialOrthotropic:
		r"""
		Creates an orthotropic thick material attribute 
		Params:
			attrName (str): name of attribute
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			ShearXY (IFVariationAttr or float): 
			ShearYZ (IFVariationAttr or float): 
			ShearXZ (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float, optional): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def createOrthotropicAxisymmetricMaterial(self, attrName, YoungX, YoungY, YoungZ, ShearXY, PoissonXY, PoissonYZ, PoissonXZ, Angle, Density, temperature=None) -> IFMaterialOrthotropic:
		r"""
		Creates an axisymmetric orthotropic material attribute 
		Params:
			attrName (str): name of attribute
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			YoungZ (IFVariationAttr or float): Young's modulus in Z
			ShearXY (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			PoissonYZ (IFVariationAttr or float): Poisson's ratio in YZ
			PoissonXZ (IFVariationAttr or float): Poisson's ratio in XZ
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float, optional): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def createOrthotropicSolidMaterial(self, attrName, YoungX, YoungY, YoungZ, ShearXY, ShearYZ, ShearXZ, PoissonXY, PoissonYZ, PoissonXZ, Density, temperature=None) -> IFMaterialOrthotropic:
		r"""
		Creates a solid orthotropic material attribute 
		Params:
			attrName (str): name of attribute
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			YoungZ (IFVariationAttr or float): Young's modulus in Z
			ShearXY (IFVariationAttr or float): 
			ShearYZ (IFVariationAttr or float): 
			ShearXZ (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			PoissonYZ (IFVariationAttr or float): Poisson's ratio in YZ
			PoissonXZ (IFVariationAttr or float): Poisson's ratio in XZ
			Density (IFVariationAttr or float): density
			temperature (float, optional): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def createAnisotropicMaterial(self, attrName, MassDensity, Angle, Matrix, temperature=None) -> IFAnisotropicMaterial:
		r"""
		Creates an anisotropic material attribute 
		Params:
			attrName (str): name of attribute
			MassDensity (IFVariationAttr or float): density
			Angle (IFVariationAttr or float): 
			Matrix (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFAnisotropicMaterial: 
		"""
		pass


	def createRigiditiesMaterial(self, attrName, massDensity, angle, pMatrix, temperature=None, materialType=None) -> IFRigiditiesMaterial:
		r"""
		Creates a rigidity matrix attribute 
		Params:
			attrName (str): name of attribute
			massDensity (float): density
			angle (float): Angle of orthotropy in degrees relative to reference axis
			pMatrix (array of float): Upper triangle of rigidity matrix
			temperature (float, optional): temperature
			materialType (str, optional): rigidities type
		Returns:
			IFRigiditiesMaterial: 
		"""
		pass


	def createFrictionalJointMaterial(self, AttrName, FrictionCoeff, InitialGap, MassPosition, Stiffness, Mass, normalDir=None) -> IFFrictionalJointMaterial:
		r"""
		Creates a frictional joint attribute (Mdl=34) 
		Params:
			AttrName (str): name of attribute
			FrictionCoeff (IFVariationAttr or float): 
			InitialGap (IFVariationAttr or float): 
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			normalDir (str, optional): "X", "Y" or "Z"
		Returns:
			IFFrictionalJointMaterial: 
		"""
		pass


	def createGeneralJointMaterial(self, AttrName, MassPosition, Stiffness, Mass) -> IFGeneralJointMaterial:
		r"""
		Creates a general joint attribute 
		Params:
			AttrName (str): name of attribute
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
		Returns:
			IFGeneralJointMaterial: 
		"""
		pass


	def createNonlinearJointMaterial(self, AttrName, MassPosition, Stiffness, Mass, TensileYieldForce, TensileStrainStiffness, CompressiveYieldForce, CompressiveStrainStiffness) -> IFNonlinearJointMaterial:
		r"""
		Creates a nonlinear joint material (mdl=32) 
		Params:
			AttrName (str): name of attribute
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			TensileYieldForce (array of realvariation): 
			TensileStrainStiffness (array of realvariation): 
			CompressiveYieldForce (array of realvariation): 
			CompressiveStrainStiffness (array of realvariation): 
		Returns:
			IFNonlinearJointMaterial: 
		"""
		pass


	def createSmoothJointMaterial(self, AttrName, MassPosition, Stiffness, Mass, LiftOffForce, LiftOffStiffness, InitialGap, Unused=None) -> IFSmoothJointMaterial:
		r"""
		Creates a nonlinear smooth joint attribute (mdl=33) 
		Params:
			AttrName (str): name of attribute
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			LiftOffForce (array of realvariation): 
			LiftOffStiffness (array of realvariation): 
			InitialGap (array of realvariation): 
			Unused (str, optional): Unused. For future extension. Do not provide this value.
		Returns:
			IFSmoothJointMaterial: 
		"""
		pass


	def createSpringJointMaterial(self, AttrName, Stiffness) -> IFSpringJointMaterial:
		r"""
		Creates a linear joint attribute 
		Params:
			AttrName (str): name of attribute
			Stiffness (array of realvariation): 
		Returns:
			IFSpringJointMaterial: 
		"""
		pass


	def createUniformJointMaterial(self, AttrName, MassPosition, Stiffness, Mass, YieldForce, StrainStiffness) -> IFUniformJointMaterial:
		r"""
		Creates a nonlinear joint attribute 
		Params:
			AttrName (str): name of attribute
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			YieldForce (array of realvariation): 
			StrainStiffness (array of realvariation): 
		Returns:
			IFUniformJointMaterial: 
		"""
		pass


	def createViscousJointMaterial(self, AttrName, MassPosition, Stiffness, Mass, Viscosity, Velocity, Preload) -> IFViscousJointMaterial:
		r"""
		Creates a viscous joint attribute (Mdl=35) 
		Params:
			AttrName (str): name of attribute
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			Viscosity (array of realvariation): 
			Velocity (array of realvariation): 
			Preload (array of realvariation): 
		Returns:
			IFViscousJointMaterial: 
		"""
		pass


	def createLeadRubberBearingJointMaterial(self, AttrName, BiaxialCoef, MassPosition, Stiffness, Mass, YieldForce, PostYieldStiffness, normalDir=None) -> IFLeadRubberBearingJointMaterial:
		r"""
		Creates a lead rubber bearing joint attribute (Mdl=36) 
		Params:
			AttrName (str): name of attribute
			BiaxialCoef (IFVariationAttr or float): 
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			YieldForce (array of realvariation): 
			PostYieldStiffness (array of realvariation): 
			normalDir (str, optional): "X", "Y" or "Z"
		Returns:
			IFLeadRubberBearingJointMaterial: 
		"""
		pass


	def createFrictionalPendulumJointMaterial(self, AttrName, ContactArea, RadiusSlide, BiaxialCoef, MassPosition, Stiffness, Mass, normalDir=None) -> IFFrictionalPendulumJointMaterial:
		r"""
		Creates a frictional pendulum joint attribute (Mdl=37) 
		Params:
			AttrName (str): name of attribute
			ContactArea (IFVariationAttr or float): 
			RadiusSlide (IFVariationAttr or float): 
			BiaxialCoef (IFVariationAttr or float): 
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			normalDir (str, optional): "X", "Y" or "Z"
		Returns:
			IFFrictionalPendulumJointMaterial: 
		"""
		pass


	def createNonLinearUserJointMaterial(self, AttrName, ModelID, NStateVar, MassPosition, Stiffness, Mass, dofData, fixedData) -> IFNonLinearUserJointMaterial:
		r"""
		Creates a non-linear user joint attribute 
		Params:
			AttrName (str): name of attribute
			ModelID (IFVariationAttr or float): user model number
			NStateVar (IFVariationAttr or float): number of state variables
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node"
			Stiffness (array of realvariation): 
			Mass (array of realvariation): 
			dofData (array of realvariation): user model data specified per degree of freedom e.g. ( ( dof1, dof2 ), ( dof1, dof2 ), ( dof1, dof2 ) )
			fixedData (array of realvariation): user model data specified for all freedoms
		Returns:
			IFNonLinearUserJointMaterial: 
		"""
		pass


	def createPiecewiseLinearJointMaterial(self, AttrName, MassPosition, CouplingType, Stiffness, Mass) -> IFPiecewiseLinearJointMaterial:
		r"""
		Creates a Piecewise linear joint attribute 
		Params:
			AttrName (str): name of attribute
			MassPosition (str): Mass Position "Between nodes", "At first node" or "At second node" Position of mass or masses: "Between nodes", "At first node", "At second node"
			CouplingType (couplingType): direction used to define axial force: "Uncoupled", "Local X", "Local Y", "Local Z"
			Stiffness (array of realvariation): Elastic spring stiffesses for each freedom
			Mass (array of realvariation): Mass for each freedom
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def createPlasticHingeJointMaterial(self, AttrName) -> IFPlasticHingeJointMaterial:
		r"""
		Creates a plastic hinge joint attribute 
		Params:
			AttrName (str): name of attribute
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def createPlasticHingePMMJointMaterial(self, AttrName, hingeType) -> IFPlasticHingePMMJointMaterial:
		r"""
		Creates a plastic hinge PMM joint attribute 
		Params:
			AttrName (str): name of attribute
			hingeType (int): 1=Fx-My, 2=Fx-Mz, 3=My-Mz, 4=Fx-My-Mz
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def createMatrixJointMaterial(self, AttrName) -> IFMatrixJointMaterial:
		r"""
		Creates a matrix joint attribute 
		Params:
			AttrName (str): name of attribute
		Returns:
			IFMatrixJointMaterial: 
		"""
		pass


	def createFieldIsoMaterial(self, attrName) -> IFMaterialIsotropic:
		r"""
		Creates a isotropic field material attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def createFieldOrthoMaterial(self, attrName) -> IFMaterialOrthotropic:
		r"""
		Creates a orthotropic field material attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def create2dInterfaceMaterial(self, attrName, energy1, strength1, disp1, coupling1, energy2, strength2, disp2, coupling2) -> IFInterfaceMaterial:
		r"""
		Creates a 2D interface material attribute 
		Params:
			attrName (str): name of attribute
			energy1 (float): critical fracture energy in 1 direction
			strength1 (float): tensile threshold strength in 1 direction
			disp1 (float): maximum relative displacement in 1 direction
			coupling1 (int): "Coupled", "UncoupledReversible" or "UncoupledOrigin"
			energy2 (float): critical fracture energy in 2 direction
			strength2 (float): tensile threshold strength in 2 direction
			disp2 (float): maximum relative displacement in 2 direction
			coupling2 (int): "Coupled", "UncoupledReversible" or "UncoupledOrigin"
		Returns:
			IFInterfaceMaterial: 
		"""
		pass


	def create3dInterfaceMaterial(self, attrName, energy1, strength1, disp1, coupling1, energy2, strength2, disp2, coupling2, energy3, strength3, disp3, coupling3) -> IFInterfaceMaterial:
		r"""
		Creates a 3D interface material attribute 
		Params:
			attrName (str): name of attribute
			energy1 (float): critical fracture energy in 1 direction
			strength1 (float): tensile threshold strength in 1 direction
			disp1 (float): maximum relative displacement in 1 direction
			coupling1 (int): "Coupled", "UncoupledReversible" or "UncoupledOrigin"
			energy2 (float): critical fracture energy in 2 direction
			strength2 (float): tensile threshold strength in 2 direction
			disp2 (float): maximum relative displacement in 2 direction
			coupling2 (int): "Coupled", "UncoupledReversible" or "UncoupledOrigin"
			energy3 (float): critical fracture energy in 3 direction
			strength3 (float): tensile threshold strength in 3 direction
			disp3 (float): maximum relative displacement in 3 direction
			coupling3 (int): "Coupled", "UncoupledReversible" or "UncoupledOrigin"
		Returns:
			IFInterfaceMaterial: 
		"""
		pass


	def createMooneyRubberMaterial(self, attrName, rubberConst1, rubberConst2, bulkModulus, massDensity, thermalExp, massR, stiffnessR) -> IFRubberMaterial:
		r"""
		Creates a material attribute for Mooney Rivlin rubber model 
		Params:
			attrName (str): name of attribute
			rubberConst1 (float): Mooney Rivlin rubber constant
			rubberConst2 (float): Mooney Rivlin rubber constant
			bulkModulus (float): bulk modulus
			massDensity (float): density
			thermalExp (float): coefficient of thermal expansion
			massR (float): Mass Rayleigh damping constant
			stiffnessR (float): Stiffness Rayleigh damping constant
		Returns:
			IFRubberMaterial: 
		"""
		pass


	def createHookeanRubberMaterial(self, attrName, rubberConst, bulkModulus, massDensity, thermalExp, massR, stiffnessR) -> IFRubberMaterial:
		r"""
		Creates a material attribute for NeoHookean rubber model 
		Params:
			attrName (str): name of attribute
			rubberConst (float): Neo Hookena rubber constant
			bulkModulus (float): bulk modulus
			massDensity (float): density
			thermalExp (float): coefficient of thermal expansion
			massR (float): Mass Rayleigh damping constant
			stiffnessR (float): Stiffness Rayleigh damping constant
		Returns:
			IFRubberMaterial: 
		"""
		pass


	def createHenckyRubberMaterial(self, attrName, shearModulus, bulkModulus, massDensity, thermalExp, massR, stiffnessR) -> IFRubberMaterial:
		r"""
		Creates a material attribute for Hencky rubber model 
		Params:
			attrName (str): name of attribute
			shearModulus (float): Shear modulus
			bulkModulus (float): bulk modulus
			massDensity (float): density
			thermalExp (float): coefficient of thermal expansion
			massR (float): Mass Rayleigh damping constant
			stiffnessR (float): Stiffness Rayleigh damping constant
		Returns:
			IFRubberMaterial: 
		"""
		pass


	def createOgdenRubberMaterial(self, attrName, bulkModulus, massDensity, thermalExp, massR, stiffnessR) -> IFRubberMaterial:
		r"""
		Creates a material attribute for Ogden rubber model 
		Params:
			attrName (str): name of attribute
			bulkModulus (float): bulk modulus
			massDensity (float): density
			thermalExp (float): coefficient of thermal expansion
			massR (float): Mass Rayleigh damping constant
			stiffnessR (float): Stiffness Rayleigh damping constant
		Returns:
			IFRubberMaterial: 
		"""
		pass


	def createVolumeCrushingMaterial(self, attrName, bIsVolumetric, bulkModulus, shearModulus, massDensity, thermalExp, massRayleigh, stiffRayleigh, heatFraction, cutOffPressure, pressureDepend0, pressureDepend1, pressureDepend2) -> IFVolumeCrushingMaterial:
		r"""
		Creates a material attribute for volumetric crushing model (Mdl=81) 
		Params:
			attrName (str): name of attribute
			bIsVolumetric (bool): volumetric crushing indicator
			bulkModulus (float): bulk modulus
			shearModulus (float): Shear modulus
			massDensity (float): density
			thermalExp (float): coefficient of thermal expansion
			massRayleigh (float): Mass Rayleigh damping constant
			stiffRayleigh (float): Stiffness Rayleigh damping constant
			heatFraction (float): Heat fraction coefficient
			cutOffPressure (float): Cut off pressure
			pressureDepend0 (float): Parameter defining pressure dependent yield stress
			pressureDepend1 (float): Parameter defining pressure dependent yield stress
			pressureDepend2 (float): Parameter defining pressure dependent yield stress
		Returns:
			IFVolumeCrushingMaterial: 
		"""
		pass


	def create2dMassMaterial(self, attrName, MassX, MassY, type=None) -> IFMaterialMass:
		r"""
		Creates a 2D mass material attribute 
		Params:
			attrName (str): name of attribute
			MassX (IFVariationAttr or float): 
			MassY (IFVariationAttr or float): 
			type (str, optional): distribution type
		Returns:
			IFMaterialMass: 
		"""
		pass


	def create3dMassMaterial(self, attrName, MassX, MassY, MassZ, type=None) -> IFMaterialMass:
		r"""
		Creates a 3D mass material attribute 
		Params:
			attrName (str): name of attribute
			MassX (IFVariationAttr or float): Mass acting in X direction
			MassY (IFVariationAttr or float): Mass acting in Y direction
			MassZ (IFVariationAttr or float): Mass acting in Z direction
			type (str, optional): distribution type
		Returns:
			IFMaterialMass: 
		"""
		pass


	def createNonlinearUserMaterial(self, attrName, Young, Poisson, Density) -> IFMaterialNonlinearUser:
		r"""
		Creates a material attribute for nonlinear user material 
		Params:
			attrName (str): name of attribute
			Young (IFVariationAttr or float): Young's modulus
			Poisson (IFVariationAttr or float): Poisson's ratio
			Density (IFVariationAttr or float): density
		Returns:
			IFMaterialNonlinearUser: 
		"""
		pass


	def createResultantUserMaterial(self, attrName, Young, Poisson, Density, temperature=None) -> IFMaterialResultantUser:
		r"""
		Creates a material attribute for nonlinear resultant material 
		Params:
			attrName (str): name of attribute
			Young (IFVariationAttr or float): Young's modulus
			Poisson (IFVariationAttr or float): Poisson's ratio
			Density (IFVariationAttr or float): density
			temperature (float, optional): temperature
		Returns:
			IFMaterialResultantUser: 
		"""
		pass


	def createCEBFIPconcrete(self, attrName, YoungsModulus, PoissonsRatio, MassDensity, CoeffThermalExpansion, MassRaleighDampingConst, StiffRaleighDampingConst, HeatFractionCoeff, MeanConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, IncludeShrinkage=None, UseNominalThickness=None, InteriorPerimFactor=None, UseFullPerimeter=None) -> IFMaterialIsotropic:
		r"""
		Creates a material attribute for CEB-FIP material (Mdl=86) 
		Params:
			attrName (str): name of attribute
			YoungsModulus (IFVariationAttr or float): Young's modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio
			MassDensity (IFVariationAttr or float): density
			CoeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			MassRaleighDampingConst (IFVariationAttr or float): Mass Rayleigh damping constant
			StiffRaleighDampingConst (IFVariationAttr or float): Stiffness Rayleigh damping constant
			HeatFractionCoeff (IFVariationAttr or float): Heat fraction coefficient
			MeanConcreteCompStrength (IFVariationAttr or float): 
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RelativeHumidity (IFVariationAttr or float): 
			NominalThickness (IFVariationAttr or float): 
			IncludeShrinkage (bool, optional): shrinkage switch
			UseNominalThickness (bool, optional): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float, optional): if using section perimeter this is the factor on the holes
			UseFullPerimeter (bool, optional): if using section perimeter this sets the interior factor to 1
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def createEurocode2concrete(self, attrName, YoungsModulus, PoissonsRatio, MassDensity, CoeffThermalExpansion, MassRaleighDampingConst, StiffRaleighDampingConst, HeatFractionCoeff, MeanConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, IncludeShrinkage, UseNominalThickness, InteriorPerimFactor, AutogenousShrinkage, UseFullPerimeter=None, pSilicaFumeType=None) -> IFMaterialIsotropic:
		r"""
		Creates a material attribute for Eurocode2 material (Mdl=86) 
		Params:
			attrName (str): name of attribute
			YoungsModulus (IFVariationAttr or float): Young's modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio
			MassDensity (IFVariationAttr or float): density
			CoeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			MassRaleighDampingConst (IFVariationAttr or float): Mass Rayleigh damping constant
			StiffRaleighDampingConst (IFVariationAttr or float): Stiffness Rayleigh damping constant
			HeatFractionCoeff (IFVariationAttr or float): Heat fraction coefficient
			MeanConcreteCompStrength (IFVariationAttr or float): 
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RelativeHumidity (IFVariationAttr or float): 
			NominalThickness (IFVariationAttr or float): 
			IncludeShrinkage (bool): shrinkage switch
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			AutogenousShrinkage (bool): autogenous shrinkage flag
			UseFullPerimeter (bool, optional): if using section perimeter this sets the interior factor to 1
			pSilicaFumeType (int, optional): silica fume type
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def createIndiaCreepConcrete(self, attrName, YoungsModulus, PoissonsRatio, MassDensity, CoeffThermalExpansion, MassRaleighDampingConst, StiffRaleighDampingConst, HeatFractionCoeff, MeanConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, IncludeShrinkage, UseNominalThickness, InteriorPerimFactor, AutogenousShrinkage, UseFullPerimeter=None) -> IFMaterialIsotropic:
		r"""
		Creates a material attribute for India IRC:112-2011 
		Params:
			attrName (str): name of attribute
			YoungsModulus (IFVariationAttr or float): Young's modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio
			MassDensity (IFVariationAttr or float): density
			CoeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			MassRaleighDampingConst (IFVariationAttr or float): Mass Rayleigh damping constant
			StiffRaleighDampingConst (IFVariationAttr or float): Stiffness Rayleigh damping constant
			HeatFractionCoeff (IFVariationAttr or float): Heat fraction coefficient
			MeanConcreteCompStrength (IFVariationAttr or float): 
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RelativeHumidity (IFVariationAttr or float): 
			NominalThickness (IFVariationAttr or float): 
			IncludeShrinkage (bool): shrinkage switch
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			AutogenousShrinkage (bool): autogenous shrinkage flag
			UseFullPerimeter (bool, optional): if using section perimeter this sets the interior factor to 1
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def createChineseCreepConcrete(self, attrName, YoungsModulus, PoissonsRatio, MassDensity, CoeffThermalExpansion, A, B, F1, G1, P1, R1, F2, G2, P2, R2, F3, R3, AR=None, BR=None, Hf=None) -> IFMaterialIsotropic:
		r"""
		Creates a material attribute for Chinese creep material (Mdl=86) 
		Params:
			attrName (str): name of attribute
			YoungsModulus (IFVariationAttr or float): Young's modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio
			MassDensity (IFVariationAttr or float): density
			CoeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			A (IFVariationAttr or float): 
			B (IFVariationAttr or float): 
			F1 (IFVariationAttr or float): 
			G1 (IFVariationAttr or float): 
			P1 (IFVariationAttr or float): 
			R1 (IFVariationAttr or float): 
			F2 (IFVariationAttr or float): 
			G2 (IFVariationAttr or float): 
			P2 (IFVariationAttr or float): 
			R2 (IFVariationAttr or float): 
			F3 (IFVariationAttr or float): 
			R3 (IFVariationAttr or float): 
			AR (IFVariationAttr or float, optional): 
			BR (IFVariationAttr or float, optional): 
			Hf (IFVariationAttr or float, optional): 
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def createPolymerMaterial(self, attrName, activationEnergyTension, activationVolumeTension, externalStringStiffnessTension, activationEnergyCompression, activationVolumeCompression, externalStringStiffnessCompression, bulkModulus, density, thermalExpansion, massDamping, stiffnessDamping) -> IFPolymerMaterial:
		r"""
		Creates a material attribute for Generic Polymer material model (Mdl=88) 
		Params:
			attrName (str): name of attribute
			activationEnergyTension (float): activation energy in tension
			activationVolumeTension (float): activation volume in tension
			externalStringStiffnessTension (float): external tensile spring stiffness
			activationEnergyCompression (float): activation energy in compression
			activationVolumeCompression (float): activation volume in compression
			externalStringStiffnessCompression (float): external compressive spring stiffness
			bulkModulus (float): bulk modulus
			density (float): density
			thermalExpansion (float): coefficient of thermal expansion
			massDamping (float): Mass Rayleigh damping constant
			stiffnessDamping (float): Stiffness Rayleigh damping constant
		Returns:
			IFPolymerMaterial: 
		"""
		pass


	def createGPMdamageMaterial(self, attrName, damageModel_E, tensionFuncId_E, compressionFuncId_E, failureCriteria_E, activationEnergyTension, activationVolumeTension, shearSpringTension, activationEnergyCompression, activationVolumeCompression, shearSpringCompression, internalFlawSize, aveCrackGrowth, stressIntensity, crackingParameter, maxRateCrackGrowth, maxCrackLength, coeffFriction, ultimateStressTension, ultimateStrainTension, ultimateStressCompression, ultimateStrainCompression, constant1, constant2, constant3, constant4, constant5, constant6, constant7, constant8, bulkModulus, density, thermal, mass, stiffness, pModeSwitch=None, pExponentYminRate=None, pMinStrainRate=None, pExponentYmaxRate=None, pMaxStrainRate=None) -> IFGPMdamageMaterial:
		r"""
		 
		Params:
			attrName (str): name of attribute
			damageModel_E (int): idam
			tensionFuncId_E (int): itdam
			compressionFuncId_E (int): icdam
			failureCriteria_E (int): icrit
			activationEnergyTension (float): At
			activationVolumeTension (float): Vt
			shearSpringTension (float): Gsprt
			activationEnergyCompression (float): Ac
			activationVolumeCompression (float): Vc
			shearSpringCompression (float): GSprc
			internalFlawSize (float): a
			aveCrackGrowth (float): c
			stressIntensity (float): K0
			crackingParameter (float): m
			maxRateCrackGrowth (float): Vmax
			maxCrackLength (float): Cmax
			coeffFriction (float): mus
			ultimateStressTension (float): sut
			ultimateStrainTension (float): eut
			ultimateStressCompression (float): suc
			ultimateStrainCompression (float): euc
			constant1 (float): C1
			constant2 (float): C2
			constant3 (float): C3
			constant4 (float): C4
			constant5 (float): C5
			constant6 (float): C6
			constant7 (float): C7
			constant8 (float): C8
			bulkModulus (float): bulk modulus
			density (float): density
			thermal (float): alpha
			mass (float): ar
			stiffness (float): br
			pModeSwitch (int, optional): 0=model 89. 1 = model 90 (mean stress), 2 = model 90 (Maxwell element stress)
			pExponentYminRate (float, optional): Exponent Y at min strain rate
			pMinStrainRate (float, optional): Min valid strain rate
			pExponentYmaxRate (float, optional): Exponent Y at max strain rate
			pMaxStrainRate (float, optional): Max valid strain rate
		Returns:
			IFGPMdamageMaterial: 
		"""
		pass


	def setArbSectionReferenceMaterial(self, nameID) -> IFDatabase:
		r"""
		set the arbitrary section reference material 
		Params:
			nameID (str or int): name or ID of material attribute
		Returns:
			IFDatabase: 
		"""
		pass


	def removeArbSectionReferenceMaterial(self) -> IFDatabase:
		r"""
		unset the arbitrary section reference material 
		Returns:
			IFDatabase: 
		"""
		pass


	def createBeamComposite(self, attrName, layerName, material, isSymmetric) -> IFCompositeBeam:
		r"""
		Creates a beam composite attribute 
		Params:
			attrName (str): name of attribute
			layerName (str): layer name
			material (IFMaterial): The name or ID of a material, or a pointer to a IFMaterial object.
			isSymmetric (bool): symmetric layup flag
		Returns:
			IFCompositeBeam: 
		"""
		pass


	def createShellComposite(self, attrName, layerName, thickness, angle, material, isSymmetric, volumeFraction=None) -> IFCompositeShell:
		r"""
		Creates a composite attribute 
		Params:
			attrName (str): name of attribute
			layerName (str): layer name
			thickness (float): relative layer thickness
			angle (float): angle of fibre to reference axis
			material (IFMaterial): The name or ID of a material, or a pointer to a IFMaterial object.
			isSymmetric (bool): symmetric layup flag
			volumeFraction (float, optional): volume fraction for a non-draped composite
		Returns:
			IFCompositeShell: 
		"""
		pass


	def createInfluence(self, attrName) -> IFInfluence:
		r"""
		Creates an influence line attribute 
		Params:
			attrName (str): name of the new attribute
		Returns:
			IFInfluence: newly created attribute
		"""
		pass


	def createDirectInfluence(self, attrName) -> IFDirectMethodInfluence:
		r"""
		Creates an influence line attribute 
		Params:
			attrName (str): name of the new attribute
		Returns:
			IFDirectMethodInfluence: newly created attribute
		"""
		pass


	def createInfluenceEnvelope(self, attrName) -> IFInfluenceEnvelope:
		r"""
		Creates an influence envelope attribute 
		Params:
			attrName (str): name of the new attribute
		Returns:
			IFInfluenceEnvelope: newly created attribute
		"""
		pass


	def setLongitudinalDirPath(self, path) -> None:
		r"""
		Sets the longitudinal direction for influence lines to follow a line path 
		Params:
			path (str): 
		Returns:
			None: 
		"""
		pass


	def setLongitudinalDirGlobalAxis(self, axis) -> None:
		r"""
		Sets the longitudinal direction for influence lines as one of the global axis 
		Params:
			axis (str): axis name
		Returns:
			None: 
		"""
		pass


	def setLongitudinalDirLocalCoord(self, pLocalCoord, axisIndex) -> None:
		r"""
		Sets the longitudinal direction for influence lines as one of the global axis 
		Params:
			pLocalCoord (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object. local coordinate
			axisIndex (int): axis index, 0 based
		Returns:
			None: 
		"""
		pass


	def createTendonProperties(self, attrName) -> IFTendonProperties:
		r"""
		Create a prestress tendon properties object. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFTendonProperties: 
		"""
		pass


	def createFailureComposite(self, attrName) -> IFFailureComposite:
		r"""
		
		Params:
			attrName (str): name of attribute
		Returns:
			IFFailureComposite: 
		"""
		pass


	def createDesignFactor(self, attrName) -> IFDesignFactor:
		r"""
		
		Params:
			attrName (str): name of attribute
		Returns:
			IFDesignFactor: 
		"""
		pass


	def createVLOVehicleLibrary(self, name) -> IFVLOVehicleLibrary:
		r"""
		
		Params:
			name (str): name of attribute
		Returns:
			IFVLOVehicleLibrary: 
		"""
		pass


	def createBeamStressRecovery(self, attrName) -> IFBeamStressRecovery:
		r"""
		
		Params:
			attrName (str): name of attribute
		Returns:
			IFBeamStressRecovery: 
		"""
		pass


	def createDesignAttribute(self, attrName, typeName, scopeName, assignType=None, isUtility=None) -> IFDesignAttribute:
		r"""
		Creates a new Design Attribute / Utility The only difference between an attribute and a utility is that utilities cannot be assigned and are shown in a different panel in the UI 
		Params:
			attrName (str): name of attribute
			typeName (str): Full SubType name as it appears in the tree
			scopeName (str): SubType name used as User Defined Results scope
			assignType (str, optional): list of features the attribute can be assign to : "Lines", "Surfaces", "Volumes" etc
			isUtility (bool, optional): true for utility, false (default) for attribute
		Returns:
			IFDesignAttribute: returned attribute
		"""
		pass


	def createShearTorsionAdvPropsDefinition(self, attrName) -> IFShearTorsionAdvPropsDefinition:
		r"""
		Creates a new advanced shear and torsion properties utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFShearTorsionAdvPropsDefinition: returned attribute
		"""
		pass


	def createMBWDefinition(self, attrName) -> IFMBWDefinition:
		r"""
		Creates a new Masonry Bridge Wizard definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMBWDefinition: returned attribute
		"""
		pass


	def createTankDefinition(self, attrName) -> IFTankDefinition:
		r"""
		Creates a new Tank definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFTankDefinition: returned attribute
		"""
		pass


	def createKogasTankDefinition(self, attrName) -> IFKogasTankDefinition:
		r"""
		Creates a new KOGAS Tank definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFKogasTankDefinition: returned attribute
		"""
		pass


	def createTankReinforcementDefinition(self, attrName) -> IFTankReinforcementDefinition:
		r"""
		Creates a new Tank reinforcement definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFTankReinforcementDefinition: returned attribute
		"""
		pass


	def createBridgeWizardBridgeDefinition(self, attrName) -> IFBridgeWizardBridgeDefinition:
		r"""
		Creates a new Bridge Wizard Bridge definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardBridgeDefinition: returned attribute
		"""
		pass


	def createBridgeWizardSupportDefinition(self, attrName) -> IFBridgeWizardSupportDefinition:
		r"""
		Creates a new Bridge Wizard Support definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardSupportDefinition: returned attribute
		"""
		pass


	def createBridgeWizardStiffenerDefinition(self, attrName) -> IFBridgeWizardStiffenerDefinition:
		r"""
		Creates a new Bridge Wizard Stiffener definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardStiffenerDefinition: returned attribute
		"""
		pass


	def createBridgeWizardSpanDefinition(self, attrName) -> IFBridgeWizardSpanDefinition:
		r"""
		Creates a new Bridge Wizard Span definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardSpanDefinition: returned attribute
		"""
		pass


	def createBridgeWizardSectionDefinition(self, attrName) -> IFBridgeWizardSectionDefinition:
		r"""
		Creates a new Bridge Wizard Section definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardSectionDefinition: returned attribute
		"""
		pass


	def createBridgeWizardTubSectionDefinition(self, attrName) -> IFBridgeWizardTubSectionDefinition:
		r"""
		Not implemented 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardTubSectionDefinition: returned attribute
		"""
		pass


	def createBridgeWizardGirderDefinition(self, attrName) -> IFBridgeWizardGirderDefinition:
		r"""
		Creates a new Bridge Wizard Girder definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardGirderDefinition: returned attribute
		"""
		pass


	def createBridgeWizardBracingDefinition(self, attrName) -> IFBridgeWizardBracingDefinition:
		r"""
		Creates a new Bridge Wizard Bracing Assembly definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardBracingDefinition: returned attribute
		"""
		pass


	def createBridgeWizardBracingRunDefinition(self, attrName) -> IFBridgeWizardBracingRunDefinition:
		r"""
		Creates a new Bridge Wizard Bracing Run definition utility. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeWizardBracingRunDefinition: returned attribute
		"""
		pass


	def createBridgeDesignGirderMaterial(self, attrName) -> IFBridgeDesignGirderMaterial:
		r"""
		Composite bridge design material definition. Describes the various materials used in a composite design 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeDesignGirderMaterial: returned attribute
		"""
		pass


	def createBridgeDesignTransverseStiffener(self, attrName) -> IFBridgeDesignTransverseStiffener:
		r"""
		Transverse stiffener definition used in bridge design 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeDesignTransverseStiffener: returned attribute
		"""
		pass


	def createBridgeDesignLongitudinalStiffener(self, attrName) -> IFBridgeDesignLongitudinalStiffener:
		r"""
		Longitudinal stiffener definition used in bridge design 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeDesignLongitudinalStiffener: returned attribute
		"""
		pass


	def createPushoverCurve(self, attrName) -> IFPushoverCurve:
		r"""
		Creates a new Pushover Curve 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPushoverCurve: returned attribute
		"""
		pass


	def createStoreyLoading(self, attrName) -> IFBuildingLoading:
		r"""
		Creates a new Storey Loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBuildingLoading: returned attribute
		"""
		pass


	def createSeismicStoreyLoading(self, attrName) -> IFBuildingLoading:
		r"""
		Creates a new eismic Storey Loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBuildingLoading: returned attribute
		"""
		pass


	def createScriptedAttribute(self, attrName, subType, isUtility=None) -> IFScriptedAttribute:
		r"""
		Creates a new attribute / utility with no initial behaviour. The only difference between an attribute and a utility is that utilities cannot be assigned and are shown in a different panel in the UI. LUSAS will not visualise or tabulate this attribute / utility, but it may be created, edited and assigned just like any other attribute / utility. It is the user's responsibility to attach any meaning, calculation, behaviour etc. A sub type is allowed to distinguish between different types of scripted attribute / utility. Values 0, 1 and 2 are reserved by LUSAS. 
		Params:
			attrName (str): name of attribute
			subType (int): sub type must be in range 3-10
			isUtility (bool, optional): true for utility, false (default) for attribute
		Returns:
			IFScriptedAttribute: 
		"""
		pass


	def createCrackTip(self, attrName) -> IFCrackTip:
		r"""
		Creates a crack tip attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFCrackTip: newly created attribute
		"""
		pass


	def createElementType(self, attrName) -> IFElementTypeAttr:
		r"""
		Creates an element type attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFElementTypeAttr: newly created attribute
		"""
		pass


	def removeAllUserResultComponents(self) -> IFDatabase:
		r"""
		Removes all user defined result components from the database. 
		Returns:
			IFDatabase: 
		"""
		pass


	def createReferencePath(self, pathName) -> IFReferencePath:
		r"""
		Creates a reference path 
		Params:
			pathName (pathName): 
		Returns:
			IFReferencePath: newly created attribute
		"""
		pass


	def createRailTrackDefinition(self, trackName) -> IFRailTrackDefinition:
		r"""
		Creates a rail track definition 
		Params:
			trackName (railTrackName): 
		Returns:
			IFRailTrackDefinition: newly created track
		"""
		pass


	def createRailTrackLayout(self, trackLayoutName) -> IFRailTrackLayout:
		r"""
		Creates a rail track layout 
		Params:
			trackLayoutName (trackLayoutName): 
		Returns:
			IFRailTrackLayout: newly created track layout
		"""
		pass


	def getRailwayLayoutsForTLO(self) -> list:
		r"""
		Return an array of all railway layouts that are used in a Rail DMI analysis 
		Returns:
			array of railway layouts: Returned array
		"""
		pass


	def createDrapeObjectsSet(self, nameStr) -> IFObjsToDrape:
		r"""
		Create a new empty objects to drape set 
		Params:
			nameStr (str): 
		Returns:
			IFObjsToDrape: 
		"""
		pass


	def createNonlinearUserThermal(self, attrName, modelId, nState) -> IFNonlinearUserThermal:
		r"""
		Creates a nonlinear user thermal material attribute 
		Params:
			attrName (str): name of attribute
			modelId (int): model number
			nState (int): number of state variables
		Returns:
			IFNonlinearUserThermal: 
		"""
		pass


	def createCamClayMaterialSet(self, attrName) -> IFCamClayMaterialSet:
		r"""
		Creates a modified Cam-Clay material set attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFCamClayMaterialSet: 
		"""
		pass


	def createPiecewiseLinearBarMaterial(self, attrName) -> IFPiecewiseLinearBarMaterial:
		r"""
		Creates a multi linear bar material attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPiecewiseLinearBarMaterial: 
		"""
		pass


	def createThermalMaterialLink(self, attrName) -> IFThermalLinkMaterial:
		r"""
		Creates a thermal link material 
		Params:
			attrName (str): name of attribute
		Returns:
			IFThermalLinkMaterial: 
		"""
		pass


	def createSoilStructureMaterialSet(self, attrName) -> IFSoilStructureMaterialSet:
		r"""
		Creates a soil structure interface material set attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def createDuncanChangMaterialSet(self, attrName) -> IFDuncanChangMaterialSet:
		r"""
		Creates a Duncan-Chang soil material set attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDuncanChangMaterialSet: 
		"""
		pass


	def createAASHTOconcreteMaterial(self, attrName) -> IFMaterialIsotropic:
		r"""
		Creates AASHTO creep material 
		Params:
			attrName (str): name of attribute
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def createPYCurve(self, attrName) -> IFPYCurve:
		r"""
		Creates a P-Y curve material 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPYCurve: 
		"""
		pass


	def createPileMaterialLayup(self, attrName) -> IFPileMaterialLayup:
		r"""
		Creates an embedded pile material layup 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPileMaterialLayup: 
		"""
		pass


	def createElastoPlasticMaterialSet(self, attrName) -> IFElastoPlasticInterfaceSet:
		r"""
		Creates a Elasto platic interface material set attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFElastoPlasticInterfaceSet: 
		"""
		pass


	def setSmartCombinationType(self, type) -> None:
		r"""
		Sets the type of smart combination - (0)Permanent/Variable (1)Adverse/Beneficial 
		Params:
			type (int): 
		Returns:
			None: 
		"""
		pass


	def getSmartCombinationType(self) -> int:
		r"""
		Gets the type of smart combination - (0)Permanent/Variable (1)Adverse/Beneficial 
		Returns:
			int: 
		"""
		pass


	def updateAutoRenumberSettings(self) -> None:
		r"""
		Set the renumbering settings passed in pSettings without carrying out the renumbering 
		Returns:
			None: 
		"""
		pass


	def renumberSettings(self) -> IFIDSettingsObj:
		r"""
		Get the renumbering settings for the current session 
		Returns:
			IFIDSettingsObj: 
		"""
		pass


	def setAutoBackup(self, isBackup, backupPath=None) -> None:
		r"""
		Maintains another (current) copy of the model file in another location 
		Params:
			isBackup (bool): maintain copy?
			backupPath (str, optional): where?
		Returns:
			None: 
		"""
		pass


	def setNumberOfBackups(self, nBackups) -> None:
		r"""
		Maintains given number of older copies of the model file within the model folder 
		Params:
			nBackups (int): how many?
		Returns:
			None: 
		"""
		pass


	def getDBBasename(self) -> str:
		r"""
		Returns Model filename without path or extension, e.g. if model is saved as "C:\temp\myModel.mdl", this function returns "myModel" In almost all circumstances it is better to use the standard token "%ModelName%" in place of calling this function. E.g. use IFView.savePicture("%ModelName%.bmp") All of modeller's file handling functions expect and expand tokens of this form automatically 
		Returns:
			str: Model name
		"""
		pass


	def getNextAnalysisName(self, type) -> str:
		r"""
		Returns a name suitable to be to a new analysis, i.e. a name guaranteed not to already be in use. Valid values for 'type' are: "general structural", "general thermal", "direct influence", "reciprocal influence", "Vehicle Load Optimisation", "Cable Tuning" Warning: This function should not be called in a loop, as the implementation must search all existing names - thus the loop would become n-squared and very slow. 
		Params:
			type (str): 
		Returns:
			str: 
		"""
		pass


	def deleteAllAnalyses(self) -> None:
		r"""
		Delete and remove all analyses from the current model. Note that this leaves LUSAS in a temporarily invalid state with no current loadcase - therefore you must follow this command with creation of replacement analyses. 
		Returns:
			None: 
		"""
		pass


	def deleteAllAttributes(self, allUsageTypes=None) -> None:
		r"""
		Deassign and delete all attributes from the current model. 
		Params:
			allUsageTypes (bool, optional): if true include all attribute of all usage types
		Returns:
			None: 
		"""
		pass


	def deleteAllUtilities(self, allUsageTypes=None) -> None:
		r"""
		Delete all utilities (aka unassignable attributes) from the current model. 
		Params:
			allUsageTypes (bool, optional): if true include all utilities of all usage types
		Returns:
			None: 
		"""
		pass


	def flushResults(self) -> None:
		r"""
		This routine cleans up all memory used to cache results that have been accessed in the current script using IFNode.getResults(), or any of the corresponding IFElement routines. This can be useful when writing scripts for large models, which might otherwise run out of memory. By default, LUSAS Modeller caches any results that have been asked for until the end of the script, in case they are asked for again. Once this function has been called, a further attempt to access the same results again will simply cause a re-calculation of those results. 
		Returns:
			None: 
		"""
		pass


	def isResultsOnly(self) -> bool:
		r"""
		Returns true if this database represents a results (mys) file instead of the more usual model (mdl) file 
		Returns:
			bool: 
		"""
		pass


	def isModified(self) -> bool:
		r"""
		Returns TRUE if this database has been modified since it was opened/created (i.e. if a save is needed). 
		Returns:
			bool: 
		"""
		pass


	def createGraphWizard(self, attrName) -> IFGraphWizard:
		r"""
		Creates a graph wizard attribute which can be used to create graphs that can be re-created or edited at any time. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFGraphWizard: newly created attribute
		"""
		pass


	def getGraphWizard(self, graphWizardName) -> IFGraphWizard:
		r"""
		Returns a graph wizard object by searching for the given name/ID The returned graph wizard  object may then be interrogated for size, values, etc 
		Params:
			graphWizardName (str or int): name or ID of the graph to be examined
		Returns:
			IFGraphWizard: returned graph wizard object
		"""
		pass


	def createPrintResultsWizard(self, attrName) -> IFPrintResultsWizard:
		r"""
		Creates a print results wizard utility object 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPrintResultsWizard: newly created attribute
		"""
		pass


	def saveView(self, attrName) -> IFSavedView:
		r"""
		Creates a model view utility which can be used to store and restore the view settings. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFSavedView: newly created utility
		"""
		pass


	def getSavedView(self, graphWizardName) -> IFSavedView:
		r"""
		Returns a model view utility by searching for the given name/ID 
		Params:
			graphWizardName (str or int): name or ID of the requested model view
		Returns:
			IFSavedView: returned model view
		"""
		pass


	def createUserDefinedResult(self, attrName) -> IFUserDefinedResult:
		r"""
		creates an User Defined Result attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFUserDefinedResult: 
		"""
		pass


	def convertToTimescale(self, value) -> None:
		r"""
		Converts the given time value from the current main units to the current timescale units 
		Params:
			value (float): the value to be converted
		Returns:
			None: 
		"""
		pass


	def convertFromTimescale(self, value) -> None:
		r"""
		Converts the given time value from the current timescale units to the current main units 
		Params:
			value (float): the value to be converted
		Returns:
			None: 
		"""
		pass


	def convertToTimescaleFrequency(self, value) -> None:
		r"""
		Converts the given frequency value from the current main units to the current timescale units 
		Params:
			value (float): the value to be converted
		Returns:
			None: 
		"""
		pass


	def convertFromTimescaleFrequency(self, value) -> None:
		r"""
		Converts the given frequency value from the current timescale units to the current main units 
		Params:
			value (float): the value to be converted
		Returns:
			None: 
		"""
		pass


	def createNote(self, attrName) -> IFNote:
		r"""
		Creates a note utility which can be used to store and restore plain text. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFNote: newly created utility
		"""
		pass


	def getNote(self, noteName) -> IFNote:
		r"""
		Returns a note utility by searching for the given name/ID 
		Params:
			noteName (str or int): name or ID of the requested note
		Returns:
			IFNote: returned note
		"""
		pass


	def createLayoutGridRectangular(self, gridName, isSkew) -> IFLayoutGridRectangular:
		r"""
		Creates a rectangular layout grid 
		Params:
			gridName (gridName): 
			isSkew (bool): true if there will be a skew angle
		Returns:
			IFLayoutGridRectangular: newly created attribute
		"""
		pass


	def createLayoutGridCircular(self, gridName) -> IFLayoutGridCircular:
		r"""
		Creates a circular layout grid 
		Params:
			gridName (gridName): 
		Returns:
			IFLayoutGridCircular: newly created attribute
		"""
		pass


	def createLayoutGridTriangle(self, gridName) -> IFLayoutGridCircular:
		r"""
		Creates a triangular layout grid 
		Params:
			gridName (gridName): 
		Returns:
			IFLayoutGridCircular: newly created attribute
		"""
		pass


	def createLayoutGridOffset(self, gridName) -> IFLayoutGridByOffset:
		r"""
		Creates a reference path offset layout grid 
		Params:
			gridName (gridName): 
		Returns:
			IFLayoutGridByOffset: newly created attribute
		"""
		pass


	def setStoreyGroupsValid(self) -> None:
		r"""
		marks the storey groups as being valid 
		Returns:
			None: 
		"""
		pass


	def setStoreyGroupsInvalid(self) -> None:
		r"""
		marks the storey groups as being invalid 
		Returns:
			None: 
		"""
		pass


	def areStoreyGroupsValid(self) -> bool:
		r"""
		return true if the storey groups are valid 
		Returns:
			bool: 
		"""
		pass


	def countStoreyGroups(self) -> int:
		r"""
		return the number of storey groups currently defined 
		Returns:
			int: 
		"""
		pass


	def getStoreyPrimaryNodes(self, ascendingHeight) -> list[IFNode]:
		r"""
		return array of the storey primary nodes 
		Params:
			ascendingHeight (bool): true for acscending storey height, false for descending
		Returns:
			array of IFNode objects: storey primary nodes array
		"""
		pass


	def createInspectionPoint(self, attrName) -> IFInspectionPoint:
		r"""
		Creates an inspection point attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFInspectionPoint: newly created attribute
		"""
		pass


	def createInspectionLine(self, name) -> IFGraphInspectionLine:
		r"""
		Create an arbitrary results inspection line through the model. The returned object can subsequently be used to calculate results in the same way as the "graph through 2D" facility 
		Params:
			name (str): unique name
		Returns:
			IFGraphInspectionLine: 
		"""
		pass


	def createBeamShellSlice(self, name) -> IFBeamShellSlice:
		r"""
		Create a utility for the Slice Resultants Beams/Shells facility. The underlying implemenatiun is the same as an inspection line with fixed entity and components - see comments therein 
		Params:
			name (str): name of this object
		Returns:
			IFBeamShellSlice: 
		"""
		pass


	def createCompositeDesignMember(self, name) -> IFCompositeDesignMember:
		r"""
		Create a utility for the Composite Design Member facility. The underlying implemenation is the same as a beam shell slice utility- see comments therein 
		Params:
			name (str): name of this object
		Returns:
			IFCompositeDesignMember: 
		"""
		pass


	def setPushoverResultsCaptions(self, strs) -> None:
		r"""
		specify the strings that will be used in results plos / reports for the pushover entity. If this function is never called, the default values are "Elastic", "Yield", "Immediate Occupancy" ,"Life Safety", "Collapse Prevention", "Rotation Capacity") Note that these strings are not stored in the model file, so need to be set each time the model is loaded Note also that the first value (elastic) will not appear in contours or values, but is only for reports 
		Params:
			strs (array of strs): strings to be used
		Returns:
			None: 
		"""
		pass


	def getModuleResultsOutput(self, attrName) -> IFModuleResultsOutput:
		r"""
		Returns a module results output utility by searching for the given sub type and name/ID 
		Params:
			attrName (str or int): name or ID of the requested note
		Returns:
			IFModuleResultsOutput: returned utility
		"""
		pass


	def setAnalysisCategory(self, category) -> None:
		r"""
		Set the analysis category. 
		Params:
			category (str): "2D Grillage/Plate", "2D Inplane", "2D Axisymmetric", "3D"
		Returns:
			None: 
		"""
		pass


	def getAnalysisCategory(self) -> str:
		r"""
		Get the analysis category. 
		Returns:
			str: "2D Grillage/Plate", "2D Inplane", "2D Axisymmetric", "3D"
		"""
		pass


	def createWoodArmer(self, attrName) -> IFWoodArmerAttr:
		r"""
		creates a Wood Armer attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFWoodArmerAttr: 
		"""
		pass


	def createResultsTransformation(self, attrName) -> IFResultsTransformationAttr:
		r"""
		creates a results transformation attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFResultsTransformationAttr: 
		"""
		pass


	def createSectionPropertyModifier(self, attrName) -> IFPropertyModifier:
		r"""
		Creates a section property modifier attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPropertyModifier: newly created attribute
		"""
		pass


	def createLoadingTendon(self, attrName) -> IFLoadingTendon:
		r"""
		Creates a tendon loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFLoadingTendon: newly created attribute
		"""
		pass


	def updatePrestressData(self) -> None:
		r"""
		Converts the data from the old format (before v17.0) to the new format. 
		Returns:
			None: 
		"""
		pass


	def createCompoundMaterial(self, attrName) -> IFCompoundMaterial:
		r"""
		Creates a compound material attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFCompoundMaterial: newly created attribute
		"""
		pass


	def createBridgeDeckMaterial(self, attrName) -> IFBridgeDeckMaterial:
		r"""
		Creates a bridge deck material attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBridgeDeckMaterial: newly created attribute
		"""
		pass


	def createReinforcementSection(self, attrName) -> IFReinforcementSection:
		r"""
		Creates a reinforcement section attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFReinforcementSection: newly created attribute
		"""
		pass


	def createReinforcementLine(self, attrName) -> IFReinforcementLine:
		r"""
		Creates a reinforcement line attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFReinforcementLine: newly created attribute
		"""
		pass


	def createCableShape(self, attrName) -> IFCableShape:
		r"""
		Creates a cable shape attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFCableShape: newly created attribute
		"""
		pass


	def createPhiCReduction(self, attrName) -> IFPhiCReduction:
		r"""
		Creates an phi c reduction attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFPhiCReduction: newly created attribute
		"""
		pass


	def createDrained(self, attrName) -> IFDrained:
		r"""
		Creates a drained attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFDrained: newly created attribute
		"""
		pass


	def createUndrained(self, attrName) -> IFUndrained:
		r"""
		Creates an undrained attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFUndrained: newly created attribute
		"""
		pass


	def createHoekBrownMaterialSet(self, attrName) -> IFHoekBrownMaterialSet:
		r"""
		Creates a Hoek-Brown material set attribute 
		Params:
			attrName (str): 
		Returns:
			IFHoekBrownMaterialSet: newly created attribute
		"""
		pass


	def createBarcelonaBasicMaterialSet(self, attrName) -> IFBarcelonaBasicMaterialSet:
		r"""
		Creates a Barcelona Basic material set attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBarcelonaBasicMaterialSet: newly created attribute
		"""
		pass


	def createParametricSection(self, attrName) -> IFParametricSection:
		r"""
		Creates a section utility which describes the type and and the dimension data of a parametric section. 
		Params:
			attrName (str): name of attribute
		Returns:
			IFParametricSection: newly created utility
		"""
		pass


	def getParametricSection(self, sectionName) -> IFParametricSection:
		r"""
		Returns a parametric section utility by searching for the given name/ID 
		Params:
			sectionName (str or int): name or ID of the requested section
		Returns:
			IFParametricSection: returned section
		"""
		pass


	def createArbitrarySection(self, attrName) -> IFArbitrarySection:
		r"""
		Creates an arbitrary section utility which holds the properties needed for the geometric attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFArbitrarySection: newly created utility
		"""
		pass


	def getArbitrarySection(self, sectionName) -> IFArbitrarySection:
		r"""
		Returns an arbitrary section utility by searching for the given name/ID 
		Params:
			sectionName (str or int): name or ID of the requested section
		Returns:
			IFArbitrarySection: returned section
		"""
		pass


	def updateOriginalModel(self, origModelFile, databaseTypeID, textoutput=None, scriptFile=None) -> None:
		r"""
		Only for use in 64bit modeller. Assumes that this database is a 64bit model which was originally created by converting the given original file name. Asks a 32bit modeller to open that original file, delete all analyses, attributes, utilities and options. Then copies all analyses, attributes, utilities and options from this 64bit model into that 32bit model - thus updating the 32bit model to have the same contents as this 64bit model. In normal use, omit the optional "textoutput" and "scriptfile" arguments. To view / check the mechanism, you may pass in the name of two files (which must not exist). One will be filled with the contents of the text output window from the 32 bit modeller. The other will be filled with the contents of the script used to do the conversion. Viewing the contents of these files may help understand and resolve any problems that may occur 
		Params:
			origModelFile (str): name of the original 32bit model file (which must exist)
			databaseTypeID (int): For future expansion. Must be 0
			textoutput (str, optional): name of a file to recieve the contents of the 32bit text output window (which must not exist)
			scriptFile (str, optional): name of a file to recieve the contents of the conversion script (which must not exist)
		Returns:
			None: 
		"""
		pass


	def createRailTrackZlrRlrProperties(self, attrName) -> IFRailTrackAnalysisZlrRlrProperties:
		r"""
		Zero or Reduced Longitudinal Resistance properties for use in Rail Track Analysis 
		Params:
			attrName (str): name of attribute
		Returns:
			IFRailTrackAnalysisZlrRlrProperties: returned attribute
		"""
		pass


	def createRailTrackZlrRlrRegions(self, attrName) -> IFRailTrackAnalysisZlrRlrRegions:
		r"""
		Zero or Reduced Longitudinal Resistance regions for use in Rail Track Analysis 
		Params:
			attrName (str): name of attribute
		Returns:
			IFRailTrackAnalysisZlrRlrRegions: returned attribute
		"""
		pass


	def createLoadingBeamProjectedPressure(self, attrName) -> IFBeamProjectedPressureLoad:
		r"""
		Creates a beam projected pressure loading attribute 
		Params:
			attrName (str): name of attribute
		Returns:
			IFBeamProjectedPressureLoad: newly created attribute
		"""
		pass


	def calculateFaceSolidityAreasNormal(self, lines, widthFactor, widthExtra, halfWidth, loadset, reporting, Am, Ao, normal) -> int:
		r"""
		Calculate the solidity ratio factors Am (area of members) and Ao (area enclosed by outline) for selected lines. All lines specified must lie in a single plane, otherwise an error will be returned. A small tolerance is allowed on line coordinates before they are considered out of plane (default 10 mm). This may be adjusted via the database options. E.g. call database.options.setDouble("solidityRatioPlaneTol_mm", 10.0) It is assumed that the individual line elements are straight - use with caution if curved elements have been used. returned value: 0: OK 1: failed to find plane 2: lines not within tolerance distance 3: not all lines connected 4: invalid loadcase 5: incompatible cross section 
		Params:
			lines (array): Array of lines (name, line, IFLine) in face - must be in a single plane
			widthFactor (array of floats): Array of extra width to be added to each entry in 'lines' (optional - empty array assumes 0.0)
			widthExtra (array of floats): Array of width factor to be applied to each entry in 'lines' (optional - empty array assumes 1.0)
			halfWidth (array of bools): For each entry in 'lines': TRUE to use half width (line shared between 2 faces), FALSE for full width. (optional - empty array assumes FALSE)
			loadset (name, id, IFLoadset): , loadcase for geometric assignment
			reporting (int): message detail: 0 - errors only, 1 - verbose output
			Am (float): returned Am (area of members)
			Ao (float): returned Ao (area enclosed by outline)
			normal (array of float): An array of 3 real numbers, representing 3d coordinates returned vector that is perpendicular to the plane
		Returns:
			int: status 0 = ok, > 0 for error
		"""
		pass


	def calculateFaceSolidityAreas(self, dir, lines, widthFactor, widthExtra, halfWidth, loadset, reporting, Am, Ao) -> int:
		r"""
		Calculate the solidity ratio factors Am (area of members) and Ao (area enclosed by outline) for selected lines. The lines are first projected onto a flat plane perpendicular to the specified 'dir' vector. It is assumed that the individual line elements are straight - use with caution if curved elements have been used. returned value: 0: OK 3: not all lines connected 4: invalid loadcase 5: incompatible cross section 
		Params:
			dir (array of float): An array of 3 real numbers, representing 3d coordinates projection vector
			lines (array): Array of lines (name, line, IFLine) in face - must be in a single plane
			widthFactor (array of floats): Array of extra width to be added to each entry in 'lines' (optional - empty array assumes 0.0)
			widthExtra (array of floats): Array of width factor to be applied to each entry in 'lines' (optional - empty array assumes 1.0)
			halfWidth (array of bools): For each entry in 'lines': TRUE to use half width (line shared between 2 faces), FALSE for full width. (optional - empty array assumes FALSE)
			loadset (name, id, IFLoadset): , loadcase for geometric assignment
			reporting (int): message detail: 0 - errors only, 1 - verbose output
			Am (float): returned Am (area of members)
			Ao (float): returned Ao (area enclosed by outline)
		Returns:
			int: status 0 = ok, > 0 for error
		"""
		pass


	def getUniqueName(self, attrType, varName) -> str:
		r"""
		Create a unique attribute name starting from that given for the specified attr group 
		Params:
			attrType (object): "Loading", "Support", "Material", etc
			varName (str): name you would like to use for a new attribute
		Returns:
			str: guaranteed unique name if succesful
		"""
		pass


	def getProject(self) -> IFProject:
		r"""
		return the parent project of this database 
		Returns:
			IFProject: 
		"""
		pass


class IFUserContentChapter(IFReportChapter):
	"""
	 
	"""

	def setFileSource(self, name) -> None:
		r"""
		Sets the file source of this chapter 
		Params:
			name (str): file name
		Returns:
			None: 
		"""
		pass


	def setFilesSource(self, fileNames) -> None:
		r"""
		Sets the files source of this chapter 
		Params:
			fileNames (str): or array of strings; file name or array of file names
		Returns:
			None: 
		"""
		pass


	def setCaption(self, caption) -> None:
		r"""
		Sets the caption this chapter 
		Params:
			caption (str): caption shown below image
		Returns:
			None: 
		"""
		pass


class IFUtilityChapter(IFReportChapter):
	"""
	Interface representing a utility in the reports 
	"""

	pass


class IFOneClickReportChapter(IFReportChapter):
	"""
	Interface representing the one-click report bitmaps in the reports 
	"""

	def addPage(self, page) -> None:
		r"""
		Adds one-click report page number to be included in this chapter 
		Params:
			page (int): 
		Returns:
			None: 
		"""
		pass


	def addObjects(self, objects) -> None:
		r"""
		Adds one-click report objects to be included in this chapter 
		Params:
			objects (IFObjectSet): 
		Returns:
			None: 
		"""
		pass


class IFCustomChapter(IFReportChapter):
	"""
	Represents a custom chapter made by user that includes a number of sub reports 
	"""

	def addSubReport(self) -> IFCustomSubReport:
		r"""
		Adds a sub report to the chapter. Returns the sub report that was added. 
		Returns:
			IFCustomSubReport: 
		"""
		pass


class IFModuleChapter(IFReportChapter):
	"""
	Represents a custom chapter whose contents are defined by a LUSAS module. 
	"""

	def createValue(self, varNname, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Creates a new value within this object for subsequent use. The initial value will be 0.0 until modified by a call to IFModuleChapter.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFModuleChapter.setValue and/or subsequent access with IFGroup.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			varNname (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this object contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def setValue(self, varName, value, units=None) -> IFDispatch:
		r"""
		Sets the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): name of the value (e.g. "E")
			value (object): The type given will depend on the value specified
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValue(self, varName, units=None) -> object:
		r"""
		Returns the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): 
			units (IFUnitSet, optional): 
		Returns:
			object: The type returned will depend on the value requested
		"""
		pass


class IFResultsChapter(IFReportChapter):
	"""
	Results chapter class 
	"""

	def addPRWUtility(self, attr) -> None:
		r"""
		Add a print results wizard utility that describes partial output for this chapter 
		Params:
			attr (IFPrintResultsWizard): The name or ID of a name, or a pointer to a IFPrintResultsWizard object.
		Returns:
			None: 
		"""
		pass


	def addUtility(self, attr) -> None:
		r"""
		Add a utility that describes partial output for this chapter 
		Params:
			attr (IFAttribute): The name or ID of a name, or a pointer to a IFAttribute object.
		Returns:
			None: 
		"""
		pass


	def setMaxComponents(self, maxComponents) -> None:
		r"""
		Set the maximum number of components in a table 
		Params:
			maxComponents (int): 
		Returns:
			None: 
		"""
		pass


class IFCableTuningTargetsResultsChapter(IFReportChapter):
	"""
	Cable Tuning Target Results chapter class 
	"""

	def setForLinear(self, linear) -> IFCableTuningTargetsResultsChapter:
		r"""
		True for linear, False for linear 
		Params:
			linear (bool): 
		Returns:
			IFCableTuningTargetsResultsChapter: 
		"""
		pass


class IFPrestressChapter(IFReportChapter):
	"""
	Represents the prestress report chapter 
	"""

	def settingOutInformation(self, settingOut, spacing, verticalOrigin, horizontalOrigin) -> IFPrestressChapter:
		r"""
		Update the setting out information data 
		Params:
			settingOut (bool): Include or not setting out information
			spacing (float): Setting out spacing
			verticalOrigin (str): Vertical origin
			horizontalOrigin (str): Horizontal origin
		Returns:
			IFPrestressChapter: 
		"""
		pass


	def setAssignmentIndexes(self, indexes) -> IFPrestressChapter:
		r"""
		Set the indexes of the assignments that wish to be displayed 
		Params:
			indexes (array of ints): 
		Returns:
			IFPrestressChapter: 
		"""
		pass


class IFMeshAttr(IFAttribute):
	"""
	Mesh attribute. 'rows' of a mesh attribute represent the number of element names defined. So, if addElementName has been called only once, only 'row' 0 is valid 
	"""

	def addElementName(self, elementName) -> IFMeshAttr:
		r"""
		Adds another element type to this attribute Most mesh attributes will only store one element type, e.g. "HX20", however, in a coupled analysis, it is possible to add a thermal equivalent, e.g. "HF20" 
		Params:
			elementName (str): 
		Returns:
			IFMeshAttr: 
		"""
		pass


	def getElementNames(self) -> list[str]:
		r"""
		Fetches an array of all the element types in this attribute Most mesh attributes will only store one element type, e.g. "HX20", however, in a coupled analysis, it is possible to have structural and thermal equivalents, e.g. "HX20" and "HF20" 
		Returns:
			array of strs: Returned array of names
		"""
		pass


	def setSingleFeatureAssignType(self, isSingleJointType) -> IFMeshAttr:
		r"""
		Set the "single feature mesh assignment" type for the separation and insertion of joint or interface elements between geometry objects 
		Params:
			isSingleJointType (bool): 
		Returns:
			IFMeshAttr: 
		"""
		pass


class IFMeshPoint(IFMeshAttr):
	"""
	point mesh attribute 
	"""

	pass


class IFPointSpacingMeshAttr(IFMeshPoint):
	"""
	 
	"""

	pass


class IFPointElementMeshAttr(IFMeshPoint):
	"""
	 
	"""

	pass


class IFMeshLine(IFMeshAttr):
	"""
	line mesh attribute 
	"""

	def setEndRelease(self, whichEnd, dof, releaseType, fixityValue=None) -> IFMeshLine:
		r"""
		Sets a line-end release 
		Params:
			whichEnd (str): 'Start' or 'End' - which end of the line to modify
			dof (str): degree of freedom: 'u','v','w','thx','thy','thz'
			releaseType (str): end release type, free, restained, or constrained
			fixityValue (float, optional): fixity value for partial fixity end release types
		Returns:
			IFMeshLine: 
		"""
		pass


	def setEndReleasesSameAsStart(self, isSame) -> IFMeshLine:
		r"""
		Call to specify that (in the dialog) the 'end' of the line has the same releases as the 'start'. Note that calling this function will have have no effect on prior calls to IFMeshLine.setEndRelease() - it only affects subsequent calls. 
		Params:
			isSame (bool): 
		Returns:
			IFMeshLine: 
		"""
		pass


	def setEndRigidZoneSameAsStart(self, isSame) -> IFMeshLine:
		r"""
		Call to specify that (in the dialog) the 'end' of the line has the same rigid zone data as the 'start'. Note that calling this function will have have no effect on prior calls to IFMeshLine.setRigid() - it only affects subsequent calls. 
		Params:
			isSame (bool): 
		Returns:
			IFMeshLine: 
		"""
		pass


	def setSize(self, element, size) -> IFMeshLine:
		r"""
		Sets up an irregular mesh. 
		Params:
			element (str): element name
			size (float): length of each element
		Returns:
			IFMeshLine: 
		"""
		pass


	def setNumber(self, element, nElements=None, ratio=None) -> IFMeshLine:
		r"""
		Sets up a mesh by number OR by transition 
		Params:
			element (str): element name
			nElements (int, optional): Number of elements (default = 0)
			ratio (float, optional): Ratio of first to last element sizes (default = 1.0)
		Returns:
			IFMeshLine: 
		"""
		pass


	def setSpacing(self, element) -> IFMeshLine:
		r"""
		Sets up a mesh by general spacing ratios 
		Params:
			element (str): element name
		Returns:
			IFMeshLine: 
		"""
		pass


	def addSpacing(self, nElements, spacing) -> IFMeshLine:
		r"""
		Adds an element spacing ratio (for mesh by general spacing ratios). 
		Params:
			nElements (int): number of elements
			spacing (float): relative spacing
		Returns:
			IFMeshLine: 
		"""
		pass


	def setRigid(self, whichEnd, rigidType, includeMass=None, rigidZoneFactor=None, rigidValue1=None, rigidValue2=None) -> IFMeshLine:
		r"""
		define rigid end zone data at the specified end of the line 
		Params:
			whichEnd (str): 'Start' or 'End' - which end of the line to modify
			rigidType (str): rigid end zone type
			includeMass (bool, optional): include or exclude density from the rigid end zone element
			rigidZoneFactor (float, optional): rigid end zone element rigid zone factor
			rigidValue1 (float, optional): rigid end zone element length or "factor A"
			rigidValue2 (float, optional): rigid end zone element "factor B"
		Returns:
			IFMeshLine: 
		"""
		pass


	def setReleaseType(self, whichEnd, type) -> IFMeshLine:
		r"""
		set the end release type. Note that "pinned" is a cosmetic dialog concept, it is still necessary to call IFMeshLine.setEndRelease with the appropriate freedoms 
		Params:
			whichEnd (str): 'Start' or 'End' - which end of the line to modify
			type (str): end releases type "pinned", "fixed" "specified" or "joint"
		Returns:
			IFMeshLine: 
		"""
		pass


	def getMeshDivisions(self, pType) -> object:
		r"""
		Return the mesh spacing. Operation is best described by an example, as below 
		Params:
			pType (int): type code
		Returns:
			float: array depending on the value of pType
		"""
		pass


	def getEndRelease(self, whichEnd, whichDof, fixityValue=None) -> int:
		r"""
		
		Params:
			whichEnd (str): 'Start' or 'End' - which end to query
			whichDof (str): degree of freedom: 'u','v','w','thetax','thetay','thetaz'
			fixityValue (float, optional): fixity value for partial fixity end release types
		Returns:
			int: release type 0 = free, 1 = restrained, 2 = continuous
		"""
		pass


	def setFixityFactorLengthType(self, type, length=None) -> IFMeshLine:
		r"""
		Choose the length which will be used to compute the fixity factor 
		Params:
			type (str): "line", "combined line" or "user defined"
			length (float, optional): Only used when the type is "user defined"
		Returns:
			IFMeshLine: 
		"""
		pass


	def setParasiticType(self, type, meshingType=None) -> IFMeshLine:
		r"""
		set the parasitic element type 
		Params:
			type (str): "reinforcement"
			meshingType (str, optional): , allow or fill gaps along parasitic line
		Returns:
			IFMeshLine: 
		"""
		pass


	def removeParasiticSpacing(self) -> IFMeshLine:
		r"""
		remove all parasitic mesh spacing 
		Returns:
			IFMeshLine: 
		"""
		pass


	def setParasiticMinimumNumber(self, number) -> IFMeshLine:
		r"""
		set the number of parasitic elements 
		Params:
			number (int): 
		Returns:
			IFMeshLine: 
		"""
		pass


	def setParasiticMaximumLength(self, length) -> IFMeshLine:
		r"""
		set the parasitic element maximum length 
		Params:
			length (float): 
		Returns:
			IFMeshLine: 
		"""
		pass


	def setParasiticMaximumAngle(self, angleDegs) -> IFMeshLine:
		r"""
		set the parasitic element maximum angle between adjacent elements 
		Params:
			angleDegs (float): 
		Returns:
			IFMeshLine: 
		"""
		pass


	def setParasiticMaxPercentDeviation(self, percentDeviation) -> IFMeshLine:
		r"""
		set the parasitic element maximum (deviation * 100 / length) from line 
		Params:
			percentDeviation (float): 
		Returns:
			IFMeshLine: 
		"""
		pass


class IFMeshSurface(IFMeshAttr):
	"""
	surface mesh attribute 
	"""

	def setRegular(self, element, xDivisions=None, yDivisions=None, transition=None) -> IFMeshSurface:
		r"""
		Sets up a mesh by number. 
		Params:
			element (str): element name
			xDivisions (int, optional): Number of elements in local X direction (if unspecified, follows child lines) (default = 0)
			yDivisions (int, optional): Number of elements in local Y direction (if unspecified, follows child lines) (default = 0)
			transition (bool, optional): Allowing transition mesh patterns? (default = FALSE)
		Returns:
			IFMeshSurface: 
		"""
		pass


	def setRegularSize(self, element, size, transition=None) -> IFMeshSurface:
		r"""
		Sets up a mesh by size. 
		Params:
			element (str): element name
			size (float): element size
			transition (bool, optional): Allowing transition mesh patterns? (default = FALSE)
		Returns:
			IFMeshSurface: 
		"""
		pass


	def setIrregular(self, element, size, quadAngle=None, sizeMultiplier=None, edgeDeviation=None) -> IFMeshSurface:
		r"""
		Sets up an irregular mesh. 
		Params:
			element (str): element name
			size (float): element size
			quadAngle (float, optional): Minimum allowable angle for quadrilateral elements (default = 0.0)
			sizeMultiplier (float, optional): Limiting factor for rate of change of element size
			edgeDeviation (float, optional): maximum allowable deviation from surface of any edge
		Returns:
			IFMeshSurface: 
		"""
		pass


	def isRegular(self) -> bool:
		r"""
		Returns true is the surface mesh is regular 
		Returns:
			bool: return
		"""
		pass


class IFMeshVolume(IFMeshAttr):
	"""
	volume mesh attribute 
	"""

	def setRegular(self, element, xDivisions=None, yDivisions=None, zDivisions=None, transition=None) -> IFMeshVolume:
		r"""
		Sets up a regular mesh. 
		Params:
			element (str): element name
			xDivisions (int, optional): Number of elements in local X direction (if unspecified, follows child lines) (default = 0)
			yDivisions (int, optional): Number of elements in local Y direction (if unspecified, follows child lines) (default = 0)
			zDivisions (int, optional): Number of elements in local Z direction (if unspecified, follows child lines) (default = 0)
			transition (bool, optional): Allowing transition mesh patterns? (default = FALSE)
		Returns:
			IFMeshVolume: 
		"""
		pass


	def setIrregular(self, element, size, edgeDeviation=None) -> IFMeshVolume:
		r"""
		Sets up an irregular mesh. 
		Params:
			element (str): element name
			size (float): element size
			edgeDeviation (float, optional): maximum allowable deviation from defining surfaces of any edge
		Returns:
			IFMeshVolume: 
		"""
		pass


class IFMeshPhreatic(IFMeshAttr):
	"""
	phreatic mesh attribute 
	"""

	pass


class IFLocalCoord(IFAttribute):
	"""
	 
	"""

	def getXVector(self) -> list[float]:
		r"""
		 
		Returns:
			array of float: The vector as an array of three numbers
		"""
		pass


	def getYVector(self) -> list[float]:
		r"""
		 
		Returns:
			array of float: The vector as an array of three numbers
		"""
		pass


	def getZVector(self) -> list[float]:
		r"""
		 
		Returns:
			array of float: The vector as an array of three numbers
		"""
		pass


	def getOrigin(self) -> list[float]:
		r"""
		 
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates The returned position
		"""
		pass


	def visualiseDefn(self, isVisualise) -> None:
		r"""
		 
		Params:
			isVisualise (bool): 
		Returns:
			None: 
		"""
		pass


	def globalToLocal(self, X, Y=None, Z=None) -> None:
		r"""
		Converts the given global coordinates into the local coordinate space of this attribute 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def localToGlobal(self, X, Y=None, Z=None) -> None:
		r"""
		Converts the given coordinates from the local coordinate space of this attribute into global coordinates 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def setAxesType(self, type) -> IFLocalCoord:
		r"""
		Sets the axes type, e.g cartesian, z cylindrical etc from the given string 
		Params:
			type (str): 
		Returns:
			IFLocalCoord: 
		"""
		pass


	def getAxesDimensionality(self, pX, pY, pZ) -> None:
		r"""
		Return the dimensionality of the 3 ordinates of this local coord. 
		Params:
			pX (int): The dimensionality of the x coord
			pY (int): The dimensionality of the Y coord
			pZ (int): The dimensionality of the z coord
		Returns:
			None: 
		"""
		pass


	def getAxesType(self) -> str:
		r"""
		retrieves the axes type, e.g cartesian, z cylindrical etc from the given string 
		Returns:
			str: 
		"""
		pass


class IFPlanarRotationCartLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFPlanarRotationCylLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFPlanarRotationSphLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFGenRotationCartLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFGenRotationCylLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFGenRotationSphLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFScaleCartLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFScaleCylLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFScaleSphLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFSurfaceAxesLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFBeamAxesLocalAttr(IFLocalCoord):
	"""
	 
	"""

	pass


class IFTransformationAttr(IFAttribute):
	"""
	 
	"""

	def setSweepType(self, sweepType) -> IFTransformationAttr:
		r"""
		Sets the sweep type, e.g minorArc, majorArc, straight from the given string 
		Params:
			sweepType (str): 
		Returns:
			IFTransformationAttr: 
		"""
		pass


	def setHofType(self, hofType) -> IFTransformationAttr:
		r"""
		Sets the order of the geometry objects to be created e.g. line, surface, volume from the given string 
		Params:
			hofType (str): 
		Returns:
			IFTransformationAttr: 
		"""
		pass


	def setNumberCopies(self, numberCopies) -> IFTransformationAttr:
		r"""
		Sets the number of copies 
		Params:
			numberCopies (int): 
		Returns:
			IFTransformationAttr: 
		"""
		pass


class IFPlanarRotationTransAttr(IFTransformationAttr):
	"""
	 
	"""

	pass


class IFGenRotationTransAttr(IFTransformationAttr):
	"""
	 
	"""

	pass


class IFScaleTransAttr(IFTransformationAttr):
	"""
	 
	"""

	pass


class IFTranslationTransAttr(IFTransformationAttr):
	"""
	 
	"""

	pass


class IFMirrorPlaneTransAttr(IFTransformationAttr):
	"""
	 
	"""

	pass


class IFScreenMirrorTransAttr(IFTransformationAttr):
	"""
	An attribute which dynamically determines a mirror plane from the current (at time of use) screen rotation and selection, and the direction specified as part of its definition 
	"""

	def setScreenMirror(self, type, lineID=None) -> None:
		r"""
		Sets the direction of the mirror. E.g. a type of "left" creates a vertical plane, perpendicular to the screen, located at the leftmost coordinate of the selection. Any subsequent change to the screen rotation or selection automatically updates this attribute to match. Similarly for top, right and bottom. In these cases, the optional line id should be omitted. Alternatively "line" may be used, in which case the line ID is expected. In this case a plane in constructed perpendicular to both the line and screen. The line must be straight 
		Params:
			type (str or int): direction
			lineID (IFLine, optional): 
		Returns:
			None: 
		"""
		pass


class IFCompoundTransAttr(IFTransformationAttr):
	"""
	 
	"""

	def add(self, transAttr) -> IFCompoundTransAttr:
		r"""
		 
		Params:
			transAttr (IFTransformationAttr): The name or ID of a transformation, or a pointer to a IFTransformationAttr object. The transformation to add
		Returns:
			IFCompoundTransAttr: 
		"""
		pass


	def remove(self, transAttr) -> IFCompoundTransAttr:
		r"""
		 
		Params:
			transAttr (IFTransformationAttr): The name or ID of a transformation, or a pointer to a IFTransformationAttr object. The transformation to remove
		Returns:
			IFCompoundTransAttr: 
		"""
		pass


class IFAboutAxisTransAttr(IFTransformationAttr):
	"""
	 
	"""

	pass


class IFVariationAttr(IFAttribute):
	"""
	 
	"""

class IFDataset(IFAttribute):
	"""
	graph dataset attribute 
	"""

	def setValues(self, dataVec) -> IFDataset:
		r"""
		Sets the array of numbers representing the curve. 
		Params:
			dataVec (array of float): array of numbers representing the curve, initialised as in: Redim data(1) : data(0)=0 : data(1)=2
		Returns:
			IFDataset: 
		"""
		pass


	def printToGrid(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def exportToFile(self, filename, append) -> None:
		r"""
		Export this graph dataset to the given filename in csv format optionally appending to the existing contents of the file 
		Params:
			filename (str): File to modify
			append (bool): If false, file will be emptied before writing begins
		Returns:
			None: 
		"""
		pass


	def getValues(self) -> list[float]:
		r"""
		 
		Returns:
			array of float: array of numbers representing the curve
		"""
		pass


	def getSize(self) -> int:
		r"""
		 
		Returns:
			int: 
		"""
		pass


class IFPSD(IFAttribute):
	"""
	PSD dataset attribute 
	"""

	def setPSD(self, logAmplitude, logFreq) -> IFPSD:
		r"""
		Sets the log flags. 
		Params:
			logAmplitude (bool): boolean: is amplitude given as log?
			logFreq (bool): boolean: is frequency given as log?
		Returns:
			IFPSD: 
		"""
		pass


	def addRow(self, frequency, amplitude) -> IFPSD:
		r"""
		Adds a row of frequency vs amplitude data 
		Params:
			frequency (float): frequency at which amplitude applies
			amplitude (float): value of the response at a given frequency
		Returns:
			IFPSD: 
		"""
		pass


class IFPedestrianLoadDefinition(IFAttribute):
	"""
	Pedestrian Load Definition attribute 
	"""

	def updateAnalyses(self) -> None:
		r"""
		Must be called after this object has been fully defined Tells modeller to update any IFPedestrianMovingLoadAnalysis objects that are using this definition. 
		Returns:
			None: 
		"""
		pass


class IFSpectralCurve(IFPSD):
	"""
	Spectral response dataset attribute 
	"""

	def setSpectralCurve(self, percentDamping, ordinate, abscissa) -> IFSpectralCurve:
		r"""
		Sets up a spectral response dataset attribute 
		Params:
			percentDamping (float): percentage damping
			ordinate (str): 'displacement', 'velocity', 'acceleration'
			abscissa (str): 'frequency', 'period'
		Returns:
			IFSpectralCurve: 
		"""
		pass


class IFVariationField(IFVariationAttr):
	"""
	field variation attribute 
	"""

	def setField(self, function, localAttr) -> IFVariationField:
		r"""
		Sets the function expression and coord set. Also unsets all limits. 
		Params:
			function (str): any expression that evaluates to a number, e.g. '4','3+4x','y'. Note all numbers must be in US English, i.e. "1.2", not the current locale (e.g. Italian/Swedish/French "1,2")
			localAttr (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object. local coordinate set in which function and limits are given
		Returns:
			IFVariationField: 
		"""
		pass


	def setCoordsType(self, type) -> IFVariationField:
		r"""
		Sets the local coord type w.r.t the variation 
		Params:
			type (str): 'variation' or 'geometry'
		Returns:
			IFVariationField: 
		"""
		pass


class IFVariationLine(IFVariationAttr):
	"""
	line variation attribute 
	"""

	def setFunction(self, distType) -> IFVariationLine:
		r"""
		Sets the distance type. 
		Params:
			distType (str): 'actual' or 'parametric' : determines how variable u is interpreted
		Returns:
			IFVariationLine: 
		"""
		pass


	def addRow(self, function) -> IFVariationLine:
		r"""
		Adds a row to this equally spaced line variation 
		Params:
			function (str): any expression that evaluates to a number, e.g. '4','3+4x','y'. Note all numbers must be in US English, i.e. "1.2", not the current locale (e.g. Italian/Swedish/French "1,2")
		Returns:
			IFVariationLine: 
		"""
		pass


	def addRowUnequal(self, distance, function) -> IFVariationLine:
		r"""
		Adds a row to this unequally spaced line variation 
		Params:
			distance (float): distance
			function (str): any expression that evaluates to a number, e.g. '4','3+4x','y'. Note all numbers must be in US English, i.e. "1.2", not the current locale (e.g. Italian/Swedish/French "1,2")
		Returns:
			IFVariationLine: 
		"""
		pass


class IFInterpolationVariation(IFVariationLine):
	"""
	interpolated line variation attribute 
	"""

	pass


class IFVariationSurface(IFVariationAttr):
	"""
	surface variation attribute 
	"""

	def setFunction(self, function) -> IFVariationSurface:
		r"""
		Sets the function expression. Also unsets all limits. 
		Params:
			function (str or float): any expression that evaluates to a number, e.g. 4,"3+4u","v". Note all numbers must be in US English, i.e. "1.2", not the current locale (e.g. Italian/Swedish/French "1,2")
		Returns:
			IFVariationSurface: 
		"""
		pass


class IFVariationBoundary(IFVariationAttr):
	"""
	surface boundary variation attribute 
	"""

	def setBoundary(self, boundary) -> IFVariationBoundary:
		r"""
		Sets the array of line objects forming the boundary. 
		Params:
			boundary (array of objects): array of line variations
		Returns:
			IFVariationBoundary: 
		"""
		pass


class IFVariationGrid(IFVariationAttr):
	"""
	surface grid variation attribute 
	"""

	def setGrid(self, matrix, xOrder=None, yOrder=None) -> IFVariationGrid:
		r"""
		 
		Params:
			matrix (array of float): 2D grid of values
			xOrder (str, optional): 'Constant','linear','quadratic','cubic'. If unspecified, calculated from grid size (default = '')
			yOrder (str, optional): 'Constant','linear','quadratic','cubic'. If unspecified, calculated from grid size (default = '')
		Returns:
			IFVariationGrid: 
		"""
		pass


class IFVariationFactored(IFVariationAttr):
	"""
	factored variation attribute 
	"""

	def setFactored(self, factor, variationAttr) -> IFVariationFactored:
		r"""
		Sets the variation factor/multiplier. 
		Params:
			factor (float): numerical multiplier
			variationAttr (IFVariationAttr): The name or ID of a variation, or a pointer to a IFVariationAttr object.
		Returns:
			IFVariationFactored: 
		"""
		pass


class IFProfileVariation(IFVariationAttr):
	"""
	profile set variation attribute 
	"""

	def setDirectionType(self, type, localCoords=None) -> IFProfileVariation:
		r"""
		Set the variation direction 
		Params:
			type (str): direction type
			localCoords (IFLocalCoord, optional): The name or ID of a localcoord, or a pointer to a IFLocalCoord object. local coordinate set if the type is a local coordinate type
		Returns:
			IFProfileVariation: 
		"""
		pass


	def setOutOfRangeType(self, before, type) -> IFProfileVariation:
		r"""
		set the out of range evaluation type 
		Params:
			before (booelan): true for before, false for after
			type (str): out of range evaluation type
		Returns:
			IFProfileVariation: 
		"""
		pass


	def addProfile(self, origin, profile) -> IFProfileVariation:
		r"""
		add a profile to the set 
		Params:
			origin (array of float): An array of 3 real numbers, representing 3d coordinates Coordinates of point in plane
			profile (IFInterpolationVariation): The name or ID of a variation, or a pointer to a IFInterpolationVariation object. profile variation
		Returns:
			IFProfileVariation: 
		"""
		pass


class IFGeometric(IFAttribute):
	"""
	 
	"""

	def setTransparent(self, isTrans) -> IFAttribute:
		r"""
		Mark this attribute as drawing in the current window as transparent (false for opaque). Note that this setting has no effect unless the view is allowing transparency with IFView.allowTransparency 
		Params:
			isTrans (bool): 
		Returns:
			IFAttribute: 
		"""
		pass


	def isTransparent(self) -> bool:
		r"""
		return true if this attribute has been marked as drawing transparent in the current window (false for opaque) 
		Returns:
			bool: 
		"""
		pass


class IFGeometricLine(IFGeometric):
	"""
	Setup beam geometric attribute 
	"""

	def setBeam(self, A, Iyy, Izz, Iyz, J, Asz, Asy, ey=None, ez=None, section=None) -> IFGeometricLine:
		r"""
		Specifies the defining parameters of this beam, with the values given at the beam axis. This function can be used for attributes which are assigned to lines meshed with all element types except axisymmetric and grillage. 
		Params:
			A (IFVariationAttr or float): cross-sectional area
			Iyy (object): {I'yy}<realvariation> second moment of area about local y axis
			Izz (object): {I'zz}<realvariation> second moment of area about local z axis
			Iyz (object): {I'yz}<realvariation> product moment of inertia
			J (object): {J'}<realvariation> torsion constant
			Asz (IFVariationAttr or float): shear area on local yz plane in z direction
			Asy (IFVariationAttr or float): shear area on local yz plane in y direction
			ey (IFVariationAttr or float, optional): eccentricity in y direction
			ez (IFVariationAttr or float, optional): eccentricity in z direction
			section (int, optional): Index of section for which the properties are set (e.g. for linear tapered, 0 for first end, 1 for second end); default is 0
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setNumberOfSections(self, nSections) -> IFGeometricLine:
		r"""
		Specifies the number of sections used to define the shape of the beam (1 = non-tapered, 2 = linear tapered, n = general tapered) 
		Params:
			nSections (int): 
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setDefinitionPath(self, pPath) -> IFGeometricLine:
		r"""
		Specifies the path that will be followed when this attribute's distance type is 'choose path at definition' For other distance types, this path will be ignored 
		Params:
			pPath (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getDefinitionPath(self) -> IFReferencePath:
		r"""
		Returns the path that will be followed when this attribute's distance type is 'choose path at definition' For other distance types, this path will be undefined 
		Returns:
			IFReferencePath: 
		"""
		pass


	def setElementType(self, uiName) -> IFGeometricLine:
		r"""
		Sets the element type for which this attribute is intended. It will subsequently be an error to assign this attribute to a line meshed with a different element type, unless the element type given is '3d thick beam', in which case assignment is allowed to any element. 
		Params:
			uiName (str): "Bar/Link", "Grillage", "2d Thin Beam", "2d Thick Beam", "3d Thin Beam", "3d Thick Beam", "3d Thick Beam (BMS3)", "Axisymmetric plate/shell" or "Cross Section Beam"
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setAxiSymmetric(self, t) -> IFGeometricLine:
		r"""
		Sets the thickness for axisymmetric membrane/shell 
		Params:
			t (IFVariationAttr or float): Thickness
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setPlaneStrain(self, t) -> IFGeometricLine:
		r"""
		Sets the thickness for plane strain beam 
		Params:
			t (IFVariationAttr or float): Thickness
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setAspcThickness(self, t) -> IFGeometricLine:
		r"""
		Sets the thickness specifically for use in the APSC model 
		Params:
			t (IFVariationAttr or float): Thickness
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setPlaneStress(self, t) -> IFGeometricLine:
		r"""
		Sets the thickness for plane stress interface 
		Params:
			t (IFVariationAttr or float): Thickness
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setCrossSection(self) -> IFGeometricLine:
		r"""
		Sets up a cross sectional line geometric attribute 
		Returns:
			IFGeometricLine: 
		"""
		pass


	def addSectionQuad(self, lowerLeftZ, lowerLeftY, upperLeftZ, upperLeftY, upperRightZ, upperRightY, lowerRightZ, lowerRightY, NewtonCotes12=None, NewtonCotes14=None, section=None, quadType=None, isTriangle=None, quadFillType=None, haveModularRatio=None, modularRatio=None, haveWarpingData=None, lowerLeftWarp=None, lowerLeftWarpY=None, lowerLeftWarpZ=None, upperLeftWarp=None, upperLeftWarpY=None, upperLeftWarpZ=None, upperRightWarp=None, upperRightWarpY=None, upperRightWarpZ=None, lowerRightWarp=None, lowerRightWarpY=None, lowerRightWarpZ=None) -> IFGeometricLine:
		r"""
		Add a quadrilateral/triangle to a specified section of this beam. The quadrilateral/triangles, when added together, make up the shape of the section 
		Params:
			lowerLeftZ (float): Z coords of corner 1 of one quadrilateral section of cross-section
			lowerLeftY (float): Y coords of corner 1 of one quadrilateral section of cross-section
			upperLeftZ (float): Z coords of corner 2 of one quadrilateral section of cross-section
			upperLeftY (float): Y coords of corner 2 of one quadrilateral section of cross-section
			upperRightZ (float): Z coords of corner 3 of one quadrilateral section of cross-section, same as upperLeftZ for triangle
			upperRightY (float): Y coords of corner 3 of one quadrilateral section of cross-section, same as upperRightY for triangle
			lowerRightZ (float): Z coords of corner 4 of one quadrilateral section of cross-section
			lowerRightY (float): Y coords of corner 4 of one quadrilateral section of cross-section
			NewtonCotes12 (int, optional): number of Newton-Coates integration points in Z direction (default =0)
			NewtonCotes14 (int, optional): number of Newton-Coates integration points in Y direction (default =0)
			section (int, optional): Index of section to which the quad should be added (e.g. for linear tapered, 0 for first end, 1 for second end); default is 0
			quadType (str, optional): string describing how this quad was defined
			isTriangle (bool, optional): true for triangle, false for quadrilaterial
			quadFillType (str, optional): string describing which part of the section this quad defines
			haveModularRatio (bool, optional): true if modular ratio is known, else false
			modularRatio (float, optional): modular ratio, only used if "haveModularRatio" is true
			haveWarpingData (bool, optional): T if warping data are known, else F
			lowerLeftWarp (float, optional): warping of corner 1
			lowerLeftWarpY (float, optional): warping y-gradient of corner 1
			lowerLeftWarpZ (float, optional): warping z-gradient of corner 1
			upperLeftWarp (float, optional): warping of corner 2
			upperLeftWarpY (float, optional): warping y-gradient of corner 2
			upperLeftWarpZ (float, optional): warping z-gradient of corner 2
			upperRightWarp (float, optional): warping of corner 3
			upperRightWarpY (float, optional): warping y-gradient of corner 3
			upperRightWarpZ (float, optional): warping z-gradient of corner 3
			lowerRightWarp (float, optional): warping of corner 4
			lowerRightWarpY (float, optional): warping y-gradient of corner 4
			lowerRightWarpZ (float, optional): warping z-gradient of corner 4
		Returns:
			IFGeometricLine: 
		"""
		pass


	def removeAllSectionQuads(self, section=None) -> IFGeometricLine:
		r"""
		Removes all quads from a specified section of this beam 
		Params:
			section (int, optional): section for which to remove quads (default is 0)
		Returns:
			IFGeometricLine: 
		"""
		pass


	def addFibre(self, fibreName, localCoordz, localCoordy, section=None, isUserDefined=None, fillType=None) -> IFGeometricLine:
		r"""
		Adds a new beam fibre location to a specified section of this beam 
		Params:
			fibreName (str): Identifies the new fibre
			localCoordz (float): The local z coordinate of the fibre
			localCoordy (float): The local y coordinate of the fibre
			section (int, optional): section for which the  fibre is set (default is 0)
			isUserDefined (bool, optional): true if user edited the calculated location (default is false)
			fillType (str, optional): string describing which part of the section this fibre defines
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getFibreNames(self) -> list:
		r"""
		Returns the cross section beam fibres from this object 
		Returns:
			array: Array of fibre names
		"""
		pass


	def getFibrePosition(self, fibreName, localCoordz, localCoordy, section=None) -> None:
		r"""
		Returns a cross section beam fibre position from a specified section of this beam 
		Params:
			fibreName (str): Identifies the fibre
			localCoordz (float): The returned local z coordinate of the fibre
			localCoordy (float): The returned local y coordinate of the fibre
			section (int, optional): section for which the fibre is set (default is 0)
		Returns:
			None: 
		"""
		pass


	def removeFibres(self, section=None) -> IFGeometricLine:
		r"""
		Removes all cross section beam fibres from this beam 
		Params:
			section (int, optional): section for which to remove fibres (default is 0)
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setLibNames(self, section, libraryName, libraryType, sectionName) -> IFGeometricLine:
		r"""
		Sets the section library, type and name for a specified section within this beam. Only used for sections created from a library. 
		Params:
			section (int): section being defined
			libraryName (str): library name
			libraryType (str): library type
			sectionName (str): section name
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setRotateFlag(self, section, rotatedFlag) -> IFGeometricLine:
		r"""
		Sets the rotation at the specified end 
		Params:
			section (int): section being defined
			rotatedFlag (int): 0=unrotated, 1=90degrees, 2=180degrees, 3=270degrees
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getRotateFlag(self, section) -> int:
		r"""
		Gets the rotation at the specified end 
		Params:
			section (int): section row number
		Returns:
			int: 0=unrotated, 1=90degrees, 2=180degrees, 3=270degrees
		"""
		pass


	def setMirrorFlag(self, section, mirroredFlag) -> IFGeometricLine:
		r"""
		Sets the mirroring at the specified end 
		Params:
			section (int): section being defined
			mirroredFlag (int): 0=none, 1=about Y-Y axis, 2=about Z-Z axis
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getMirrorFlag(self, section) -> int:
		r"""
		Gets the mirroring at the specified end 
		Params:
			section (int): section row number
		Returns:
			int: 0=none, 1=about Y-Y axis, 2=about Z-Z axis
		"""
		pass


	def setVerticalAlignment(self, vAlign) -> IFGeometricLine:
		r"""
		Sets the vertical alignment of the beam ends 
		Params:
			vAlign (float or str): offset value or type
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setHorizontalAlignment(self, hAlign) -> IFGeometricLine:
		r"""
		Sets the horizontal alignment of the beam ends 
		Params:
			hAlign (float or str): offset value or type
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setAlignmentSection(self, section) -> IFGeometricLine:
		r"""
		Sets the section to which all others are aligned 
		Params:
			section (int): section being defined
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setSectionName(self, name, section) -> IFGeometricLine:
		r"""
		Sets the name for a section in tapered sections 
		Params:
			name (str): name for this row
			section (int): section being defined
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setInterpolation(self, shapeInterpolation, distance, section, pFunctionValue=None) -> IFGeometricLine:
		r"""
		Sets the section shape interpolation and distance for a section 
		Params:
			shapeInterpolation (str): shape interpolation
			distance (float): distance to section
			section (int): section being defined
			pFunctionValue (float, optional): order value when shapeInterpolation is 'Function'
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setStandardSection(self, shapeName, dimensionNames, dimensions, section=None) -> IFGeometricLine:
		r"""
		Sets the shape, dimension names, and dimension values of the specified section e.g. "SHS", "B" and "D", for solid hollow section. If the beam is tapered, this function must be called once for each section, 
		Params:
			shapeName (str): 
			dimensionNames (array of str): 
			dimensions (array of floats): 
			section (int, optional): section to which the quad should be added (default is 0)
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setMultipleVarying(self, bMultipleVarying) -> IFGeometricLine:
		r"""
		Sets the subtype for the geometric line to a multiple varying section 
		Params:
			bMultipleVarying (bool): Multiple Varying section flag
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setSpecifyInterp(self, bSpecifyInterp) -> IFGeometricLine:
		r"""
		specify whether or not the shape interpolation is specified for general sections if 'FALSE' a spline interpolation is used on all specified sections 
		Params:
			bSpecifyInterp (bool): Specify interpolation order flag
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setEqualSpacing(self, bEqualSpacing) -> IFGeometricLine:
		r"""
		specify whether or not the distances for general sections are specified if 'FALSE' all specified sections are assumed to be spaced evenly 
		Params:
			bEqualSpacing (bool): Equal Spacing flag
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setSymmetry(self, bSymmetry) -> IFGeometricLine:
		r"""
		specify that a general section is symmetric about its mid-point therefore allowing only the first half of the sections to be entered 
		Params:
			bSymmetry (bool): Symmetric section flag
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setDistanceType(self, distanceType) -> IFGeometricLine:
		r"""
		determines how distances between the sections for a general tapered section are specified 
		Params:
			distanceType (str): distance type
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getBoundsAtNormalisedPosition(self, nrmCoordOnLine, lineID, yMax, yMin, zMin, zMax, ey, ez) -> None:
		r"""
		Returns the bounding rectangle of this section. A normalised coordinate is needed for tapering sections - use 0 for non-tapering sections. For multi-varying sections that are set to 'follow path', a line ID must also be passed in, so that the path coordinates (chainage) can be calculated. For all other sections, the line ID is optional. For any kind section, if a line ID is passed in, the eccentricity of the section at the given location will also be calculated and returned. If the line is given as 'nothing', the eccentricity cannot be calculated, and will be returned as 0 
		Params:
			nrmCoordOnLine (float): normalised coord w.r.t the line
			lineID (str or int): name or ID of line
			yMax (float): top coord relative to centroid
			yMin (float): bottom coord relative to centroid
			zMin (float): left coord relative to centroid
			zMax (float): right coord relative to centroid
			ey (float): eccentricity of section
			ez (float): eccentricity of section
		Returns:
			None: 
		"""
		pass


	def getSectionQuads(self, section, quadCoords) -> None:
		r"""
		returns an array of coords P1, P2, P3, P4 for each quad in the cross section 
		Params:
			section (int): section row
			quadCoords (array): array (0..nSections-1) of array (0..nQuads-1) of array of 2 numbers (quad x and y)
		Returns:
			None: 
		"""
		pass


	def getSectionPerimeter(self, normalisedCoord, exteriorPerimeter, interiorPerimeter) -> None:
		r"""
		return section perimeters at the given position 
		Params:
			normalisedCoord (float): normalised coord 0 -> 1
			exteriorPerimeter (float): section exterior perimeter at position normalisedCoord
			interiorPerimeter (float): section interior (sum of holes) perimeter at position normalisedCoord
		Returns:
			None: 
		"""
		pass


	def getNumberOfSections(self) -> int:
		r"""
		Returns the number of sections used to define the shape of the beam (1 = non-tapered, 2 = linear tapered, n = general tapered) 
		Returns:
			int: 
		"""
		pass


	def exportSectionImage(self, filename, width, height, drawParam) -> str:
		r"""
		Creates an image file of the cross section. The file format is determined by the specified file extension, valid formats are BMP, PNG, JPG & GIF. 
		Params:
			filename (str): name of file to create
			width (int): image width
			height (int): image height
			drawParam (str): optional drawing parameter. 'Full', 'Icon', 'Shadow', 'Taper', 'SingleRow'
		Returns:
			str: on success, full path and name of file created
		"""
		pass


	def getDimensionNames(self) -> list:
		r"""
		Returns a list of the section dimension names for a standard section 
		Returns:
			array: Array of dimension names
		"""
		pass


	def setCompoundSection(self, material=None) -> IFGeometricLine:
		r"""
		Sets the subtype for the geometric line to a compound section 
		Params:
			material (str, optional): reference material attribute. If omitted, don't use modular ratios
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setCompoundPosition(self, section, horzThis, horzAlignTo, horzOther, vertThis, vertAlignTo, vertOther) -> IFGeometricLine:
		r"""
		Sets the relative position of a section within a compound section 
		Params:
			section (int): section being defined
			horzThis (str): horizontal position on this section
			horzAlignTo (int): index of section being aligned to, or 0 for align to coords
			horzOther (float or str): Position on other section, or coordinate
			vertThis (str): vertical position on this section
			vertAlignTo (int): index of section being aligned to, or 0 for align to coords
			vertOther (float or str): Position on other section, or coordinate
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setCompoundMaterial(self, section, material) -> IFGeometricLine:
		r"""
		Defines the material used to calculate modular ratio for each section 
		Params:
			section (int): section being defined
			material (str): material attribute
		Returns:
			IFGeometricLine: 
		"""
		pass


	def updateCompoundProperties(self) -> IFGeometricLine:
		r"""
		Calculates the compound section properties and quads from the component sections 
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setFromLibrary(self, libraryName, libraryType, sectionName, rotation, mirror, section=None) -> IFGeometricLine:
		r"""
		Imports a standard section from the library. Use instead of setBeam. 
		Params:
			libraryName (str): library name
			libraryType (str): library type
			sectionName (str or int): section name or index in CSV
			rotation (int): 0=unrotated, 1=90degrees, 2=180degrees, 3=270degrees
			mirror (int): 0=none, 1=about X-X axis, 2=about Y-Y axis
			section (int, optional): Index of section for which the properties are set (e.g. for linear tapered, 0 for first end, 1 for second end); default is 0
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setInfillSectionMaterials(self, material1, material2, materialAssigned, reductionFactor, section=None) -> IFGeometricLine:
		r"""
		Sets the materials to be used to calculate the properties of an 'infill & encased standard section' 
		Params:
			material1 (str): material attribute for steel section
			material2 (str): material attribute for encasement/infill
			materialAssigned (int): 1 or 2: material used in analysis
			reductionFactor (float): stiffness reduction factor applied to encasement/infill material
			section (int, optional): Index of section for which the properties are set (for compound sections); default is 0
		Returns:
			IFGeometricLine: 
		"""
		pass


	def defineSectionOutline(self, outlineDefn, section=None) -> IFGeometricLine:
		r"""
		defines the section outline for general parametric sections 
		Params:
			outlineDefn (array of str): outline definition from library file
			section (int, optional): section to which the outline should be added (default is 0)
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setReinforcement(self, attribute) -> IFGeometricLine:
		r"""
		Set the attribute that describes the reinforcement of a section of this attribute 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. reinforcement member line attribute
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getReinforcement(self) -> IFReinforcementLine:
		r"""
		Get the attribute that describes the reinforcement of a section of this attribute 
		Returns:
			IFReinforcementLine: 
		"""
		pass


	def countSubSections(self) -> int:
		r"""
		return the number of sub-sections defining this beam section, for example a back-to-back C section is two sub-sections, an infill section may be up to to three sub-sections 
		Returns:
			int: number of sub-sections
		"""
		pass


	def getTrimmingLoopCoordsAlongLine(self, subSectionIndex, line, normalisedCoord, nPointsPerTrimmingLoop, trimmingLoopCoords) -> int:
		r"""
		get the cooordinates defining the section trimming loops at a position alog a line to which this attribute is assigned 
		Params:
			subSectionIndex (int): index of the required sub-section
			line (name, line, IFLine): geometry line along which section is required
			normalisedCoord (float): normalise coordinate along the line 0 -> 1
			nPointsPerTrimmingLoop (array of int): number of points defining each section trimming loop, outer boundary first
			trimmingLoopCoords (array of float): x,y,x,y.. coords defining the section trimming loops, outer boundary first
		Returns:
			int: return error code, 0 = success
		"""
		pass


	def getTrimmingLoopCoords(self, subSectionIndex, normalisedCoord, nPointsPerTrimmingLoop, trimmingLoopCoords) -> int:
		r"""
		get the cooordinates defining the section trimming loops at the given normalised coordinate along this attribute 
		Params:
			subSectionIndex (int): index of the required sub-section
			normalisedCoord (float): normalise coordinate along the section, 0 -> 1
			nPointsPerTrimmingLoop (array of int): number of points defining each section trimming loop, outer boundary first
			trimmingLoopCoords (array of float): x,y,x,y.. coords defining the section trimming loops, outer boundary first
		Returns:
			int: return error code, 0 = success
		"""
		pass


	def getElementReinforcement(self, element, internalPoint, nrmCrd, sectionAttr, rebars, transverse=None) -> int:
		r"""
		get the reinforcement section definition at the given internal point and element 
		Params:
			element (name, element, IFElement): element
			internalPoint (int): internal point index
			nrmCrd (float): normalised coordinate along the beam
			sectionAttr (IFReinforcementSection): rebar section definition
			rebars (array of IFReinforcementSectionBar): objects
			transverse (IFTransverseReinforcement, optional): transverse reinforcement
		Returns:
			int: return error code, 0 = success
		"""
		pass


	def getNodeReinforcement(self, line, node, nrmCrd, sectionAttr, rebars, transverse=None) -> int:
		r"""
		get the reinforcement section definition at the given node on the line 
		Params:
			line (name, line, IFLine): geometry line
			node (name, node, IFNode): node
			nrmCrd (float): normalised coordinate along the beam
			sectionAttr (IFReinforcementSection): rebar section definition
			rebars (array of IFReinforcementSectionBar): objects
			transverse (IFTransverseReinforcement, optional): transverse reinforcement
		Returns:
			int: return error code, 0 = success
		"""
		pass


	def getInspectionReinforcement(self, line, inspection, index, nrmCrd, sectionAttr, rebars, transverse=None) -> int:
		r"""
		get the reinforcement section definition at the given inspection location on the line 
		Params:
			line (name, line, IFLine): geometry line
			inspection (name, inspection, IFInspectionLine): inspection location
			index (int): index
			nrmCrd (float): normalised coordinate along the beam
			sectionAttr (IFReinforcementSection): rebar section definition
			rebars (array of IFReinforcementSectionBar): objects
			transverse (IFTransverseReinforcement, optional): transverse reinforcement
		Returns:
			int: return error code, 0 = success
		"""
		pass


	def isInfill(self) -> bool:
		r"""
		return true if this is an infill section 
		Returns:
			bool: 
		"""
		pass


	def isCompound(self) -> bool:
		r"""
		return true if this is a compound section 
		Returns:
			bool: 
		"""
		pass


	def isSimpleTaper(self) -> bool:
		r"""
		return true if this is a linear taper between two section 
		Returns:
			bool: 
		"""
		pass


	def getSectionName(self, section) -> str:
		r"""
		return true if this is a linear taper between two section 
		Params:
			section (int): section index
		Returns:
			str: section name
		"""
		pass


	def isReinforcementValid(self, reason) -> bool:
		r"""
		Return True if the reinforcement that has been applied to this is valid, False otherwise. This method will assume valid reinforcement and will return True if no reinfocement has been applied to this 
		Params:
			reason (str): the reason that the reinforcement is invalid
		Returns:
			bool: 
		"""
		pass


	def setBridgeDeckSection(self, deckType, option) -> IFGeometricLine:
		r"""
		Sets the subtype for the geometric line to a bridge deck section 
		Params:
			deckType (str): Type of bridge deck
			option (str): Subtype option of bridge deck
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getBridgeDeckType(self) -> str:
		r"""
		Get the type of bridge deck attribute 
		Returns:
			str: Type of bridge deck. e.g. "not bridge deck", "RC slab", "Girder with slab"
		"""
		pass


	def getBridgeDeckSubType(self) -> str:
		r"""
		Get the subtype option of bridge deck attribute 
		Returns:
			str: Subtype option for bridge deck type
		"""
		pass


	def setSlabTreatment(self, slabTreatment) -> IFGeometricLine:
		r"""
		Sets whether the slab component of a bridge deck is cracked or uncracked 
		Params:
			slabTreatment (str): cracking option
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getSlabTreatment(self) -> str:
		r"""
		Gets whether the slab component of a bridge deck is cracked or uncracked 
		Returns:
			str: cracking option
		"""
		pass


	def setCrackedPropertiesMethod(self, method) -> IFGeometricLine:
		r"""
		Sets the cracked properties calculation method 
		Params:
			method (str): calculation method : "Approximate (ACI318)" or "From reinforcement"
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getCrackedPropertiesMethod(self) -> str:
		r"""
		Gets the cracked properties calculation method 
		Returns:
			str: calculation method : "Approximate (ACI318)" or "From reinforcement"
		"""
		pass


	def setGirderStiffeners(self, position, outstand, thickness) -> IFGeometricLine:
		r"""
		Sets which sides of the main girders have stiffeners in 'transverse slab with bracing', and their dimensions 
		Params:
			position (str): position: "Both sides of web", "Inside of web only", "Outside of web only"
			outstand (float): stiffener width
			thickness (float): stiffener thickness
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getGirderStiffeners(self, outstand, thickness) -> str:
		r"""
		Gets which sides of the main girders have stiffeners in 'transverse slab with bracing', and their dimensions 
		Params:
			outstand (float): stiffener width
			thickness (float): stiffener thickness
		Returns:
			str: position: "Both sides of web", "Inside of web only", "Outside of web only"
		"""
		pass


	def setTorsionConstant(self, method, girderWarping=None, paramValue=None) -> IFGeometricLine:
		r"""
		Sets the method to use to calculate torsion constant in a bridge deck 
		Params:
			method (str): method: 'Sum slab and girder' / 'Girder only' / 'Grillage slab' / 'User Defined'
			girderWarping (str, optional): warping approach for girder, if included: 'None' / 'NCHRP Report 725 Both ends' / 'NCHRP Report 725 One end'
			paramValue (float, optional): unbraced length if NCHRP seleced / J value if 'User Defined' selected
		Returns:
			IFGeometricLine: 
		"""
		pass


	def addBridgeDeckSlabA(self, b, t, diameter=None, spacing=None) -> IFGeometricLine:
		r"""
		Adds bridge deck slab dimensions to the beam (for RC/infill/transverse with bracing/shear key slab types) see also addBridgeDeckSlabB, addBridgeDeckSlabC, getBridgeDeckSlabA 
		Params:
			b (float): slab width
			t (float): slab thickness
			diameter (float, optional): hole diameter
			spacing (float, optional): spacing
		Returns:
			IFGeometricLine: 
		"""
		pass


	def addBridgeDeckSlabB(self, b, t, ys, bh, th, effWidth, row=None, distance=None) -> IFGeometricLine:
		r"""
		Adds bridge deck top slab dimensions to the beam (for girder with top slab) see also addBridgeDeckSlabA, addBridgeDeckSlabC,  getBridgeDeckSlabB 
		Params:
			b (float): slab width
			t (float): slab thickness
			ys (float): slab offset
			bh (float): haunch width
			th (float): haunch depth
			effWidth (float): slab effective width (set to -1 to use slab width)
			row (int, optional): in a varying slab, the row being added (Girder & Slab only)
			distance (float, optional): row distance
		Returns:
			IFGeometricLine: 
		"""
		pass


	def addBridgeDeckSlabC(self, b, D, tt, tb, type, tw=None, Wt=None, Wb=None, ot=None, ob=None) -> IFGeometricLine:
		r"""
		Adds bridge deck slab dimensions to the beam (for multicellular slab type) see also  addBridgeDeckSlabA, addBridgeDeckSlabB, getBridgeDeckSlabC 
		Params:
			b (float): width of one slab cell (longitudinal), between elements (transverse)
			D (float): overall slab thickness
			tt (float): top slab thickness
			tb (float): bottom slab thickness
			type (int): 0:long no flange offsets, 1:long with flange offsets, 2:transverse
			tw (float, optional): web width (longitudinal only)
			Wt (float, optional): average top flange width (longitudinal only)
			Wb (float, optional): average bottom flange width (longitudinal only)
			ot (float, optional): top flange offset (longitudinal only)
			ob (float, optional): bottom flange offset (longitudinal only)
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getBridgeDeckSlabA(self, b, h, diameter, spacing) -> None:
		r"""
		Gets bridge deck slab dimensions for RC/infill/transverse with bracing/shear key bridge deck slab types see also addBridgeDeckSlabA 
		Params:
			b (float): slab width
			h (float): slab thickness
			diameter (float): hole diameter
			spacing (float): hole spacing
		Returns:
			None: 
		"""
		pass


	def getTopSlabRowCount(self) -> int:
		r"""
		Gets the number of entires defining the slab in a Bridge Deck girder with top slab 
		Returns:
			int: 
		"""
		pass


	def getBridgeDeckSlabB(self, row, b, t, ys, bh, th, effWidth, distance) -> None:
		r"""
		Gets bridge deck slab dimensions for girder with top slab bridge deck slab type see also addBridgeDeckSlabB 
		Params:
			row (int): row number for tapered slabs
			b (float): slab width
			t (float): slab thickness
			ys (float): slab offset
			bh (float): haunch width
			th (float): haunch depth
			effWidth (float): slab effective width (set to -1 to use slab width, bcls)
			distance (float): row distance
		Returns:
			None: 
		"""
		pass


	def getBridgeDeckSlabC(self, b, D, tt, tb, type, tw, Wt, Wb, ot, ob) -> None:
		r"""
		Gets bridge deck slab dimensions for multicellular slab type see also addBridgeDeckSlabC 
		Params:
			b (float): width of one slab cell (longitudinal), between elements (transverse)
			D (float): overall slab thickness
			tt (float): top slab thickness
			tb (float): bottom slab thickness
			type (int): 0:long no flange offsets, 1:long with flange offsets, 2:transverse
			tw (float): web width (longitudinal only)
			Wt (float): average top flange width (longitudinal only)
			Wb (float): average bottom flange width (longitudinal only)
			ot (float): top flange offset (longitudinal only)
			ob (float): bottom flange offset (longitudinal only)
		Returns:
			None: 
		"""
		pass


	def setIncludeHaunchMaterial(self, includeHaunch) -> IFGeometricLine:
		r"""
		Sets whether to include the haunch material in stiffness calculations for bridge decks 
		Params:
			includeHaunch (bool): include haunch material flag
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setAllowBridgeDeckEccentricity(self, allowEccentricity) -> IFGeometricLine:
		r"""
		Sets whether to allow bridge decks to have eccentricity in 3d analysis 
		Params:
			allowEccentricity (bool): allow eccentricity flag
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setIncludeGirderStiffeners(self, includeStiffeners) -> IFGeometricLine:
		r"""
		Sets whether to include plate girder stiffeners in stiffness calculations for bridge decks 
		Params:
			includeStiffeners (bool): include plate girder stiffeners flag
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setBridgeDeckReinforcement(self, diaTop, diaBottom, spacingTop, spacingBottom, coverTop, coverBottom) -> IFGeometricLine:
		r"""
		Defines the reinforcement in the bridge deck 
		Params:
			diaTop (float): bar diameter
			diaBottom (float): bar diameter
			spacingTop (float): bar spacing
			spacingBottom (float): bar spacing
			coverTop (float): cover to bars
			coverBottom (float): cover to bars
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getBridgeDeckReinforcement(self, diaTop, diaBottom, spacingTop, spacingBottom, coverTop, coverBottom) -> None:
		r"""
		Gets the reinforcement definition for the bridge deck 
		Params:
			diaTop (float): bar diameter
			diaBottom (float): bar diameter
			spacingTop (float): bar spacing
			spacingBottom (float): bar spacing
			coverTop (float): cover to bars
			coverBottom (float): cover to bars
		Returns:
			None: 
		"""
		pass


	def getSectionDimensions(self, normalisedCoord, shapeCode) -> list[float]:
		r"""
		Return section dimensions at the given normalised distance along the attribute if returned shape code is -1, the cross section shape cannot be interpolated 
		Params:
			normalisedCoord (float): normalised coord 0 -> 1
			shapeCode (int): cross section shape code
		Returns:
			array of floats: cross section dimensions (shape code dependent)
		"""
		pass


	def getTopSlabDimensions(self, normalisedCoord) -> list[float]:
		r"""
		Return bridge deck slab dimensions at the given normalised distance along the attribute 
		Params:
			normalisedCoord (float): normalised coord 0 -> 1
		Returns:
			array of floats: top slab dimensions: b, t, ys, bh, th, effWidth
		"""
		pass


	def setEccentricityOrigin(self, yType, zType, yFibre=None, zFibre=None) -> IFGeometricLine:
		r"""
		Specify the origin for eccentricity. If not called, the default is "centroid" 
		Params:
			yType (str): type to be used in y direction - "Fibre" or "Centroid"
			zType (str): type to be used in z direction - "Fibre" or "Centroid"
			yFibre (str, optional): named fibre to be used in y direction (only used when yType = "fibre")
			zFibre (str, optional): named fibre to be used in z direction (only used when zType = "fibre")
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getEccentricityOrigin(self, yType, zType, yFibre, zFibre) -> None:
		r"""
		Inquire the origin for eccentricity as set with IFGeometricLine.setEccentricityOrigin 
		Params:
			yType (str): type used in y direction - "Fibre" or "Centroid"
			zType (str): type used in z direction - "Fibre" or "Centroid"
			yFibre (str): named fibre used in y direction (only used when yType = "fibre")
			zFibre (str): named fibre used in z direction (only used when zType = "fibre")
		Returns:
			None: 
		"""
		pass


	def getProjectedWidth(self, lineID, nrmCoordOnLine, Dir) -> float:
		r"""
		returns the width of the section in the projected direction 
		Params:
			lineID (str or int): name or ID of line
			nrmCoordOnLine (float): normalised coord w.r.t the line
			Dir (array of float): An array of 3 real numbers, representing 3d coordinates projection vector
		Returns:
			float: projected width
		"""
		pass


	def setUsingOptimPool(self, usingPool) -> IFGeometricLine:
		r"""
		Sets whether this attribute is using a section optimisation pool (IFGeomBeamOptimPool or 'Same as current') 
		Params:
			usingPool (bool): TRUE is using an optimisation pool
		Returns:
			IFGeometricLine: 
		"""
		pass


	def isUsingOptimPool(self) -> int:
		r"""
		Returns 0:not using optimisation, 1: using IFGeomBeamOptimPool, 2: 'Same as current' 
		Returns:
			int: 
		"""
		pass


	def setOptimisationPool(self, attribute) -> IFGeometricLine:
		r"""
		Set the beam optimisation pool attribute for the geometric line. If no attribute is set the 'Same library as Current section' will be used. 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. cross section pool attribute
		Returns:
			IFGeometricLine: 
		"""
		pass


	def getOptimisationPool(self) -> IFGeomBeamOptimPool:
		r"""
		Get the beam optimisation pool attribute for the geometric line 
		Returns:
			IFGeomBeamOptimPool: 
		"""
		pass


	def setOptimInitialSection(self, libraryName, libraryType, sectionName) -> IFGeometricLine:
		r"""
		Sets the section library, type and name for the initial section to be used for optimisation The section must be contained in the optimisation pool 
		Params:
			libraryName (str): library name
			libraryType (str): library type
			sectionName (str): section name
		Returns:
			IFGeometricLine: 
		"""
		pass


	def setOptimResultSection(self, libraryName, libraryType, sectionName) -> IFGeometricLine:
		r"""
		Sets the section library, type and name for the optimised section The section must be contained in the optimisation pool 
		Params:
			libraryName (str): library name
			libraryType (str): library type
			sectionName (str): section name
		Returns:
			IFGeometricLine: 
		"""
		pass


class IFGeometricSurface(IFGeometric):
	"""
	Setup surface geometric attribute 
	"""

	def setSurface(self, t, ez=None) -> IFGeometricSurface:
		r"""
		Sets the thickness 
		Params:
			t (IFVariationAttr or float): thickness
			ez (IFVariationAttr or float, optional): eccentricity in Z direction
		Returns:
			IFGeometricSurface: 
		"""
		pass


class IFGeometricJoint(IFGeometric):
	"""
	 
	"""

	def setJoint(self, ecc=None, dy=None, dz=None, useShearDistances=None) -> IFGeometricJoint:
		r"""
		Sets the eccentricity 
		Params:
			ecc (IFVariationAttr or float, optional): eccentricity
			dy (IFVariationAttr or float, optional): local y parametric distance to shear spring
			dz (IFVariationAttr or float, optional): local z parametric distance to shear spring
			useShearDistances (bool, optional): if false ignore the shear distances and do not tabulate
		Returns:
			IFGeometricJoint: 
		"""
		pass


class IFGeometricThermalLink(IFGeometric):
	"""
	 
	"""

	def setDistributionType(self, type) -> IFGeometricThermalLink:
		r"""
		set the distribution type 
		Params:
			type (str): distribution type
		Returns:
			IFGeometricThermalLink: 
		"""
		pass


	def setArea(self, area) -> IFGeometricThermalLink:
		r"""
		Sets the eccentricity 
		Params:
			area (IFVariationAttr or float): area for 2d/3d links
		Returns:
			IFGeometricThermalLink: 
		"""
		pass


	def setThickness(self, area) -> IFGeometricThermalLink:
		r"""
		Sets the eccentricity 
		Params:
			area (IFVariationAttr or float): thickness for axisymmetric links
		Returns:
			IFGeometricThermalLink: 
		"""
		pass


class IFPropertyModifier(IFAttribute):
	"""
	When assigned to a line, this attribute will add its modification factors to the values tabulated by the IFGeometricLine assigned to that line, allowing differing values of each porperty depending on either a Stiffness or Mass context. 
	"""

	def setStiffnessFactor(self, varName, value) -> IFDispatch:
		r"""
		Sets modification factor for the named geometric property for stiffness calculations 
		Params:
			varName (str): name of geometric property (e.g. "A")
			value (float): factor to be applied to property
		Returns:
			IFDispatch: 
		"""
		pass


	def setMassFactor(self, varName, value) -> IFDispatch:
		r"""
		Sets modification factor for the named geometric property for mass calculations 
		Params:
			varName (str): name of geometric property (e.g. "A")
			value (float): factor to be applied to property
		Returns:
			IFDispatch: 
		"""
		pass


class IFActivate(IFAttribute):
	"""
	Activate attribute When assigned to features in a particular loadcase, activate attributes make the elements meshed on those features active for that loadcase and subsequent loadcases. Note that all elements are created initially active, so activate attributes can only be used after a prior assignment of a deactivate loadcase. Incremental construction can be modelled by making all elements initially inactive, and then progressively assigning activate attributes over several loadcases Tunnelling can be modelled by making all elements initially active, and progressively assigning deactivate attributes over several loadcases 
	"""

	def setConstraintEquType(self, constrType) -> IFActivate:
		r"""
		set flag to indicate the type of constraint equation to create at activate/deactivate element interface 
		Params:
			constrType (str): 
		Returns:
			IFActivate: 
		"""
		pass


class IFDeactivate(IFAttribute):
	"""
	Deactivate attribute When assigned to features in a particular loadcase, deactivate attributes make the elements meshed on those features inactive for that loadcase and subsequent loadcases. Incremental construction can be modelled by making all elements initially inactive, and then progressively assigning activate attributes over several loadcases Tunnelling can be modelled by making all elements initially active, and progressively assigning deactivate attributes over several loadcases 
	"""

	def setCustomType(self, constrType) -> IFDeactivate:
		r"""
		set flag to indicate the type of custom behaviour. This function is only expected for attributes created with the "custom" type. Note that "active mesh" and "fixed whilst deactivated" result in no constraint equations being tabulated. All the other types do tabulate constraint equations. 
		Params:
			constrType (str): "none", "tangent", "fixed", "horizontal", "activeMesh", or "fixed whilst deactivated"
		Returns:
			IFDeactivate: 
		"""
		pass


	def setDeactivate(self, deactType, percentage, stiffness) -> IFDeactivate:
		r"""
		set flag to indicate the type of basic option to create at activate/deactivate element interface. If the type chosen is "custom", then a subsequent call to setConstraintEquType() is expected Also set the percentage of forces to redistribute and the stiffness reduction factor 
		Params:
			deactType (str): "activeMesh",  "closingPart", "fixed whilst deactivated", or "custom"
			percentage (float): 
			stiffness (float): 
		Returns:
			IFDeactivate: 
		"""
		pass


	def setForceDistribution(self, redistribution, nincs=None) -> IFDeactivate:
		r"""
		set flag to indicate the type of force redistribution to create at activate/deactivate element interface 
		Params:
			redistribution (str): 
			nincs (int, optional): number of increments
		Returns:
			IFDeactivate: 
		"""
		pass


class IFDrained(IFAttribute):
	"""
	Drained attribute 
	"""

	pass


class IFUndrained(IFAttribute):
	"""
	Undrained attribute 
	"""

	pass


class IFDamping(IFAttribute):
	"""
	structural or viscous damping attribute 
	"""

	def setStructural(self) -> IFDamping:
		r"""
		Sets up a structural damping attribute. 
		Returns:
			IFDamping: 
		"""
		pass


	def setViscous(self) -> IFDamping:
		r"""
		Sets up a viscous damping attribute. 
		Returns:
			IFDamping: 
		"""
		pass


	def addRow(self, Mass, Stiffness, frequency) -> IFDamping:
		r"""
		Adds a row if it is valid 
		Params:
			Mass (IFVariationAttr or float): Mass Rayleigh damping constant
			Stiffness (IFVariationAttr or float): Stiffness Rayleigh damping constant
			frequency (float): reference circular frequency
		Returns:
			IFDamping: 
		"""
		pass


class IFResetDeformation(IFAttribute):
	"""
	Reset deformation attribute Used to establish an initial equilibrium state, such as for a geotechnical analysis. 
	"""

	def setNodes(self) -> IFResetDeformation:
		r"""
		Sets the object type the attribute is applied to as nodes 
		Returns:
			IFResetDeformation: 
		"""
		pass


	def setElements(self) -> IFResetDeformation:
		r"""
		Sets the object type the attribute is applied to as elements 
		Returns:
			IFResetDeformation: 
		"""
		pass


class IFDimensionLines(IFAttribute):
	"""
	Dimensions lines attribute Used to annotate a plot with distances between points 
	"""

	def setDistancesAligned(self, axis) -> IFDimensionLines:
		r"""
		Sets the annotation type as distances between leader lines, aligned to the given axis 
		Params:
			axis (str): axis to align to ("X", "Y" or "Z")
		Returns:
			IFDimensionLines: 
		"""
		pass


	def setDistancesTrue(self) -> IFDimensionLines:
		r"""
		Sets the annotation type as "true" distances between leader lines 
		Returns:
			IFDimensionLines: 
		"""
		pass


	def setOrdinates(self, axis) -> IFDimensionLines:
		r"""
		Sets the annotation type as ordinates (distances from first leader line) 
		Params:
			axis (str): axis to align to ("X", "Y" or "Z")
		Returns:
			IFDimensionLines: 
		"""
		pass


	def setProjection(self, axis, distance) -> IFDimensionLines:
		r"""
		Sets the minimum distance from an assigned point to the dimension line annotation 
		Params:
			axis (str): axis in which to project ("X", "Y", "Z" or "screen")
			distance (float): minimum projection line length
		Returns:
			IFDimensionLines: 
		"""
		pass


class IFGeomBeamOptimPool(IFAttribute):
	"""
	Geometric section optimisation pool utility Represents the pool of sections that may be used to optimise another section 
	"""

	def removeAllSections(self) -> None:
		r"""
		Removes all sections from this pool 
		Returns:
			None: 
		"""
		pass


	def addSection(self, libraryName, libraryType, sectionName) -> IFGeomBeamOptimPool:
		r"""
		Adds one section to this pool 
		Params:
			libraryName (str): library name, e.g. UK Sections)
			libraryType (str): library type, e.g. Universal Beams (BS4)
			sectionName (str): section name, e.g. 838x292x194kg UB
		Returns:
			IFGeomBeamOptimPool: 
		"""
		pass


	def countSections(self) -> int:
		r"""
		Returns the number of sections in this pool 
		Returns:
			int: 
		"""
		pass


	def getAllSections(self) -> object:
		r"""
		Returns all the sections in this pool as a 2d array of strings. If there are seven sections in the pool, the array will be dimensioned as [7][3] 
		Returns:
			object: 
		"""
		pass


	def setAllSections(self, array) -> None:
		r"""
		Sets all the sections in this pool using the given 2d array of strings. If there are seven sections given, the array must be dimensioned as [7][3] 
		Params:
			array (array of strs): 
		Returns:
			None: 
		"""
		pass


	def updateDependentLines(self) -> None:
		r"""
		Notifies all dependent optimisation geometry that the pool of sections has been changed 
		Returns:
			None: 
		"""
		pass


class IFGeomBeamOptimUtil(IFAttribute):
	"""
	Geometric section optimisation utility Represents the list of sections that will be optimised 
	"""

	def removeAllGeometricLines(self) -> None:
		r"""
		Removes all geometric lines from this utility 
		Returns:
			None: 
		"""
		pass


	def addGeometricLine(self, section) -> IFGeomBeamOptimUtil:
		r"""
		Adds one geometric line to this utility 
		Params:
			section (IFGeometricLine): The name or ID of a name, or a pointer to a IFGeometricLine object. Beam section attribute
		Returns:
			IFGeomBeamOptimUtil: 
		"""
		pass


	def countGeometricLines(self) -> int:
		r"""
		Returns the number of geometric lines in this utility 
		Returns:
			int: 
		"""
		pass


	def getAllGeometricLines(self) -> object:
		r"""
		Returns all the geometric lines in this utility as an array of IFGeometricLine 
		Returns:
			object: 
		"""
		pass


	def setAllGeometricLines(self, array) -> None:
		r"""
		Sets all the geometric liness in this utility 
		Params:
			array (array of IFGeometricLine): 
		Returns:
			None: 
		"""
		pass


	def removeAllConstraints(self) -> None:
		r"""
		Removes all constraints from this utility 
		Returns:
			None: 
		"""
		pass


	def addConstraint(self, componentName, maxValue, active) -> IFGeomBeamOptimUtil:
		r"""
		Adds one constraint to this utility 
		Params:
			componentName (str): Component name, e.g. Util(My)
			maxValue (float): Max value allowed for given component
			active (bool): Set to false to ignore this constraint
		Returns:
			IFGeomBeamOptimUtil: 
		"""
		pass


	def countConstraints(self) -> int:
		r"""
		Returns the number of constraints in this utility 
		Returns:
			int: 
		"""
		pass


	def getConstraint(self, index, componentName, maxValue, active) -> None:
		r"""
		Returns a single constraint from this utility, identified by its position 
		Params:
			index (int): Must be in range 0.. countConstraints()-1
			componentName (object): Component name, e.g. Util(My)
			maxValue (object): Max value allowed for given component
			active (object): Set to false to ignore this constraint
		Returns:
			None: 
		"""
		pass


	def removeAllLoadcases(self) -> None:
		r"""
		Removes all loadcases from this utility 
		Returns:
			None: 
		"""
		pass


	def addLoadcase(self, section) -> IFGeomBeamOptimUtil:
		r"""
		Adds one loadcase to this utility 
		Params:
			section (IFLoadcase): The name or ID of a name, or a pointer to a IFLoadcase object. Loadcase
		Returns:
			IFGeomBeamOptimUtil: 
		"""
		pass


	def countLoadcases(self) -> int:
		r"""
		Returns the number of loadcases in this utility 
		Returns:
			int: 
		"""
		pass


	def getAllLoadcases(self) -> object:
		r"""
		Returns all the loadcases in this utility as an array of IFGeometricLine 
		Returns:
			object: 
		"""
		pass


	def setAllLoadcases(self, array) -> None:
		r"""
		Sets all the loadcases in this utility 
		Params:
			array (array of IFLoadcase): 
		Returns:
			None: 
		"""
		pass


	def getMaxIterations(self) -> int:
		r"""
		Sets the maximum number of iterations 
		Returns:
			int: 
		"""
		pass


	def setMaxIterations(self, maxIterations) -> None:
		r"""
		Sets the maximum number of iterations 
		Params:
			maxIterations (int): new value
		Returns:
			None: 
		"""
		pass


class IFEquivalence(IFAttribute):
	"""
	equivalence attribute 
	"""

	def setEquivalence(self, tol, equivUnmergables=None) -> IFEquivalence:
		r"""
		Sets the equivalence 
		Params:
			tol (float): max distance in model units between nodes
			equivUnmergables (bool, optional): if T equivalence mesh on unmergable geometry
		Returns:
			IFEquivalence: 
		"""
		pass


class IFCrackTip(IFAttribute):
	"""
	crack tip attribute 
	"""

	pass


class IFElementTypeAttr(IFAttribute):
	"""
	element type attribute 
	"""

	def addElementName(self, elementName) -> IFElementTypeAttr:
		r"""
		Sets the element name 
		Params:
			elementName (str): element name
		Returns:
			IFElementTypeAttr: 
		"""
		pass


class IFSurfaceRadiation(IFAttribute):
	"""
	radiation surface 
	"""

	def setRadiation(self) -> IFSurfaceRadiation:
		r"""
		Empty place holder in case one day we have extra params or different subtypes 
		Returns:
			IFSurfaceRadiation: 
		"""
		pass


	def addSurface(self, Surface, isShading) -> IFSurfaceRadiation:
		r"""
		Adds a surface if it is valid 
		Params:
			Surface (IFThermalSurface): The name or ID of a thermalsurface, or a pointer to a IFThermalSurface object. thermal surface defining part of this radiation surface
			isShading (bool): boolean: does the associated thermal surface eclipse the view of other thermal surfaces?
		Returns:
			IFSurfaceRadiation: 
		"""
		pass


	def addSymmetryAttr(self, Attr) -> IFSurfaceRadiation:
		r"""
		Adds a symmetry 
		Params:
			Attr (IFThermalSurface): The name or ID of a thermalsurface, or a pointer to a IFThermalSurface object. thermal surface defining part of this radiation surface
		Returns:
			IFSurfaceRadiation: 
		"""
		pass


	def addSymmetryEqn(self, abcd) -> IFSurfaceRadiation:
		r"""
		Adds a symmetry 
		Params:
			abcd (array of float): array containing the four equation parameters
		Returns:
			IFSurfaceRadiation: 
		"""
		pass


	def addSymmetryEqnVals(self, a, b, c, d) -> IFSurfaceRadiation:
		r"""
		Adds a symmetry 
		Params:
			a (float): plane of symmetry equation: ax + by + cz = d
			b (float): plane of symmetry equation: ax + by + cz = d
			c (float): plane of symmetry equation: ax + by + cz = d
			d (float): plane of symmetry equation: ax + by + cz = d
		Returns:
			IFSurfaceRadiation: 
		"""
		pass


	def addSymmetryPlane(self, Perp, constant) -> IFSurfaceRadiation:
		r"""
		Adds a symmetry 
		Params:
			Perp (array of float): An array of 3 real numbers, representing 3d coordinates direction perpendicular to the plane (containing a, b, and c)
			constant (float): plane of symmetry equation: ax + by + cz = d
		Returns:
			IFSurfaceRadiation: 
		"""
		pass


class IFSearchArea(IFAttribute):
	"""
	search area attribute 
	"""

	def setSearch(self) -> IFSearchArea:
		r"""
		empty place holder in case one day we have extra params or different subtypes 
		Returns:
			IFSearchArea: 
		"""
		pass


class IFAge(IFAttribute):
	"""
	Age attribute 
	"""

	def setAgeType(self, type) -> IFAge:
		r"""
		Sets the age of the structure at activation 
		Params:
			type (str): age type "specified" or "calculated"
		Returns:
			IFAge: 
		"""
		pass


	def setAgeAtActivation(self, age) -> IFAge:
		r"""
		Sets the age of the structure at activation 
		Params:
			age (float): age at activation (seconds). NB t is always in seconds, unless timescale units are set to "increments", in which case t is dimensionless
		Returns:
			IFAge: 
		"""
		pass


	def setAgeAtShrinkage(self, age) -> IFAge:
		r"""
		set the age of the structure when curing stops, and shrinkage begins. 
		Params:
			age (float): age when shrinkage starts (seconds). NB s is also always in seconds
		Returns:
			IFAge: 
		"""
		pass


	def addTempDuration(self, temp, duration) -> IFAge:
		r"""
		set the age of the structure when curing stops, and shrinkage begins. 
		Params:
			temp (float): temperature
			duration (float): duration of the temperature (seconds)
		Returns:
			IFAge: 
		"""
		pass


class IFPhiCReduction(IFAttribute):
	"""
	Phi c reduction attribute 
	"""

	pass


class IFSlide(IFAttribute):
	"""
	slideline 
	"""

	def addRow(self, primaryScale, secondaryScale, coulombFriction, zonalContactDetection, slidelineExtension, closeContactDetection, temperature) -> IFSlide:
		r"""
		Adds a set of parameters to this slideline, representing one temperature in a temperature dependant slideline 
		Params:
			primaryScale (float): 
			secondaryScale (float): 
			coulombFriction (float): 
			zonalContactDetection (float): 
			slidelineExtension (float): 
			closeContactDetection (float): 
			temperature (float): 
		Returns:
			IFSlide: 
		"""
		pass


	def addChange(self, loadcase, type) -> IFSlide:
		r"""
		Modifies the slideline type for the given loadcase and all subsequent loadcases. Typically a slideline might be defined with a starting type of 'Null' and then be modified at a certain point in the analysis to be of type 'Sliding'. It is quite legal to call this function repeatedly, setting up (for example) a change from 'Null' to 'Sliding' to 'Tied' 
		Params:
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase at which slideline type changes
			type (str): 'No friction', 'Friction', 'Null','Tied', or 'Sliding'
		Returns:
			IFSlide: 
		"""
		pass


class IFThermalSurfaceGap(IFAttribute):
	"""
	Thermal gap attribute 
	"""

	def setThermalGap(self, surf1Attr, surf2Attr, update=None, shading=None, active=None) -> IFThermalSurfaceGap:
		r"""
		Sets up a thermal gap attribute. 
		Params:
			surf1Attr (IFThermalSurface): The name or ID of a thermalsurface, or a pointer to a IFThermalSurface object. thermal surface defining first side of gap
			surf2Attr (IFThermalSurface): The name or ID of a thermalsurface, or a pointer to a IFThermalSurface object. thermal surface defining second side of gap
			update (bool, optional): geometry update flag (default = TRUE)
			shading (bool, optional): element shading flag (default = TRUE)
			active (bool, optional): active gap flag (default = TRUE)
		Returns:
			IFThermalSurfaceGap: 
		"""
		pass


	def addConductanceProperties(self, conductance, heatTransfer, conductanceVariation, heatTransferVariation, maxGapSize, temp) -> IFThermalSurfaceGap:
		r"""
		Sets conductance properties 
		Params:
			conductance (float): gap conductance for a closed gap
			heatTransfer (float): convective heat transfer coeff for a closed gap
			conductanceVariation (float): variation of gap conductance with gap opening
			heatTransferVariation (float): variation of convective heat transfer coeff with gap opening
			maxGapSize (float): max link length beyond which a link will not be created
			temp (float): reference temperature
		Returns:
			IFThermalSurfaceGap: 
		"""
		pass


	def addContactProperties(self, conductance, heatTransfer, pressure, temp) -> IFThermalSurfaceGap:
		r"""
		Sets contact properties 
		Params:
			conductance (float): gap conductance for contact pressure
			heatTransfer (float): convective heat transfer coeff for pressure
			pressure (float): contact pressure
			temp (float): reference temperature
		Returns:
			IFThermalSurfaceGap: 
		"""
		pass


	def addChange(self, loadcase, type) -> IFThermalSurfaceGap:
		r"""
		Modifies the gap type for the given loadcase and all subsequent loadcases. 
		Params:
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase at which slideline type changes
			type (str): 'ACTIVE', or 'INACTIVE'
		Returns:
			IFThermalSurfaceGap: 
		"""
		pass


class IFThermalSurface(IFAttribute):
	"""
	Thermal surface attribute 
	"""

	def setSubSegments(self, nSegments) -> IFThermalSurface:
		r"""
		Sets thermal surface params. 
		Params:
			nSegments (int): sub-segments for view factors (default = 2)
		Returns:
			IFThermalSurface: 
		"""
		pass


	def addEnvironmentProperties(self, conductance, heatTransfer, emissivity, envTemp, temp) -> IFThermalSurface:
		r"""
		Sets the environment properties 
		Params:
			conductance (float): surface conductance to environment
			heatTransfer (float): surface convective heat transfer coeff
			emissivity (float): environment emissivity
			envTemp (float): environment temperature
			temp (float): reference temperature
		Returns:
			IFThermalSurface: 
		"""
		pass


	def addRadiationProperties(self, emissivity, temp) -> IFThermalSurface:
		r"""
		Sets the radiation properties 
		Params:
			emissivity (float): 0.0 to 1.0
			temp (float): reference temperature
		Returns:
			IFThermalSurface: 
		"""
		pass


class IFSupport(IFAttribute):
	"""
	 
	"""

	pass


class IFSupportThermal(IFSupport):
	"""
	Thermal support 
	"""

	def setThermal(self, phi, pres=None) -> IFSupportThermal:
		r"""
		Sets up a thermal support. 
		Params:
			phi (str): restraint type with respect to temperature
			pres (str, optional): restraint type with respect to capillary pressure
		Returns:
			IFSupportThermal: 
		"""
		pass


	def setSpring(self, type, phiStiff, presStiff=None) -> IFSupportThermal:
		r"""
		Sets up spring stiffnesses. 
		Params:
			type (str): 'Total', 'Length', or 'Area' - indicates whether given stiffnesses are total values, or are given per unit length or per unit area
			phiStiff (IFVariationAttr or float): stiffness with respect to temperature (conductivity)
			presStiff (IFVariationAttr or float, optional): stiffness with respect to capillary pressure
		Returns:
			IFSupportThermal: 
		"""
		pass


class IFSupportStructural(IFSupport):
	"""
	Structural support 
	"""

	def setStructural(self, u, v, w=None, thx=None, thy=None, thz=None, l1=None, l2=None, pore=None, torsion=None) -> IFSupportStructural:
		r"""
		Sets up a structural support. [restraint types: 'F', 'R', 'S', 'P' or 'Z'] 
		Params:
			u (str): restraint type along X axis
			v (str): restraint type along Y axis
			w (str, optional): restraint type along Z axis (default = 'R')
			thx (str, optional): restraint type rotationally about X axis (default = 'R')
			thy (str, optional): restraint type rotationally about Y axis (default = 'R')
			thz (str, optional): restraint type rotationally about Z axis (default = 'R')
			l1 (str, optional): restraint type rotationally about loof 1 / hinge (default = 'R')
			l2 (str, optional): restraint type rotationally about loof 2 / hinge (default = 'R')
			pore (str, optional): restraint type with respect to pore pressure (default = 'R')
			torsion (str, optional): restraint type with respect to torsional warping (default = 'R')
		Returns:
			IFSupportStructural: 
		"""
		pass


	def setSpring(self, type, ustiff, vstiff, wstiff, thxstiff, thystiff, thzstiff, loof1stiff, loof2stiff, porestiff, torsionstiff=None) -> IFSupportStructural:
		r"""
		Sets up spring stiffnesses. 
		Params:
			type (str): 'Total', 'Length', or 'Area' - indicates whether given stiffness is a total stiffness, or is given per unit length or per unit area
			ustiff (IFVariationAttr or float): spring stiffness along X axis
			vstiff (IFVariationAttr or float): spring stiffness along Y axis
			wstiff (IFVariationAttr or float): spring stiffness along Z axis
			thxstiff (IFVariationAttr or float): spring stiffness rotationally about X axis
			thystiff (IFVariationAttr or float): spring stiffness rotationally about Y axis
			thzstiff (IFVariationAttr or float): spring stiffness rotationally about Z axis
			loof1stiff (IFVariationAttr or float): spring stiffness rotationally about loof 1 / hinge
			loof2stiff (IFVariationAttr or float): spring stiffness rotationally about loof 2 / hinge
			porestiff (IFVariationAttr or float): spring stiffness with respect to pore pressure
			torsionstiff (IFVariationAttr or float, optional): spring stiffness with respect to torsional warping
		Returns:
			IFSupportStructural: 
		"""
		pass


	def setPorePressureSeepage(self) -> IFSupportStructural:
		r"""
		Sets pore pressure seepage definition data 
		Returns:
			IFSupportStructural: 
		"""
		pass


	def setLiftOff(self, type, freedom=None, useUpper=None, valUpper=None, useLower=None, valLower=None) -> IFSupportStructural:
		r"""
		Sets up lift-off conditions 
		Params:
			type (str): Type of lift off: None/Contact single/Contact all/Contact gap/Lift-off single/Lift-off all
			freedom (str, optional): freedom string or integer dialog row number
			useUpper (bool, optional): True if upper limit provided
			valUpper (float, optional): Upper limit
			useLower (bool, optional): True if lower limit provided
			valLower (float, optional): Lower limit
		Returns:
			IFSupportStructural: 
		"""
		pass


	def setViscousDamping(self, userSpecified, xReduction, yReduction, zReduction, xDensityWaveSpeed=None, yDensityWaveSpeed=None, zDensityWaveSpeed=None) -> IFSupportStructural:
		r"""
		Sets the viscous damping coefficients for non-reflective/absorbing boundary conditions 
		Params:
			userSpecified (bool): TRUE: user specified coefficients, FALSE: solver calculates the viscous damping coefficients (density.wavespeed not required)
			xReduction (IFVariationAttr or float): Relaxation coefficient for X axis
			yReduction (IFVariationAttr or float): Relaxation coefficient for Y axis
			zReduction (IFVariationAttr or float): Relaxation coefficient for Z axis
			xDensityWaveSpeed (IFVariationAttr or float, optional): Material density at the boundary node x pressure/shear wave speed for X axis
			yDensityWaveSpeed (IFVariationAttr or float, optional): Material density at the boundary node x pressure/shear wave speed for Y axis
			zDensityWaveSpeed (IFVariationAttr or float, optional): Material density at the boundary node x pressure/shear wave speed for Z axis
		Returns:
			IFSupportStructural: 
		"""
		pass


class IFInspectionPoint(IFAttribute):
	"""
	Represents a coordinate (point) in 3d space. 
	"""

	def setInspection(self, assignmentType, distanceType=None, excludeRigid=None) -> None:
		r"""
		Set inspection assignment type and distance type 
		Params:
			assignmentType (str): "Point", "Line", "Surface", "Volume"
			distanceType (str, optional): "Parametric", "Actual from start", "Actual from end"
			excludeRigid (bool, optional): if true then distances exclude the rigid end zones of lines
		Returns:
			None: 
		"""
		pass


	def addLocation(self, u, v=None, w=None) -> None:
		r"""
		Add a location within the attribute. 
		Params:
			u (float): location in u direction for lines, surfaces and volumns.
			v (float, optional): location in v direction for surfaces and volumns.
			w (float, optional): location in w direction for volumns only.
		Returns:
			None: 
		"""
		pass


	def setKeepOnlyValid(self, doKeep) -> None:
		r"""
		option to ignore locations outside the assigned objects 
		Params:
			doKeep (bool): if true ignore locations outside the assigned objects
		Returns:
			None: 
		"""
		pass


	def setScriptedResults(self, feature, index, value, entity, component=None, loadcase=None) -> None:
		r"""
		specify the value of a result at this location 
		Params:
			feature (IFDatabaseMember): feature to which to attach value (this attribute must be assigned to that feature)
			index (int): index of location within this (corresponds to a row in the definition dialog)
			value (float): value to assign
			entity (str int or IFScriptedResultsComponentSet): Name or index of results entity, or object in which to store results
			component (str, optional): Name of results component (if 'entity' is an IFScriptedResultsComponentSet, then this is expected to be an integer)
			loadcase (IFLoadcase, optional): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Loadcase in which results apply (unless given as IFScriptedResultsComponentSet in 'entity')
		Returns:
			None: 
		"""
		pass


	def getAttributeValue(self, feature, locationIndex, attrType, varName, loadcase=None, units=None, errorFlag=None, singleLoadcase=None) -> object:
		r"""
		Retrieves a named attribute value at this location 
		Params:
			feature (IFDatabaseMember): feature to which to attach value (this attribute must be assigned to that feature)
			locationIndex (int): index of location within this (corresponds to a row in the definition dialog)
			attrType (object): "Loading", "Support", "Material", etc
			varName (str): e.g. "E" or "thickness". The set of available names depends on the attibute assigned
			loadcase (IFLoadset, optional): 
			units (IFUnitSet, optional): 
			errorFlag (bool, optional): If provided, and an error occurs (e.g. attribute not assigned), this flag is set true, and no error is reported
			singleLoadcase (bool, optional): if T process just the given loadcase, if F descend the loadcases, default true
		Returns:
			object: The type of value returned will depend on what was requested
		"""
		pass


	def countAssignedObjects(self, locationIndex) -> int:
		r"""
		return the number of assigned object corresponding to the given location index 
		Params:
			locationIndex (int): index of location within this (corresponds to a row in the definition dialog)
		Returns:
			int: number of objects assigned yto
		"""
		pass


	def getAssignedObject(self, locationIndex, assignedObjectIndex) -> IFDatabaseMember:
		r"""
		companion function to countAssignedObjects, return the assigned object corresponding to the given location index and assigned object index 
		Params:
			locationIndex (int): index of location within this (corresponds to a row in the definition dialog)
			assignedObjectIndex (int): assigned object index
		Returns:
			IFDatabaseMember: assigned object
		"""
		pass


	def countMeshObjects(self, locationIndex) -> int:
		r"""
		return the number of mesh objects corresponding to the given location index 
		Params:
			locationIndex (int): index of location within this (corresponds to a row in the definition dialog)
		Returns:
			int: number of objects assigned yto
		"""
		pass


	def getMeshObject(self, locationIndex, assignedObjectIndex) -> IFDatabaseMember:
		r"""
		companion function to countMeshObjects, return the mesh object corresponding to the given location index and assigned object index 
		Params:
			locationIndex (int): index of location within this (corresponds to a row in the definition dialog)
			assignedObjectIndex (int): assigned object index
		Returns:
			IFDatabaseMember: mesh object
		"""
		pass


class IFInspectionLine(IFDatabaseMember):
	"""
	Represents an arbitrary line through the model, which can be used to store and display results similar to those seen by the "graph through 2D" and "slice resultants beams/shells" tools. 
	"""

	def createValue(self, varNname, energy=None, force=None, length=None, mass=None, time=None, temperature=None, perUnitLength=None) -> IFDispatch:
		r"""
		Creates a new value within this object for subsequent use. The initial value will be 0.0 until modified by a call to IFInspectionLine.setValue. LUSAS will not use this value for any purpose, but will store it in model files, and allow subsequent modification with IFInspectionLine.setValue and/or subsequent access with IFInspectionLine.getValue. The value may have any simple data type - integer, boolean, real or string, or it may be a LUSAS LPI object representing an attribute. Or it may be an array of any of these. Note that arrays cannot mix types - e.g. you can have an array of strings OR an array of booleans, but you cannot have an array that contains both strings and booleans, and similarly for all other types. For numbers, it will often be desirable, but is not compulsory, to attach unit information to the value, such that its value can be fetched or modified in a known system of units. This is done using the six optional integers. The integers represent the indices, or 'power' of each scalar quantity - e.g. 2=squared,3=cubed and so on. Each integer may be positive or negative. E.g. specifying '0,0,1,0,0,0' would mean that the new quantity is a length; '0,0,2,0,0,0' would mean length squared, i.e. area; '0,0,1,0,-1,0' would mean length divided by time, i.e. velocity; and '0,1,-2,0,0,0' would mean force per unit area. 
		Params:
			varNname (str): name of the new value
			energy (int, optional): energy component of the new value (default 0.0)
			force (int, optional): force component of the new value (default 0.0)
			length (int, optional): length component of the new value (default 0.0)
			mass (int, optional): mass component of the new value (default 0.0)
			time (int, optional): time component of the new value (default 0.0)
			temperature (int, optional): temperature component of the new value (default 0.0)
			perUnitLength (int, optional): Only to be used for quantities that are 'per unit length' or 'per unit area', such as "mm�/m" (default 0.0)
		Returns:
			IFDispatch: 
		"""
		pass


	def removeValue(self, varName) -> bool:
		r"""
		remove value added to this object by "createValue" 
		Params:
			varName (str): name of the value
		Returns:
			bool: return true if removed
		"""
		pass


	def existsValue(self, varName) -> bool:
		r"""
		Returns true if this object contains a value with the given name 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			bool: 
		"""
		pass


	def setValue(self, varName, value, units=None) -> IFDispatch:
		r"""
		Sets the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): name of the value (e.g. "E")
			value (object): The type given will depend on the value specified
			units (IFUnitSet, optional): 
		Returns:
			IFDispatch: 
		"""
		pass


	def getValue(self, varName, units=None) -> object:
		r"""
		Returns the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the the database's current unit system. 
		Params:
			varName (str): 
			units (IFUnitSet, optional): 
		Returns:
			object: The type returned will depend on the value requested
		"""
		pass


	def getValueUnits(self, varName, units=None) -> str:
		r"""
		Returns the units ("N/mm�", "m/s", etc) of the value that will be returned by IFInspectionLine.getValue for the given named variable. Optionally, an IFUnitSet object (or its name) can be passed to control which system of units (e.g. mm/m/inch) will be used to build the returned string. If not given, the database's current unit system will be used. 
		Params:
			varName (str): name of the value (e.g. "E")
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			str: the returned string
		"""
		pass


	def getValueNames(self) -> list[str]:
		r"""
		Allows user to inquire the names of values which are valid to be used in IFInspectionLine.getValue The return value is an array of strings, each of which is a valid value name. 
		Returns:
			array of strs: Returned array of names
		"""
		pass


	def getValueDescription(self, varName) -> str:
		r"""
		Returns a description or definition of the given named value. A list of valid names may be obtained by calling IFInspectionLine.getValueNames 
		Params:
			varName (str): name of the value (e.g. "E")
		Returns:
			str: the returned string
		"""
		pass


	def getValueType(self, varName) -> str:
		r"""
		Return the type (string, real, integer, attribute etc) of value that will be returned by IFInspectionLine.getValue for the given named variable. In order to find the list of valid named variables, use IFInspectionLine.getValueNames 
		Params:
			varName (str): 
		Returns:
			str: 
		"""
		pass


	def setValueDescription(self, name, desc, persist=None) -> IFDispatch:
		r"""
		specify a description to be used (in the report wizard) for a value previously added using IFInspectionLine.createValue. Note that if this function is not called, the value will not appear in the report. It is an error to call this function for any value not previously added using IFInspectionLine.createValue. By default, values that are added via createValue() are not persistent. That is, when the object is subsequently redefined using a call of the form db.create....(), all such data is lost, consistently with all other data. However, the persist flag may be set true to prevent this. This should only be done for data that cannot be logically invalidated by entering conflicting data in Modeller's user interface. 
		Params:
			name (str): name of the value
			desc (str): new description
			persist (bool, optional): persistence (default false)
		Returns:
			IFDispatch: 
		"""
		pass


	def setEditDialog(self, filename) -> None:
		r"""
		Set name of dialog used to edit this loadset when the "Edit..." context menu is chosen. This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFInspectionLine.setEditingMenuID or IFInspectionLine.setDefinitionMenuID 
		Params:
			filename (str): 
		Returns:
			None: 
		"""
		pass


	def setEditingMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this loadset is edited or double-clicked on. The existing menu entry 'Edit...' will be modified in the context menu such that it generates the ID given. When this menu item is chosen by the user, or the loadset is double-clicked, all LUSAS extension modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can no longer view or modify the underlying modeller definition via the "Edit..." menu entry. To enable this, call IFInspectionLine.setDefinitionMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple types such as strings and integers
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def setDefinitionMenuID(self, menuID, clientData=None, isRelativeID=None) -> None:
		r"""
		Set the menu ID that will be generated when this loadset is edited or double-clicked on. A new menu entry 'Edit definition...' will be automatically added to the context menu, with the ID given. When this menu item is chosen by the user, or the loadset is double-clicked, all LUSAS extension modules will be informed that the given menu ID has been triggered. The appropriate module can then handle all three events (creation, edit, double click) in one handler - onMenuClick. Note that the user can still view and modify the underlying modeller definition via the "Edit..." menu entry. To disable this, call IFInspectionLine.setEditingMenuID() in preference to this function. 
		Params:
			menuID (int): 
			clientData (object, optional): This data will be passed back to you, unmodified, in your overrides of onMenuClick() and onMenuUpdate(). Limited to simple data types like strings and integers.
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			None: 
		"""
		pass


	def getEditingMenuID(self, isRelativeID=None) -> int:
		r"""
		Retrieve the menu ID that was set using setDefinitionMenuID 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def getDefinitionMenuID(self, isRelativeID=None) -> int:
		r"""
		Retrieve the menu ID that was set using setEditingMenuID 
		Params:
			isRelativeID (bool, optional): If true, the given menu ID is assumed to be relative to the constant ID_MODULE_MENU_MIN. If false (the default), it is an absolute value
		Returns:
			int: 
		"""
		pass


	def setDoubleClickDialog(self, filename=None) -> None:
		r"""
		Set name of dialog used to edit this loadset when it is double clicked in the treeview. This is the best method to use if the editing dialog is written as a VBScript TFM. LUSAS extension modules should generally use IFInspectionLine.setEditingMenuID or IFInspectionLine.setDefinitionMenuID 
		Params:
			filename (str, optional): If given, sets the dialog. If not given, reset to internal default dialog
		Returns:
			None: 
		"""
		pass


	def insertContextMenuItem(self, beforeItem, itemText, command, helpString=None, sessionFile=None) -> None:
		r"""
		Inserts a new menu item before the specified item in the context (right click) menu for this loadset. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			beforeItem (str or int): menu item before which new item is to be placed
			itemText (str): text of new item
			command (str): command to execute when menu item selected
			helpString (str, optional): help string to be displayed in status bar when cursor hovers over menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def removeContextMenuItem(self, itemText, sessionFile=None) -> None:
		r"""
		Removes a context menu item previously added with IFInspectionLine.insertContextMenuItem. The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			itemText (str): text of context menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def removeExternalDefinition(self) -> None:
		r"""
		Remove all traces of externally applied definitions, such as those added using IFInspectionLine.setEditingMenuID, IFInspectionLine.setDefinitionMenuID, and IFInspectionLine.setDoubleClickDialog(). This has the effect of breaking the link to the external definition (usually a library or similar) 
		Returns:
			None: 
		"""
		pass


	def setDescription(self, description=None) -> None:
		r"""
		Sets a helpful description to be used in the utilities tree. If no string is given, the objecy will automatically create a description. Note that most object types do not yet support this functionality, and therefore the automatically generated description would be blank. Alternatively, the description can be passed to this function in which case it overrides any automatic description 
		Params:
			description (str, optional): description to attach
		Returns:
			None: 
		"""
		pass


	def getDescription(self) -> str:
		r"""
		returns the description that was added via IFInspectionLine.setDescription 
		Returns:
			str: 
		"""
		pass


	def getNameAndDescription(self) -> str:
		r"""
		Returns the name and description of this object, as shown in the modeller treeview Currently it is the same as "getName() (getDescription())" 
		Returns:
			str: the returned name
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns objects ID IDs are program-generated and quite seperate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def getIDAndName(self) -> str:
		r"""
		Returns the ID and name of this utility, as shown in the modeller treeview Currently it is the same as "getID():getName()" 
		Returns:
			str: the returned name
		"""
		pass


	def getIDAndNameAndDescription(self) -> str:
		r"""
		Returns the ID, name and description of this utility, as shown in the modeller treeview Currently it is the same as "getID():getName() (getDescription())" 
		Returns:
			str: the returned name
		"""
		pass


class IFGraphInspectionLine(IFInspectionLine):
	"""
	Represents an arbitrary line through the model, which can be used to store and display results similar to those seen by the "graph through 2D" tool. 
	"""

	def setLocationLine(self, data, lineLength=None, addMeshLimits=None) -> IFInspectionLine:
		r"""
		define the inspection line definition through the model using the given geometry data object, the line may be of any type 
		Params:
			data (IFGeometryData): line definition data
			lineLength (float, optional): optionally return the length of the line
			addMeshLimits (object, optional): optional <boolean> if true insert values along the line to find the limits of the mesh, default false
		Returns:
			IFInspectionLine: 
		"""
		pass


	def setLocationObject(self, obj, addMeshLimits=None) -> IFInspectionLine:
		r"""
		Set the location of this inspection line to follow an existing database line 
		Params:
			obj (IFDatabaseMember): line to follow
			addMeshLimits (object, optional): optional <boolean> if true insert values along the line to find the limits of the mesh, default false
		Returns:
			IFInspectionLine: 
		"""
		pass


	def setExtent(self, extentType, groupName=None) -> IFInspectionLine:
		r"""
		Set up the elements that will be considered If not called, the default extent is "elements showing results" 
		Params:
			extentType (str): elements used in the calculation - "Elements showing results" | "Full model" | "Visible model" | "Group"
			groupName (str, optional): group name (only used if extentType is "group")
		Returns:
			IFInspectionLine: 
		"""
		pass


	def setProjection(self, p1, p2, p3, limitProjLength=None) -> IFInspectionLine:
		r"""
		Set up the projection from the location to the model If not called, the default extent is the current vertical axis 
		Params:
			p1 (float): projection vector
			p2 (float): projection vector
			p3 (float): projection vector
			limitProjLength (object, optional): optional <double> maximum allowable length from location into model, negative means no limit, default -1.0
		Returns:
			IFInspectionLine: 
		"""
		pass


	def setCorridor(self, corridorWidth) -> IFInspectionLine:
		r"""
		Set up the width that will be considered for integration If not called, the default corridor width is zero 
		Params:
			corridorWidth (float): as graph through 2d facility
		Returns:
			IFInspectionLine: 
		"""
		pass


	def setEvenSpacing(self, nLocations) -> IFInspectionLine:
		r"""
		Specify a fixed number of locations, along the graph line at which to sample results (rather than the default, which provides results at each location where the line crosses an element boundary) 
		Params:
			nLocations (int): Must be > 0
		Returns:
			IFInspectionLine: 
		"""
		pass


	def setFixedDistance(self, spacing) -> IFInspectionLine:
		r"""
		Specify a fixed increment, along the graph line, at which to sample results (rather than the default, which provides results at each location where the line crosses an element boundary) A result will always be returned at the end of the line, so if the line is 5.14 units long, and a fixed distance of 1.5 is chosen, results will be returned at distances 0, 1.5, 3, 4.5, 5.14. 
		Params:
			spacing (float): Must be > 0
		Returns:
			IFInspectionLine: 
		"""
		pass


	def setElementBoundaries(self) -> IFInspectionLine:
		r"""
		Provide results at each location where the graph line crosses an element boundary 
		Returns:
			IFInspectionLine: 
		"""
		pass


class IFBeamShellSlice(IFInspectionLine):
	"""
	implementation of the "slice resultants beams/shells" tool. 
	"""

	def setName(self, name) -> IFBeamShellSlice:
		r"""
		modify the name of this object 
		Params:
			name (str): 
		Returns:
			IFBeamShellSlice: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns object name 
		Returns:
			str: Name
		"""
		pass


	def setBeamShellSlice(self, distanceType, distances, includePoints, startDistance, aboutNeutralAxis, useEffectiveWidth, effectiveWidth, wholeElementsOnly, smoothCorners, slicePrefix, extentType, groupName, selectedLines, rotation) -> IFBeamShellSlice:
		r"""
		sets up a beam shell slice utility object 
		Params:
			distanceType (str or int): type of distances in next value "from points"(0), "incremental"(1), "absolute"(2), "parametric"(3), "constant"(4)
			distances (str): input distances e.g. "3@1,4@2"
			includePoints (bool): create a slice at each point along the selected lines?
			startDistance (float): start distance
			aboutNeutralAxis (bool): else moments are about slice path
			useEffectiveWidth (bool): as option on dialog
			effectiveWidth (float): only used if 'useEffectiveWidth' is true
			wholeElementsOnly (bool): else include partial elements
			smoothCorners (bool): as option on dialog
			slicePrefix (str): used to generate label at each slice plane
			extentType (str or int): extent type  = "full"(0), "visible"(1), "group"(2), "results"(3), or "selected"(4)
			groupName (str): only used if extentType = group, in which case its the name of the group to use as the extent
			selectedLines (array of int): lines defining the path
			rotation (float): slice plane rotation
		Returns:
			IFBeamShellSlice: 
		"""
		pass


	def getBeamShellSliceInputs(self, distanceType, distances, includePoints, startDistance, aboutNeutralAxis, useEffectiveWidth, effectiveWidth, wholeElementsOnly, smoothCorners, slicePrefix, extentType, groupName, selectedLines, rotation) -> None:
		r"""
		Returns the inputs used to define this object 
		Params:
			distanceType (str or int): type of distances in next value "from points"(0), "incremental"(1), "absolute"(2), "parametric"(3), "constant"(4)
			distances (str): input distances e.g. "3@1,4@2"
			includePoints (bool): create a slice at each point along the selected lines?
			startDistance (float): start distance
			aboutNeutralAxis (bool): else moments are about slice path
			useEffectiveWidth (bool): as option on dialog
			effectiveWidth (float): only used if 'useEffectiveWidth' is true
			wholeElementsOnly (bool): else include partial elements
			smoothCorners (bool): as option on dialog
			slicePrefix (str): used to generate label at each slice plane
			extentType (str or int): extent type  = "full"(0), "visible"(1), "group"(2), "results"(3), or "selected"(4)
			groupName (str): only used if extentType = group, in which case its the name of the group to use as the extent
			selectedLines (array of int): lines defining the path
			rotation (float): slice plane rotation
		Returns:
			None: 
		"""
		pass


	def getAllResults(self, option=None, context=None, units=None) -> list[float]:
		r"""
		return all the results of this slice. The returned array contains 'n' sets of 7 values (Fx,Fy,Fz,Mx,My,Mz,distance). 'n' in this context is the number of unique values of results as returned by IFBeamShellSlice.getNumberLocations, which may be fewer than that returned by IFBeamShellSlice.getNumberResults and therefore refers to original user input When called, modeller will calculate and cache all Beam/Shell slices in the given context (not just the requested slice). This can be changed by modifying the "Beam/Shell Slicing" objects in the context CalcResultsSet. 
		Params:
			option (str or int, optional): Dictates behaviour of this function when more than one slice exists at a location "error" (default), "max", "min", "abs"
			context (IFResultsContext, optional): The name or ID of a context, or a pointer to a IFResultsContext object. If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			array of float: 
		"""
		pass


	def getSingleResult(self, locnIndex, option=None, context=None, units=None) -> list[float]:
		r"""
		return all the results of a single slice. The returned array contains 7 values Fx,Fy,Fz,Mx,My,Mz,distance When called, modeller will calculate and cache all Beam/Shell slices in the given context (not just the requested slice). This can be changed by modifying the "Beam/Shell Slicing" objects in the context CalcResultsSet. 
		Params:
			locnIndex (int): ID of the location of interest. Note that this is 0..IFBeamShellSlice.getNumberResults - 1 and NOT 0..IFBeamShellSlice.getNumberLocations - 1
			option (str or int, optional): Dictates behaviour of this function when more than one slice exists at a location "error" (default), "max", "min", "abs"
			context (IFResultsContext, optional): The name or ID of a context, or a pointer to a IFResultsContext object. If this variable is given, settings such as active loadcase, and active elements will be taken from this context, instead of the current view
			units (IFUnitSet, optional): unit system to use. If not given, database units will be assumed
		Returns:
			array of float: 
		"""
		pass


	def getNumberLocations(self) -> int:
		r"""
		return the number of original input locations in this object 
		Returns:
			int: number of original input locations
		"""
		pass


	def getNumberResults(self) -> int:
		r"""
		return the number of results slices in this object. This can be more than IFBeamShellSlice.getNumberLocations, because it is possible to have multiple results at a single location (e.g. either side of an averaging discontinuity) 
		Returns:
			int: number of slices
		"""
		pass


	def getInputLocation(self, i, X, Y, Z, distance) -> None:
		r"""
		Get the position, in both global and local coords, of each original input slice location 
		Params:
			i (int): index of this location (must be in range 0..IFBeamShellSlice.getNumberLocations - 1)
			X (float): location of this location (global model coords)
			Y (float): location of this location (global model coords)
			Z (float): location of this location (global model coords)
			distance (float): location of this location (distance along slice path)
		Returns:
			None: 
		"""
		pass


	def getResultsLocation(self, i, X, Y, Z, distance) -> None:
		r"""
		Get the position, in both global and local coords, of the location of each set of results 
		Params:
			i (int): index of this result (must be in range 0..IFBeamShellSlice.getNumberResults - 1)
			X (float): location of this result (global model coords)
			Y (float): location of this result (global model coords)
			Z (float): location of this result (global model coords)
			distance (float): location of this result (distance along slice path)
		Returns:
			None: 
		"""
		pass


	def setUndeformedPos(self, posIndex, X, Y, Z) -> None:
		r"""
		Set the undeformed centroid position 
		Params:
			posIndex (int): slice location index
			X (float): x ccordinate
			Y (float): y ccordinate
			Z (float): z ccordinate
		Returns:
			None: 
		"""
		pass


	def setDeformedPos(self, posIndex, X, Y, Z) -> None:
		r"""
		Set the deformed centroid position 
		Params:
			posIndex (int): slice location index
			X (float): x ccordinate
			Y (float): y ccordinate
			Z (float): z ccordinate
		Returns:
			None: 
		"""
		pass


class IFCompositeDesignMember(IFBeamShellSlice):
	"""
	implementation of the "composite design member" object. 
	"""

	pass


class IFLoading(IFAttribute):
	"""
	Base class for all load attributes 
	"""

	pass


class IFLoadingBeamDistributed(IFLoading):
	"""
	Beam distributed loading attribute 
	"""

	def setBeamDistributed(self, type, dirType, position=None) -> IFLoadingBeamDistributed:
		r"""
		Sets up a beam distributed loading attribute. 
		Params:
			type (str): "parametric" or "actual"
			dirType (str): "local", "global", or "projected"
			position (str, optional): axis position: "nodal" or "beam"
		Returns:
			IFLoadingBeamDistributed: 
		"""
		pass


	def addRow(self, startDist, startpx, startpy, startpz, startmx, startmy, startmz, endDist, endpx, endpy, endpz, endmx, endmy, endmz) -> IFLoadingBeamDistributed:
		r"""
		Adds a row 
		Params:
			startDist (float): 
			startpx (float): 
			startpy (float): 
			startpz (float): 
			startmx (float): 
			startmy (float): 
			startmz (float): 
			endDist (float): 
			endpx (float): 
			endpy (float): 
			endpz (float): 
			endmx (float): 
			endmy (float): 
			endmz (float): 
		Returns:
			IFLoadingBeamDistributed: 
		"""
		pass


class IFLoadingBeamPoint(IFLoading):
	"""
	Beam point loading attribute 
	"""

	def setBeamPoint(self, type, dirType, position=None) -> IFLoadingBeamPoint:
		r"""
		Sets up a beam point loading attribute. 
		Params:
			type (str): "parametric" or "actual"
			dirType (str): "local" or "global"
			position (str, optional): axis position: "nodal" or "beam"
		Returns:
			IFLoadingBeamPoint: 
		"""
		pass


	def addRow(self, distance, loadpx, loadpy, loadpz, loadmx, loadmy, loadmz) -> IFLoadingBeamPoint:
		r"""
		Adds a row 
		Params:
			distance (float): 
			loadpx (float): 
			loadpy (float): 
			loadpz (float): 
			loadmx (float): 
			loadmy (float): 
			loadmz (float): 
		Returns:
			IFLoadingBeamPoint: 
		"""
		pass


class IFLoadingConcentrated(IFLoading):
	"""
	Concentrated structural loading attribute 
	"""

	def setConcentrated(self, px, py, pz=None, mx=None, my=None, mz=None, loof1=None, loof2=None, pore=None, biMoment=None) -> IFLoadingConcentrated:
		r"""
		Sets up a concentrated structural loading attribute. 
		Params:
			px (IFVariationAttr or float): concentrated load in X
			py (IFVariationAttr or float): concentrated load in Y
			pz (IFVariationAttr or float, optional): concentrated load in Z (default = 0.0)
			mx (IFVariationAttr or float, optional): concentrated moment in X (default = 0.0)
			my (IFVariationAttr or float, optional): concentrated moment in Y (default = 0.0)
			mz (IFVariationAttr or float, optional): concentrated moment in Z (default = 0.0)
			loof1 (IFVariationAttr or float, optional): loof 1 / hinge rotation (default = 0.0)
			loof2 (IFVariationAttr or float, optional): loof 2 / hinge rotation (default = 0.0)
			pore (IFVariationAttr or float, optional): pore pressure (default = 0.0)
			biMoment (IFVariationAttr or float, optional): torsional warping (default = 0.0)
		Returns:
			IFLoadingConcentrated: 
		"""
		pass


class IFLoadingBody(IFLoading):
	"""
	Body force loading attribute 
	"""

	def setBody(self, accX, accY, accZ=None, angVelX=None, angVelY=None, angVelZ=None, angAccX=None, angAccY=None, angAccZ=None, fluidAccX=None, fluidAccY=None, fluidAccZ=None) -> IFLoadingBody:
		r"""
		Sets up a body force loading attribute. 
		Params:
			accX (IFVariationAttr or float): linear acceleration in global direction
			accY (IFVariationAttr or float): linear acceleration in global direction
			accZ (IFVariationAttr or float, optional): linear acceleration in global direction (default = 0.0)
			angVelX (IFVariationAttr or float, optional): angular velocity about global axis (default = 0.0)
			angVelY (IFVariationAttr or float, optional): angular velocity about global axis (default = 0.0)
			angVelZ (IFVariationAttr or float, optional): angular velocity about global axis (default = 0.0)
			angAccX (IFVariationAttr or float, optional): angular acceleration about global axis (default = 0.0)
			angAccY (IFVariationAttr or float, optional): angular acceleration about global axis (default = 0.0)
			angAccZ (IFVariationAttr or float, optional): angular acceleration about global axis (default = 0.0)
			fluidAccX (IFVariationAttr or float, optional): linear acceleration in global direction applied to fluid phase (default = 0.0)
			fluidAccY (IFVariationAttr or float, optional): linear acceleration in global direction applied to fluid phase (default = 0.0)
			fluidAccZ (IFVariationAttr or float, optional): linear acceleration in global direction applied to fluid phase (default = 0.0)
		Returns:
			IFLoadingBody: 
		"""
		pass


class IFLoadingGravity(IFLoading):
	"""
	Gravity loading attribute 
	"""

	pass


class IFLoadingTemperature(IFLoading):
	"""
	Temperature loading attribute 
	"""

	def setTemperature(self, type, temp, dTdX=None, dTdY=None, dTdZ=None, T0=None, dT0dX=None, dT0dY=None, dT0dZ=None) -> IFLoadingTemperature:
		r"""
		Sets up a temperature loading attribute. 
		Params:
			type (str): 'nodal' or 'element'
			temp (IFVariationAttr or float): temperature
			dTdX (object, optional): {dT/dX}<realvariation> temperature gradient along X (default = 0.0)
			dTdY (object, optional): {dT/dY}<realvariation> temperature gradient along Y (default = 0.0)
			dTdZ (object, optional): {dT/dZ}<realvariation> temperature gradient along Z (default = 0.0)
			T0 (IFVariationAttr or float, optional): initial temperature (default = 0.0)
			dT0dX (object, optional): {dT0/dX}<realvariation> initial temperature gradient along X (default = 0.0)
			dT0dY (object, optional): {dT0/dY}<realvariation> initial temperature gradient along Y (default = 0.0)
			dT0dZ (object, optional): {dT0/dZ}<realvariation> initial temperature gradient along Z (default = 0.0)
		Returns:
			IFLoadingTemperature: 
		"""
		pass


class IFLoadingStressStrain(IFLoading):
	"""
	Initial stress/strain loading 
	"""

	def setStressStrain(self, type, values, eleType1=None, eleType2=None, eleType3=None) -> IFLoadingStressStrain:
		r"""
		Sets up an initial stress/strain loading The number of values required will depend on the element type and whether the load is to be initial or residual. For initial loading, both stresses and strains should be provided. For residual loading, only stresses should be provided To determine the number of stress values that are appropriate to a particular element type, see the element reference manual The element type can be given in either of two different ways - by feature type and description, e.g. "line - thick non linear beam" or by element name, .e.g "BMS3". Once defined, a stress and strain load can be assigned to any element type of the same stress model. 
		Params:
			type (str): 'Initial' or 'Residual'
			values (array of realvariation): see above
			eleType1 (str, optional): feature type - e.g. "line", "surface" etc or element type - e.g. "BMS3", "QTS8" etc
			eleType2 (str, optional): Only needed if 'eleType1' above is given as a feature type, in which case further clarifies element type, e.g. "Thick nonlinear beam"
			eleType3 (int, optional): Only needed if 'eleType1' above is given as a feature type, in which case further clarifies 2d or 3d (by value 2 or 3)
		Returns:
			IFLoadingStressStrain: 
		"""
		pass


class IFLoadingFace(IFLoading):
	"""
	Face loading attribute 
	"""

	def setFace(self, px, py, pz=None, pwp=None) -> IFLoadingFace:
		r"""
		Sets up a face loading attribute. 
		Params:
			px (IFVariationAttr or float): face pressure in local X
			py (IFVariationAttr or float): face pressure in local Y
			pz (IFVariationAttr or float, optional): face pressure in local Z (default = 0.0)
			pwp (IFVariationAttr or float, optional): pore pressure flux
		Returns:
			IFLoadingFace: 
		"""
		pass


class IFLoadingTendon(IFLoading):
	"""
	Tendon loading attribute 
	"""

	def setForce(self, force) -> IFLoadingTendon:
		r"""
		Sets the tendon force 
		Params:
			force (float): 
		Returns:
			IFLoadingTendon: 
		"""
		pass


	def setJackingEnd(self, end, angle, slip) -> IFLoadingTendon:
		r"""
		Set the jacking end of the tendon loading 
		Params:
			end (int): 1 or 2
			angle (float): angle
			slip (float): slip
		Returns:
			IFLoadingTendon: 
		"""
		pass


	def unsetJackingEnd(self, end) -> IFLoadingTendon:
		r"""
		Unset the jacking on the given end 
		Params:
			end (int): 1 or 2
		Returns:
			IFLoadingTendon: 
		"""
		pass


	def setProfile(self, attribute) -> IFLoadingTendon:
		r"""
		Set the profile attribute 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. tendon profile attribute
		Returns:
			IFLoadingTendon: 
		"""
		pass


	def setProperty(self, attribute) -> IFLoadingTendon:
		r"""
		Set the property attribute 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. tendon property attribute
		Returns:
			IFLoadingTendon: 
		"""
		pass


class IFFieldFaceLoading(IFLoading):
	"""
	 
	"""

	def setFlux(self, flux, isHygro=None, moistureFlux=None) -> IFFieldFaceLoading:
		r"""
		Sets up a distributed flux loading attribute. 
		Params:
			flux (IFVariationAttr or float): 
			isHygro (bool, optional): True if hygro-thermal
			moistureFlux (IFVariationAttr or float, optional): 
		Returns:
			IFFieldFaceLoading: 
		"""
		pass


class IFLoadingGlobalDistributed(IFLoading):
	"""
	Global distributed loading attribute 
	"""

	def setGlobalDistributed(self, type, wx, wy, wz=None, mx=None, my=None, mz=None, loof1=None, loof2=None, keepGlobal=None, porePressire=None) -> IFLoadingGlobalDistributed:
		r"""
		Sets up a global distributed loading attribute. 
		Params:
			type (str): 'Total','Length', or 'Area'
			wx (IFVariationAttr or float): global distributed load value in X
			wy (IFVariationAttr or float): global distributed load value in Y
			wz (IFVariationAttr or float, optional): global distributed load value in Z (default = 0.0)
			mx (IFVariationAttr or float, optional): global distributed moment in X (default = 0.0)
			my (IFVariationAttr or float, optional): global distributed moment in Y (default = 0.0)
			mz (IFVariationAttr or float, optional): global distributed moment in Z (default = 0.0)
			loof1 (IFVariationAttr or float, optional): loof 1 / hinge rotation (default = 0.0)
			loof2 (IFVariationAttr or float, optional): loof 2 / hinge rotation (default = 0.0)
			keepGlobal (bool, optional): if T undo any transformed freedoms to keep loads in the global direction (default false)
			porePressire (IFVariationAttr or float, optional): pre pressure flux (default = 0.0)
		Returns:
			IFLoadingGlobalDistributed: 
		"""
		pass


class IFLoadingLocalDistributed(IFLoading):
	"""
	Local distributed loading attribute 
	"""

	def setLocalDistributed(self, wx, wy, wz=None, type=None) -> IFLoadingLocalDistributed:
		r"""
		Sets up a local distributed loading attribute. 
		Params:
			wx (IFVariationAttr or float): uniformly distributed load in X
			wy (IFVariationAttr or float): uniformly distributed load in Y
			wz (IFVariationAttr or float, optional): uniformly distributed load in Z (default = 0.0)
			type (str, optional): distributed type
		Returns:
			IFLoadingLocalDistributed: 
		"""
		pass


class IFPrescribedDisplacementLoad(IFLoading):
	"""
	 
	"""

	def setDisplacement(self, freedom, load) -> IFPrescribedDisplacementLoad:
		r"""
		set the displacement for a freedom 
		Params:
			freedom (str): freedom
			load (IFVariationAttr or float): displacement
		Returns:
			IFPrescribedDisplacementLoad: 
		"""
		pass


class IFPrescribedVelocityLoad(IFLoading):
	"""
	 
	"""

	def setVelocity(self, freedom, load) -> IFPrescribedVelocityLoad:
		r"""
		set the velocity for a freedom 
		Params:
			freedom (str): freedom
			load (IFVariationAttr or float): displacement
		Returns:
			IFPrescribedVelocityLoad: 
		"""
		pass


class IFPrescribedAccelerationLoad(IFLoading):
	"""
	 
	"""

	def setAcceleration(self, freedom, load) -> IFPrescribedAccelerationLoad:
		r"""
		set the acceleration for a freedom 
		Params:
			freedom (str): freedom
			load (IFVariationAttr or float): displacement
		Returns:
			IFPrescribedAccelerationLoad: 
		"""
		pass


class IFLoadingFlux(IFLoading):
	"""
	Creates a concentrated flux loading attribute 
	"""

	def setFlux(self, type, FLUX, isHygro=None, liquidFlux=None) -> IFLoadingFlux:
		r"""
		Sets up a concentrated flux loading attribute. 
		Params:
			type (str): 
			FLUX (IFVariationAttr or float): 
			isHygro (bool, optional): True if hygro-thermal
			liquidFlux (IFVariationAttr or float, optional): 
		Returns:
			IFLoadingFlux: 
		"""
		pass


class IFPrescribedTemperatureLoad(IFLoading):
	"""
	 
	"""

	def setType(self, type) -> IFPrescribedTemperatureLoad:
		r"""
		set the temperature 
		Params:
			type (str): "incremental" or "total"
		Returns:
			IFPrescribedTemperatureLoad: 
		"""
		pass


	def setTemperature(self, freedom, load) -> IFPrescribedTemperatureLoad:
		r"""
		set the temperature 
		Params:
			freedom (str): freedom "PHI"
			load (IFVariationAttr or float): temperature
		Returns:
			IFPrescribedTemperatureLoad: 
		"""
		pass


	def setHumidity(self, humidity) -> IFPrescribedTemperatureLoad:
		r"""
		set the humidity 
		Params:
			humidity (IFVariationAttr or float): humidity
		Returns:
			IFPrescribedTemperatureLoad: 
		"""
		pass


	def setSaturation(self, saturation) -> IFPrescribedTemperatureLoad:
		r"""
		set the saturation 
		Params:
			saturation (IFVariationAttr or float): saturation
		Returns:
			IFPrescribedTemperatureLoad: 
		"""
		pass


class IFLoadingInitialTemperature(IFLoading):
	"""
	 
	"""

	def setInitial(self, type, temp, dof2Type, value, isLiquid=None) -> IFLoadingInitialTemperature:
		r"""
		Sets up an initial temperature loading attribute for hygro analysis. 
		Params:
			type (str): "Nodal" or "Element"
			temp (object): temperature <realvariation>
			dof2Type (str): humidity or saturation
			value (IFVariationAttr or float): humidity or saturation
			isLiquid (bool, optional): is liquid or set concrete
		Returns:
			IFLoadingInitialTemperature: 
		"""
		pass


	def setInitialThermal(self, type, temp) -> IFLoadingInitialTemperature:
		r"""
		Sets up an initial temperature loading attribute for thermal analysis. 
		Params:
			type (str): "Nodal" or "Element"
			temp (object): temperature <realvariation>
		Returns:
			IFLoadingInitialTemperature: 
		"""
		pass


class IFLoadingEnvironmental(IFLoading):
	"""
	Environmental loading attribute 
	"""

	def setEnvironmental(self) -> IFLoadingEnvironmental:
		r"""
		Sets up an environmental loading attribute. 
		Returns:
			IFLoadingEnvironmental: 
		"""
		pass


	def addRow(self, Environmental, Convective, Radiation, temp, isHygro=None, relativeHumidity=None, vapourMassTransfer=None, useChiltonColburn=None) -> IFLoadingEnvironmental:
		r"""
		 
		Params:
			Environmental (IFVariationAttr or float): environmental temperature
			Convective (IFVariationAttr or float): convective coefficient
			Radiation (IFVariationAttr or float): radiation coefficient
			temp (float): reference temperature
			isHygro (bool, optional): true for hygro false for thermal
			relativeHumidity (IFVariationAttr or float, optional): relative humidity
			vapourMassTransfer (IFVariationAttr or float, optional): vapour mass transfer coefficient
			useChiltonColburn (bool, optional): true for Chilton Colburn analogy for vapour mass transfer coefficient
		Returns:
			IFLoadingEnvironmental: 
		"""
		pass


class IFInternalHeatLoading(IFLoading):
	"""
	 
	"""

	def setInternalHeat(self) -> IFInternalHeatLoading:
		r"""
		Sets up an internal heat loading attribute. 
		Returns:
			IFInternalHeatLoading: 
		"""
		pass


	def addRow(self, internalHeat, temp=None, isHygro=None, moistureHeat=None) -> IFInternalHeatLoading:
		r"""
		Adds a row 
		Params:
			internalHeat (IFVariationAttr or float): internal heat gen.
			temp (float, optional): Reference temperature
			isHygro (booelan, optional): true for hygro false for thermal
			moistureHeat (IFVariationAttr or float, optional): hygro moisture water heat gen.
		Returns:
			IFInternalHeatLoading: 
		"""
		pass


class IFInternalHeatUserLoading(IFLoading):
	"""
	 
	"""

	def addRow(self, data, temperature) -> IFInternalHeatUserLoading:
		r"""
		Uses the given array of data to represent the given temperature. This is equivalent to a 'row' in the internal heat definition dialog in Modeller's user interface. The number of items in the array dictates the number of columns 
		Params:
			data (array of realvariation): 
			temperature (float): 
		Returns:
			IFInternalHeatUserLoading: 
		"""
		pass


class IFLoadingDiscreteBase(IFLoading):
	"""
	Common base class for IFLoadingDiscrete and IFDiscreteCompoundLoading 
	"""

	pass


class IFLoadingDiscrete(IFLoadingDiscreteBase):
	"""
	Discrete loading attribute 
	"""

	def addRow(self, coordX, coordY, coordZ, load, load2=None, load3=None) -> IFLoadingDiscretePoint:
		r"""
		Adds a row 
		Params:
			coordX (float): position of load
			coordY (float): position of load
			coordZ (float): position of load
			load (float): value of load
			load2 (float, optional): value of load (only used if the direction type is 'XYZ')
			load3 (float, optional): value of load (only used if the direction type is 'XYZ')
		Returns:
			IFLoadingDiscretePoint: 
		"""
		pass


	def addRowData(self, data, componentsPerSet=None) -> IFLoadingDiscretePoint:
		r"""
		Adds a row 
		Params:
			data (array of float): data vector, x,y, z, loading ...
			componentsPerSet (int, optional): number of values in a single set of data
		Returns:
			IFLoadingDiscretePoint: 
		"""
		pass


	def setGridSizes(self, xGridSize, yGridSize) -> IFLoadingDiscretePoint:
		r"""
		Sets discrete load grid size 
		Params:
			xGridSize (int): 
			yGridSize (int): 
		Returns:
			IFLoadingDiscretePoint: 
		"""
		pass


	def getDiscreteLoadType(self) -> str:
		r"""
		Return the type of discrete load 
		Returns:
			str: 
		"""
		pass


class IFLoadingDiscretePoint(IFLoadingDiscrete):
	"""
	Discrete point loading attribute 
	"""

	def setDiscrete(self, dirType, Dir, nGridX=None, nGridY=None) -> IFLoadingDiscretePoint:
		r"""
		Sets up a discrete point loading attribute. 
		Params:
			dirType (str): untransformed load direction 'X','Y','Z','Normal','None','globalXYZ','transformXYZ'
			Dir (array of float): An array of 3 real numbers, representing 3d coordinates projection vector
			nGridX (int, optional): number of grid points in X (default = 0)
			nGridY (int, optional): number of grid points in Y (default = 0)
		Returns:
			IFLoadingDiscretePoint: 
		"""
		pass


class IFLoadingDiscretePatch(IFLoadingDiscrete):
	"""
	Discrete patch loading attribute 
	"""

	def setDiscretePatch(self, type, dirType, Dir=None) -> IFLoadingDiscretePatch:
		r"""
		Sets up a discrete patch loading attribute. 
		Params:
			type (str): 'surf8','surf4','line3','line2','multiQuad','multiStraight'
			dirType (str): untransformed load direction 'X','Y','Z','Normal','None','patchX','patchY','globalXYZ','transformXYZ'
			Dir (array of float, optional): An array of 3 real numbers, representing 3d coordinates projection vector (default = [0,0,1])
		Returns:
			IFLoadingDiscretePatch: 
		"""
		pass


	def setSweptAngleDegrees(self, angleDegrees) -> IFLoadingDiscretePatch:
		r"""
		Sets the swept angle for a disc patch. 
		Params:
			angleDegrees (float): 
		Returns:
			IFLoadingDiscretePatch: 
		"""
		pass


	def setDivisions(self, xDivs, yDivs) -> IFLoadingDiscretePatch:
		r"""
		Sets the number of patch divisions in local x and y 
		Params:
			xDivs (int): >= 0, zero indicates default
			yDivs (int): >= 0, zero indicates default
		Returns:
			IFLoadingDiscretePatch: 
		"""
		pass


class IFDiscreteFluxPointLoading(IFLoadingDiscretePoint):
	"""
	Discrete point flux loading attribute 
	"""

	pass


class IFDiscreteHeatPointLoading(IFLoadingDiscretePoint):
	"""
	Discrete point internal heat loading attribute 
	"""

	pass


class IFDiscreteENVTLoading(IFLoadingDiscretePatch):
	"""
	Discrete patch ENVT loading attribute 
	"""

	pass


class IFDiscreteFluxPatchLoading(IFLoadingDiscretePatch):
	"""
	Discrete patch flux loading attribute 
	"""

	pass


class IFDiscreteHeatPatchLoading(IFLoadingDiscretePatch):
	"""
	Discrete patch flux loading attribute 
	"""

	pass


class IFDiscreteCompoundLoading(IFLoadingDiscreteBase):
	"""
	Discrete compound loading attribute 
	"""

	def countLoading(self) -> int:
		r"""
		Return the number of defining loads 
		Returns:
			int: 
		"""
		pass


	def addLoading(self, pLoadingAttr, pOffsetCoord=None, pTransAttr=None, haveTrans=None, factor=None) -> IFDiscreteCompoundLoading:
		r"""
		Add discrete loading attribute to this compound attribute 
		Params:
			pLoadingAttr (IFLoading): discrete loading attribute to add
			pOffsetCoord (array of float, optional): An array of 3 real numbers, representing 3d coordinates optional offset coordinates
			pTransAttr (IFTransformationAttr, optional): optional transformation to apply
			haveTrans (bool, optional): optional boolean to indicate if using transformation attribute
			factor (float, optional): optional factor on the load, default 1.0
		Returns:
			IFDiscreteCompoundLoading: 
		"""
		pass


	def removeLoading(self, pLoadingAttr) -> IFDiscreteCompoundLoading:
		r"""
		remove the given discrete loading attribute from compound attribute, this function will remove a single occurrence 
		Params:
			pLoadingAttr (IFLoading): discrete loading attribute to remove
		Returns:
			IFDiscreteCompoundLoading: 
		"""
		pass


	def getOffsetCoordinates(self, index) -> list[float]:
		r"""
		get the offset coordinates given the index into the defining loads array 
		Params:
			index (int): zero base index
		Returns:
			array of float: 
		"""
		pass


	def getLoading(self, index) -> IFLoading:
		r"""
		get the loading attribute given the index into the defining loads array 
		Params:
			index (int): zero base index
		Returns:
			IFLoading: returned attribute
		"""
		pass


	def hasTransformation(self, index) -> bool:
		r"""
		return true if the given the index into the defining loads array has a transformation attribute 
		Params:
			index (int): zero base index
		Returns:
			bool: 
		"""
		pass


	def getTransformation(self, index) -> IFTransformationAttr:
		r"""
		get the transformation attribute given the index into the defining loads array 
		Params:
			index (int): zero base index
		Returns:
			IFTransformationAttr: returned attribute
		"""
		pass


	def getDiscreteLoadType(self) -> str:
		r"""
		Return the type of discrete load 
		Returns:
			str: 
		"""
		pass


	def getFactor(self, index) -> float:
		r"""
		return teh load factor given the index into the defining loads array 
		Params:
			index (int): load factor
		Returns:
			float: 
		"""
		pass


	def hasPointGridOrPatch(self) -> bool:
		r"""
		Returns true if this compound load contains any point grid or patch load, the function recurses any compound loads defining this compoint load 
		Returns:
			bool: 
		"""
		pass


class IFInitialVelocityLoad(IFLoading):
	"""
	 
	"""

	def setVelocity(self, freedom, load) -> IFInitialVelocityLoad:
		r"""
		set the velocity for a freedom 
		Params:
			freedom (str): freedom
			load (IFVariationAttr or float): displacement
		Returns:
			IFInitialVelocityLoad: 
		"""
		pass


class IFInitialAccelerationLoad(IFLoading):
	"""
	 
	"""

	def setAcceleration(self, freedom, load) -> IFInitialAccelerationLoad:
		r"""
		set the acceleration for a freedom 
		Params:
			freedom (str): freedom
			load (IFVariationAttr or float): displacement
		Returns:
			IFInitialAccelerationLoad: 
		"""
		pass


class IFSurfDistrLoading(IFLoading):
	"""
	Surface distributed loading attribute 
	"""

	def setDistributionType(self, type, distributionAngle=None) -> IFSurfDistrLoading:
		r"""
		set the distribution type 
		Params:
			type (str): type, "one_way", ....
			distributionAngle (float, optional): one-way loading distribution angle
		Returns:
			IFSurfDistrLoading: 
		"""
		pass


	def setLoadDirection(self, type, localCoords=None) -> IFSurfDistrLoading:
		r"""
		set the loading direction type 
		Params:
			type (str): type, "globalX", ....
			localCoords (IFLocalCoord, optional): The name or ID of a localcoord, or a pointer to a IFLocalCoord object. local coordinates for local directions
		Returns:
			IFSurfDistrLoading: 
		"""
		pass


	def setRefDirection(self, type, localCoords=None) -> IFSurfDistrLoading:
		r"""
		set the reference direction type 
		Params:
			type (str): type, "surfaceZ", ....
			localCoords (IFLocalCoord, optional): The name or ID of a localcoord, or a pointer to a IFLocalCoord object. local coordinates for local directions
		Returns:
			IFSurfDistrLoading: 
		"""
		pass


	def setSubBeamData(self, numberSubBeams, subBeamAngle, subBeamLoadIntensity=None) -> IFSurfDistrLoading:
		r"""
		set the sub-beam definition data 
		Params:
			numberSubBeams (int): number of sub-beams
			subBeamAngle (float): sub-beam angle
			subBeamLoadIntensity (IFVariationAttr or float, optional): sub-beam load intensity
		Returns:
			IFSurfDistrLoading: 
		"""
		pass


	def setLoading(self, surfLoadIntensity, areaLoadFactorExpr=None, scalingType=None) -> IFSurfDistrLoading:
		r"""
		set the loading 
		Params:
			surfLoadIntensity (IFVariationAttr or float): surface load intensity
			areaLoadFactorExpr (str, optional): Any function of area that evaluates to a number, note all numbers must be in US English, i.e. "1.2", not the current locale (e.g. Italian/Swedish/French "1,2")
			scalingType (str, optional): load scaling type
		Returns:
			IFSurfDistrLoading: 
		"""
		pass


	def setAspectRatio(self, aspectRatio) -> IFSurfDistrLoading:
		r"""
		set the aspect ratio to change from two-way to one-way loading, the aspect ratio is always > 1.0, values less than the limit are two-way loading, values greater than the limit are one-way loading, 
		Params:
			aspectRatio (float): type, "one_way", ....
		Returns:
			IFSurfDistrLoading: 
		"""
		pass


class IFTemperatureProfileLoad(IFLoading):
	"""
	Temperature profile loading attribute 
	"""

	def setForceType(self, type) -> IFTemperatureProfileLoad:
		r"""
		set the applied force type 
		Params:
			type (str): type, "axial", ....
		Returns:
			IFTemperatureProfileLoad: 
		"""
		pass


	def setLoadDirection(self, type) -> IFTemperatureProfileLoad:
		r"""
		set the loading direction type 
		Params:
			type (str): type, "local y", ....
		Returns:
			IFTemperatureProfileLoad: 
		"""
		pass


	def setTopTemperature(self, temperature) -> IFTemperatureProfileLoad:
		r"""
		set the temperature of the highest most point in the section 
		Params:
			temperature (str): function in H/s for temperature
		Returns:
			IFTemperatureProfileLoad: 
		"""
		pass


	def setBottomTemperature(self, temperature) -> IFTemperatureProfileLoad:
		r"""
		set the temperature of the lowest point in the section 
		Params:
			temperature (str): function in H/s for temperature
		Returns:
			IFTemperatureProfileLoad: 
		"""
		pass


	def setThicknessTolerance(self, tolerance) -> IFTemperatureProfileLoad:
		r"""
		set the tolerance for checking negative segment thickness 
		Params:
			tolerance (float): thickness is valid if >= (0.0 - tolerance)
		Returns:
			IFTemperatureProfileLoad: 
		"""
		pass


	def addUpperRow(self, thickness, temperature) -> IFTemperatureProfileLoad:
		r"""
		add a temperature over thickness section down from the top 
		Params:
			thickness (str): function in H defining the depth over which the temperature acts
			temperature (str): function in H/s for temperature
		Returns:
			IFTemperatureProfileLoad: 
		"""
		pass


	def addLowerRow(self, thickness, temperature) -> IFTemperatureProfileLoad:
		r"""
		add a temperature over thickness section up from the bottom 
		Params:
			thickness (str): function in H defining the depth over which the temperature acts
			temperature (str): function in H/s for temperature
		Returns:
			IFTemperatureProfileLoad: 
		"""
		pass


	def getTemperature(self, totalSectionHeight, specificHeight, pTemperature) -> int:
		r"""
		evaluate the temperature at the given height 
		Params:
			totalSectionHeight (float): total section height
			specificHeight (float): height at which to calculate the temperature
			pTemperature (float): temperature at the given height
		Returns:
			int: on exit, 0 = success, else error
		"""
		pass


	def getStressProfile(self, nrmCrd, beamSectionAttr, materialAttr, numberPoints, pForce, pMoment, pSectionMaterials, pSectionHeights, pStressProfiles) -> int:
		r"""
		integrate this temperature profile over the given beam section and return the stress profile for each material in the section 
		Params:
			nrmCrd (float): normalised coord along the beam
			beamSectionAttr (IFGeometricLine): The name or ID of a name, or a pointer to a IFGeometricLine object. beam section attribute
			materialAttr (IFMaterial): The name or ID of a name, or a pointer to a IFMaterial object. material attribute
			numberPoints (int): number of point at which to evaluate the profile, <= 0 for the default
			pForce (float): axial force in the beam
			pMoment (float): moment about the neutral axis
			pSectionMaterials (IFMaterial): array of materials
			pSectionHeights (float): array of section heights
			pStressProfiles (float): 2d array, height and stress
		Returns:
			int: on exit, 0 = success, -1 = different materials overlap in the perpendicular slice direction, -2 = no active polygons in the section, all other values = error
		"""
		pass


class IFStrainProfileLoad(IFLoading):
	"""
	Strain profile loading attribute 
	"""

	def setForceType(self, type) -> IFStrainProfileLoad:
		r"""
		set the applied force type 
		Params:
			type (str): type, "axial", ....
		Returns:
			IFStrainProfileLoad: 
		"""
		pass


	def setLoadDirection(self, type) -> IFStrainProfileLoad:
		r"""
		set the loading direction type 
		Params:
			type (str): type, "local y", ....
		Returns:
			IFStrainProfileLoad: 
		"""
		pass


	def setTopStrain(self, strain) -> IFStrainProfileLoad:
		r"""
		set the strain of the highest most point in the section 
		Params:
			strain (str): function in H/s for strain
		Returns:
			IFStrainProfileLoad: 
		"""
		pass


	def setBottomStrain(self, strain) -> IFStrainProfileLoad:
		r"""
		set the strain of the lowest point in the section 
		Params:
			strain (str): function in H/s for strain
		Returns:
			IFStrainProfileLoad: 
		"""
		pass


	def setThicknessTolerance(self, tolerance) -> IFStrainProfileLoad:
		r"""
		set the tolerance for checking negative segment thickness 
		Params:
			tolerance (float): thickness is valid if >= (0.0 - tolerance)
		Returns:
			IFStrainProfileLoad: 
		"""
		pass


	def addUpperRow(self, thickness, strain) -> IFStrainProfileLoad:
		r"""
		add a strain over thickness section down from the top 
		Params:
			thickness (str): function in H defining the depth over which the temperature acts
			strain (str): function in H/s for strain
		Returns:
			IFStrainProfileLoad: 
		"""
		pass


	def addLowerRow(self, thickness, strain) -> IFStrainProfileLoad:
		r"""
		add a strain over thickness section up from the bottom 
		Params:
			thickness (str): function in H defining the depth over which the temperature acts
			strain (str): function in H/s for strain
		Returns:
			IFStrainProfileLoad: 
		"""
		pass


	def getStrain(self, totalSectionHeight, specificHeight, pStrain) -> int:
		r"""
		evaluate the strain at the given height 
		Params:
			totalSectionHeight (float): total section height
			specificHeight (float): height at which to calculate the strain
			pStrain (float): strain at the given height
		Returns:
			int: on exit, 0 = success, else error
		"""
		pass


	def getStressProfile(self, nrmCrd, beamSectionAttr, materialAttr, numberPoints, pForce, pMoment, pSectionMaterials, pSectionHeights, pStressProfiles) -> int:
		r"""
		integrate this strain profile over the given beam section and return the stress profile for each material in the section 
		Params:
			nrmCrd (float): normalised coord along the beam
			beamSectionAttr (IFGeometricLine): The name or ID of a name, or a pointer to a IFGeometricLine object. beam section attribute
			materialAttr (IFMaterial): The name or ID of a name, or a pointer to a IFMaterial object. material attribute
			numberPoints (int): number of point at which to evaluate the profile, <= 0 for the default
			pForce (float): axial force in the beam
			pMoment (float): moment about the neutral axis
			pSectionMaterials (IFMaterial): array of materials
			pSectionHeights (float): array of section heights
			pStressProfiles (float): 2d array, height and stress
		Returns:
			int: on exit, 0 = success, -1 = different materials overlap in the perpendicular slice direction, -2 = no active polygons in the section, all other values = error
		"""
		pass


class IFWaterPressureDistrLoad(IFLoading):
	"""
	Water Pressure Distribution loading 
	"""

	def setDensity(self, density) -> IFWaterPressureDistrLoad:
		r"""
		Sets the fluid density 
		Params:
			density (float): 
		Returns:
			IFWaterPressureDistrLoad: 
		"""
		pass


	def setOnlyPoreWaterPressure(self, doNodePressure) -> IFWaterPressureDistrLoad:
		r"""
		tabulate node or face pressure 
		Params:
			doNodePressure (bool): 
		Returns:
			IFWaterPressureDistrLoad: 
		"""
		pass


	def setPhreatic(self, attribute, assignType=None) -> IFWaterPressureDistrLoad:
		r"""
		Set the phreatic attribute and assignment type 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. WPDL phreatic attribute
			assignType (str, optional): "faces" or "continuum"
		Returns:
			IFWaterPressureDistrLoad: 
		"""
		pass


	def setProfile(self, attribute) -> IFWaterPressureDistrLoad:
		r"""
		Set the profile attribute 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. tendon profile attribute
		Returns:
			IFWaterPressureDistrLoad: 
		"""
		pass


class IFBeamProjectedPressureLoad(IFLoading):
	"""
	Beam Projected Pressure loading 
	"""

	def setLoadDirection(self, type, localCoords=None) -> IFBeamProjectedPressureLoad:
		r"""
		set the loading direction type 
		Params:
			type (str): type, "globalX", ....
			localCoords (IFLocalCoord, optional): The name or ID of a localcoord, or a pointer to a IFLocalCoord object. local coordinates for local directions
		Returns:
			IFBeamProjectedPressureLoad: 
		"""
		pass


	def setLoading(self, loadingPressure) -> IFBeamProjectedPressureLoad:
		r"""
		set the loading intensity 
		Params:
			loadingPressure (IFVariationAttr or float): pressure load intensity
		Returns:
			IFBeamProjectedPressureLoad: 
		"""
		pass


	def setLoadingWidth(self, type, widthParameter) -> IFBeamProjectedPressureLoad:
		r"""
		set the loading width type and parameter derived from projected section width 
		Params:
			type (str): width type, "factor", "extra", "custom"
			widthParameter (float): width factor/extra/custom value for width type
		Returns:
			IFBeamProjectedPressureLoad: 
		"""
		pass


class IFConstraint(IFAttribute):
	"""
	 
	"""

	pass


class IFConstraintConstant(IFConstraint):
	"""
	constant constraint equation 
	"""

	def setConstant(self, dof) -> IFConstraintConstant:
		r"""
		Sets up a constant constraint equation. 
		Params:
			dof (str): degree of freedom: 'u','v','w','thetax','thetay','thetaz'
		Returns:
			IFConstraintConstant: 
		"""
		pass


	def setPrimaryNode(self, primaryNodeId) -> IFConstraintConstant:
		r"""
		Sets the optional primary node id. Renamed from setMasterNode() (P768). 
		Params:
			primaryNodeId (int): primary node id'
		Returns:
			IFConstraintConstant: 
		"""
		pass


	def setPrimaryPoint(self, point) -> IFConstraintConstant:
		r"""
		Sets the optional primary point object. Renamed from setMasterPoint() (P768). 
		Params:
			point (IFPoint): The name or ID of a point, or a pointer to a IFPoint object. primary point
		Returns:
			IFConstraintConstant: 
		"""
		pass


class IFRigidFloorConstraintEqu(IFConstraint):
	"""
	Rigid floor constraint equation 
	"""

	def excludeNormalRotation(self) -> IFRigidFloorConstraintEqu:
		r"""
		
		Returns:
			IFRigidFloorConstraintEqu: 
		"""
		pass


	def includeNormalRotation(self) -> IFRigidFloorConstraintEqu:
		r"""
		
		Returns:
			IFRigidFloorConstraintEqu: 
		"""
		pass


	def setDensity(self, density) -> IFRigidFloorConstraintEqu:
		r"""
		
		Params:
			density (float): 
		Returns:
			IFRigidFloorConstraintEqu: 
		"""
		pass


	def setThickness(self, thickness) -> IFRigidFloorConstraintEqu:
		r"""
		
		Params:
			thickness (float): 
		Returns:
			IFRigidFloorConstraintEqu: 
		"""
		pass


class IFConstraintCyclic(IFConstraint):
	"""
	Cyclic constraint equation 
	"""

	pass


class IFCyclicTranslation(IFConstraint):
	"""
	 
	"""

	pass


class IFNormalTiedMeshConstraint(IFConstraint):
	"""
	 
	"""

	def setRigid(self, doRigid) -> IFNormalTiedMeshConstraint:
		r"""
		set the constraint type 
		Params:
			doRigid (bool): TRUE rigid constraints, FALSE for tied constraints
		Returns:
			IFNormalTiedMeshConstraint: 
		"""
		pass


class IFEquiDistTiedConstraint(IFConstraint):
	"""
	 
	"""

	def setRigid(self, doRigid) -> IFEquiDistTiedConstraint:
		r"""
		set the constraint type 
		Params:
			doRigid (bool): TRUE rigid constraints, FALSE for tied constraints
		Returns:
			IFEquiDistTiedConstraint: 
		"""
		pass


class IFConstraintPath(IFConstraint):
	"""
	Path constraint equation 
	"""

	def setPath(self, x1, y1, z1, x2, y2, z2) -> IFConstraintPath:
		r"""
		Sets up a path constraint equation. 
		Params:
			x1 (float): X coord of point defining start of direction of displacement
			y1 (float): Y coord of point defining start of direction of displacement
			z1 (float): Z coord of point defining start of direction of displacement
			x2 (float): X coord of point defining end of direction of displacement
			y2 (float): Y coord of point defining end of direction of displacement
			z2 (float): Z coord of point defining end of direction of displacement
		Returns:
			IFConstraintPath: 
		"""
		pass


class IFPlanarSurfaceConstraint(IFConstraint):
	"""
	 
	"""

	pass


class IFRigidDisplacementConstraint(IFConstraint):
	"""
	 
	"""

	pass


class IFRigidLinkConstraint(IFConstraint):
	"""
	 
	"""

	pass


class IFConstraintEquation(IFConstraint):
	"""
	Specified constraint equation 
	"""

	def setEquation(self, dof, value) -> IFConstraintEquation:
		r"""
		Sets up a specified constraint equation. 
		Params:
			dof (str): degree of freedom: 'u','v','w','thetax','thetay','thetaz'
			value (float): required value for the degree of freedom
		Returns:
			IFConstraintEquation: 
		"""
		pass


class IFConstraintTied(IFConstraint):
	"""
	Specified tied mesh constraint equation 
	"""

	def setTied(self, x1, y1, z1, x2, y2, z2) -> IFConstraintTied:
		r"""
		Sets up a specified tied mesh equation. 
		Params:
			x1 (float): X coord of point defining direction of primary node being tied
			y1 (float): Y coord of point defining direction of primary node being tied
			z1 (float): Z coord of point defining direction of primary node being tied
			x2 (float): X coord of point defining direction of secondary node being tied
			y2 (float): Y coord of point defining direction of secondary node being tied
			z2 (float): Z coord of point defining direction of secondary node being tied
		Returns:
			IFConstraintTied: 
		"""
		pass


	def setRigid(self, doRigid) -> IFConstraintTied:
		r"""
		set the constraint type 
		Params:
			doRigid (bool): TRUE rigid constraints, FALSE for tied constraints
		Returns:
			IFConstraintTied: 
		"""
		pass


class IFStraightLineConstraint(IFConstraint):
	"""
	 
	"""

	pass


class IFRetainedFreedom(IFAttribute):
	"""
	 
	"""

	pass


class IFRetainedStructural(IFRetainedFreedom):
	"""
	Structural retained freedom 
	"""

	def setStructural(self, u, v, w=None, thx=None, thy=None, thz=None, l1=None, l2=None, pore=None) -> IFRetainedStructural:
		r"""
		Sets up a structural retained freedom. [restraint types: 'Primary' or 'Secondary'] 
		Params:
			u (str): restraint type along X axis
			v (str): restraint type along Y axis
			w (str, optional): restraint type along Z axis (default = 'Primary')
			thx (str, optional): restraint type rotationally about X axis (default = 'Primary')
			thy (str, optional): restraint type rotationally about Y axis (default = 'Primary')
			thz (str, optional): restraint type rotationally about Z axis (default = 'Primary')
			l1 (str, optional): restraint type rotationally about loof 1 / hinge (default = 'Primary')
			l2 (str, optional): restraint type rotationally about loof 2 / hinge (default = 'Primary')
			pore (str, optional): restraint type with respect to pore pressure (default = 'Primary')
		Returns:
			IFRetainedStructural: 
		"""
		pass


class IFRetainedThermal(IFRetainedFreedom):
	"""
	thermal retained freedom 
	"""

	def setThermal(self, t) -> IFRetainedThermal:
		r"""
		Sets up a thermal retained freedom. [restraint types: 'Primary' or 'Secondary'] 
		Params:
			t (str): restraint type with respect to temperature
		Returns:
			IFRetainedThermal: 
		"""
		pass


class IFThermalProperties(IFAttribute):
	"""
	 
	"""

	pass


class IFMaterial(IFAttribute):
	"""
	Setup material attribute 
	"""

	def removeTemperatureDependence(self) -> IFAttribute:
		r"""
		Remove temperature dependence from this attribute 
		Returns:
			IFAttribute: 
		"""
		pass


	def isNonlinear(self) -> bool:
		r"""
		Return true if this material is considered to be nonlinear (e.g. has plastic, creep, and/or shrinkage behaviour) 
		Returns:
			bool: 
		"""
		pass


	def getActiveMaterial(self) -> IFMaterial:
		r"""
		Return the active material from a compound material or return this material if not a compound material 
		Returns:
			IFMaterial: 
		"""
		pass


	def haveActiveMaterial(self) -> bool:
		r"""
		Return true if this material can return an active material 
		Returns:
			bool: 
		"""
		pass


class IFAnisotropicMaterial(IFMaterial):
	"""
	 
	"""

	def addRow(self, MassDensity, Angle, Matrix, temperature=None) -> IFAnisotropicMaterial:
		r"""
		 
		Params:
			MassDensity (IFVariationAttr or float): density
			Angle (IFVariationAttr or float): 
			Matrix (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFAnisotropicMaterial: 
		"""
		pass


class IFRigiditiesMaterial(IFMaterial):
	"""
	 
	"""

	def addRow(self, massDensity, angle, Matrix, temperature=None) -> IFRigiditiesMaterial:
		r"""
		 
		Params:
			massDensity (float): density
			angle (float): 
			Matrix (array of float): 
			temperature (float, optional): temperature
		Returns:
			IFRigiditiesMaterial: 
		"""
		pass


class IFFrictionalJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFGeneralJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFNonlinearJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFSmoothJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFSpringJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFUniformJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFViscousJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFLeadRubberBearingJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFFrictionalPendulumJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFNonLinearUserJointMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFPiecewiseLinearJointMaterial(IFMaterial):
	"""
	 
	"""

	def setForceDisplacementCurve(self, dof, selected, Force=None, Displacement=None, r=None, controlForce=None, points=None) -> IFPiecewiseLinearJointMaterial:
		r"""
		Adds the force/displacement curve data to a Piecewise Linear joint material 
		Params:
			dof (int): degree of freedom
			selected (bool): TRUE for curve input, FALSE for elastic spring
			Force (array of realvariation, optional): 
			Displacement (array of realvariation, optional): 
			r (IFVariationAttr or float, optional): stiffness factor, r (default 1.0)
			controlForce (array of realvariation, optional): control forces for materials 43-47
			points (array of ints, optional): points in each curve for materials 43-47
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def setCurveDataForPMM(self, momentAngle, Moment, Rotation, r, controlForce, points) -> IFPiecewiseLinearJointMaterial:
		r"""
		Adds the moment/rotation curve data to a PMM Piecewise Linear joint material 
		Params:
			momentAngle (int): moment Angle index
			Moment (array of realvariation): 
			Rotation (array of realvariation): 
			r (IFVariationAttr or float): stiffness factor, r (default 1.0)
			controlForce (array of realvariation): control forces for material 43-47
			points (array of ints): points in each curve for material 43-47
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def setHysteresisType(self, loop, hysteresisType, unloadingRule=None) -> IFPiecewiseLinearJointMaterial:
		r"""
		Sets the hysteresis type for a Piecewise Linear joint material 
		Params:
			loop (int): loop number, 1 or 2
			hysteresisType (HysteresisType): 
			unloadingRule (UnloadingRule, optional): unloading rule where required
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def setHysteresisParams(self, dof, loop, parameters) -> IFPiecewiseLinearJointMaterial:
		r"""
		Adds the hysteresis data to a Piecewise Linear joint material 
		Params:
			dof (int): degree of freedom
			loop (int): loop number, 1 or 2
			parameters (array of realvariation): parameters specific to hysteresis type
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def setMomentAnglesForPMM(self, momentAngles) -> IFPiecewiseLinearJointMaterial:
		r"""
		Adds the moment angles to a Piecewise Linear joint material for PMM analysis 
		Params:
			momentAngles (array of float): array of moments angles in degrees
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def setNumAcceptanceCriteria(self, nac) -> IFPiecewiseLinearJointMaterial:
		r"""
		Adds the number of acceptance criteria to a Piecewise Linear joint material 
		Params:
			nac (int): number of acceptance criteria
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def setAcceptanceCriteria(self, dof, curve, parameters) -> IFPiecewiseLinearJointMaterial:
		r"""
		Adds the acceptance criteria to a Piecewise Linear joint material 
		Params:
			dof (int): degree of freedom
			curve (int): material data curve index
			parameters (array of float): array of displacements
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def setAcceptanceCriteriaPMM(self, momAngle, curve, parameters) -> IFPiecewiseLinearJointMaterial:
		r"""
		Adds the acceptance criteria to a Piecewise Linear joint material 
		Params:
			momAngle (int): moment angle index (call setAnglesForPMM first)
			curve (int): material data curve index
			parameters (array of float): array of displacements
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def useSecantStiffness(self, useSecant) -> IFPiecewiseLinearJointMaterial:
		r"""
		Use secant stiffness for handling nearly flat or softening segments 
		Params:
			useSecant (bool): TRUE for secant stiffness, FALSE for tangent stiffness
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


	def useCylindrical(self, cylindrical) -> IFPiecewiseLinearJointMaterial:
		r"""
		For Piecewise Linear (joint no rotational stiffness) material: use one lateral degree of freedom acting in all directions in the horizontal plain, and one axial (vertical axis) direction, instead of three orthoganal directions. 
		Params:
			cylindrical (bool): TRUE for two cylindrical DOFs, FALSE for three orthoganal directions
		Returns:
			IFPiecewiseLinearJointMaterial: 
		"""
		pass


class IFPlasticHingeJointMaterial(IFMaterial):
	"""
	 
	"""

	def setParameterisedCurveData(self, dof, selected, force=None, displacement=None) -> IFPlasticHingeJointMaterial:
		r"""
		Defines the parameterised curve for each DoF. The values of the actual tabulated curves will simply be these values multiplied by the computed member capacity and ultimate displacement for each dof. 
		Params:
			dof (int): degree of freedom
			selected (bool): TRUE for curve input, FALSE for elastic spring
			force (array of realvariation, optional): 
			displacement (array of realvariation, optional): 
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def getParameterisedCurveData(self, dof, selected, force, displacement) -> IFPlasticHingeJointMaterial:
		r"""
		Retrieves the parameterised curve previously set by setParameterisedCurveData 
		Params:
			dof (int): degree of freedom
			selected (bool): TRUE for curve input, FALSE for elastic spring
			force (array of realvariation): 
			displacement (array of realvariation): 
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def setAcceptanceCriteria(self, dof, positive, negative) -> IFPlasticHingeJointMaterial:
		r"""
		Defines the parameterised values of the acceptance criteria for each DoF. These values represent factors of the calculated ultimate deformation for each dof 
		Params:
			dof (int): degree of freedom
			positive (array of realvariation): 
			negative (array of realvariation): 
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def getAcceptanceCriteria(self, dof, positive, negative) -> IFPlasticHingeJointMaterial:
		r"""
		Retrieves the parameterised values of the acceptance criteria. 
		Params:
			dof (int): degree of freedom
			positive (array of realvariation): 
			negative (array of realvariation): 
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def setUltimateStrength(self, continuesFromD) -> IFPlasticHingeJointMaterial:
		r"""
		Sets whether the ultimate strength continues from 'point D' or drops to zero 
		Params:
			continuesFromD (bool): TRUE for continues, FALSE for drops to zero
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def getUltimateStrength(self) -> bool:
		r"""
		Gets whether the ultimate strength setting 
		Returns:
			bool: returned ultimate strength setting
		"""
		pass


	def setMaterialYield(self, _yield) -> IFPlasticHingeJointMaterial:
		r"""
		Sets the yield value. This value will be used in calculation of the hinge capacities 
		Params:
			_yield (float): 
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def getMaterialYield(self) -> float:
		r"""
		Gets the yield value. This value will be used in calculation of the hinge capacities 
		Returns:
			float: the returned yield value
		"""
		pass


	def setHysteresis(self, hysteresis) -> IFPlasticHingeJointMaterial:
		r"""
		Sets whether the hysteresis model is used 
		Params:
			hysteresis (bool): TRUE for hysterisis
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def getHysteresis(self) -> bool:
		r"""
		Gets whether the hysteresis model is used 
		Returns:
			bool: returned hysteresis setting
		"""
		pass


	def setJointStiffnessFactor(self, stiffnessFactor) -> IFPlasticHingeJointMaterial:
		r"""
		Sets the joint stiffness factor 
		Params:
			stiffnessFactor (float): 
		Returns:
			IFPlasticHingeJointMaterial: 
		"""
		pass


	def getJointStiffnessFactor(self) -> float:
		r"""
		Gets the joint stiffness factor 
		Returns:
			float: the returned stiffness factor
		"""
		pass


class IFPlasticHingePMMJointMaterial(IFMaterial):
	"""
	 
	"""

	def getHingeType(self) -> int:
		r"""
		Gets the interacting plastic hinge type 
		Returns:
			int: 1=Fx-My, 2=Fx-Mz, 3=My-Mz, 4=Fx-My-Mz
		"""
		pass


	def setMomentAngles(self, momentAngles) -> IFPlasticHingePMMJointMaterial:
		r"""
		Adds the moment angles to a Piecewise Linear joint material for PMM analysis 
		Params:
			momentAngles (array of float): array of moments angles in degrees
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getMomentAngles(self, momentAngles) -> IFPlasticHingePMMJointMaterial:
		r"""
		Gets the defined moment angles 
		Params:
			momentAngles (array of float): array of moments angles in degrees
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def setParameterisedMomentCurveData(self, angle, moment, rotation) -> IFPlasticHingePMMJointMaterial:
		r"""
		Defines the parameterised curve for each moment direction my and mz. The values of the actual tabulated curves will simply be these values multiplied by the computed member capacity and ultimate displacement in the appropriate direction. 
		Params:
			angle (int): moment angle index
			moment (array of realvariation): 
			rotation (array of realvariation): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getParameterisedMomentCurveData(self, angle, moment, rotation) -> IFPlasticHingePMMJointMaterial:
		r"""
		Retrieves the parameterised curve previously set by setParameterisedMomentCurveData 
		Params:
			angle (int): moment angle index
			moment (array of realvariation): 
			rotation (array of realvariation): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def setAcceptanceCriteria(self, angle, values) -> IFPlasticHingePMMJointMaterial:
		r"""
		Defines the parameterised values of the acceptance criteria for each moment angle. The acceptance criteria parameters are the same for both moments but the actual values are determined for each moment direction and axial force. 
		Params:
			angle (int): moment angle index
			values (array of realvariation): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getAcceptanceCriteria(self, angle, values) -> IFPlasticHingePMMJointMaterial:
		r"""
		Retrieves the parameterised values of the acceptance criteria. 
		Params:
			angle (int): moment angle index
			values (array of realvariation): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def setAxialInteraction(self, axial, moment) -> IFPlasticHingePMMJointMaterial:
		r"""
		Defines the proportions of axial force and their corresponding factor to be applied to the ending capacities 
		Params:
			axial (array of realvariation): 
			moment (array of realvariation): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getAxialInteraction(self, axial, moment) -> IFPlasticHingePMMJointMaterial:
		r"""
		Retrieves the axial interaction arrays previously set by setAxialInteraction 
		Params:
			axial (array of realvariation): 
			moment (array of realvariation): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def setUltimateStrength(self, continuesFromD) -> IFPlasticHingePMMJointMaterial:
		r"""
		Sets whether the ultimate strength continues from 'point D' or drops to zero 
		Params:
			continuesFromD (bool): TRUE for continues, FALSE for drops to zero
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getUltimateStrength(self) -> bool:
		r"""
		Gets whether the ultimate strength setting 
		Returns:
			bool: returned ultimate strength setting
		"""
		pass


	def setMaterialYield(self, _yield) -> IFPlasticHingePMMJointMaterial:
		r"""
		Sets the yield value. This value will be used in calculation of the hinge capacities 
		Params:
			_yield (float): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getMaterialYield(self) -> float:
		r"""
		Gets the yield value. This value will be used in calculation of the hinge capacities 
		Returns:
			float: the returned yield value
		"""
		pass


	def setHysteresis(self, hysteresis) -> IFPlasticHingePMMJointMaterial:
		r"""
		Sets whether the hysteresis model is used 
		Params:
			hysteresis (bool): TRUE for hysterisis
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getHysteresis(self) -> bool:
		r"""
		Gets whether the hysteresis model is used 
		Returns:
			bool: returned hysteresis setting
		"""
		pass


	def setJointStiffnessFactor(self, stiffnessFactor) -> IFPlasticHingePMMJointMaterial:
		r"""
		Sets the joint stiffness factor 
		Params:
			stiffnessFactor (float): 
		Returns:
			IFPlasticHingePMMJointMaterial: 
		"""
		pass


	def getJointStiffnessFactor(self) -> float:
		r"""
		Gets the joint stiffness factor 
		Returns:
			float: the returned stiffness factor
		"""
		pass


class IFMatrixJointMaterial(IFMaterial):
	"""
	 
	"""

	def setMatrix(self, type, bFull, values) -> IFMatrixJointMaterial:
		r"""
		Adds the matrix type and values to a Matrix joint material 
		Params:
			type (str): matrix type
			bFull (bool): full matrix input option (TRUE for full matrix, FALSE for upper right quadrant)
			values (IFVariationAttr or float): matrix values
		Returns:
			IFMatrixJointMaterial: 
		"""
		pass


class IFMaterialTropicSet(IFMaterial):
	"""
	 
	"""

	def addUserComponent(self, component, modelID, nState, Value, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			component (str): 
			modelID (int): 
			nState (int): 
			Value (array of float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addPlasticHardCurve(self, type, Graph, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			type (str): 
			Graph (array of float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addPlasticHardCurveCompression(self, type, Tension, Compression, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			type (str): 
			Tension (array of float): 
			Compression (array of float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addCreepPowerTime(self, Param1, Param2, Param3, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			Param1 (IFVariationAttr or float): 
			Param2 (IFVariationAttr or float): 
			Param3 (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addCreepPowerStrain(self, Param1, Param2, Param3, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			Param1 (IFVariationAttr or float): 
			Param2 (IFVariationAttr or float): 
			Param3 (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addCreepExponential(self, Param1, Param2, Param3, Param4, Param5, Param6, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			Param1 (IFVariationAttr or float): 
			Param2 (IFVariationAttr or float): 
			Param3 (IFVariationAttr or float): 
			Param4 (IFVariationAttr or float): 
			Param5 (IFVariationAttr or float): 
			Param6 (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addCreepEightParam(self, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			Param1 (IFVariationAttr or float): 
			Param2 (IFVariationAttr or float): 
			Param3 (IFVariationAttr or float): 
			Param4 (IFVariationAttr or float): 
			Param5 (IFVariationAttr or float): 
			Param6 (IFVariationAttr or float): 
			Param7 (IFVariationAttr or float): 
			Param8 (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addCreepStressPotentialHill(self, StressX, StressY, StressZ, StressXY, StressYZ, StressXZ, initialYield=None, heatFraction=None, temp=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			StressX (IFVariationAttr or float): 
			StressY (IFVariationAttr or float): 
			StressZ (IFVariationAttr or float): 
			StressXY (IFVariationAttr or float): 
			StressYZ (IFVariationAttr or float): 
			StressXZ (IFVariationAttr or float): 
			initialYield (IFVariationAttr or float, optional): 
			heatFraction (IFVariationAttr or float, optional): 
			temp (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def setCreepStressPotentialVonMises(self) -> IFMaterialTropicSet:
		r"""
		 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addDamageSimo(self, Threshold, ParamA, ParamB, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			Threshold (IFVariationAttr or float): 
			ParamA (IFVariationAttr or float): 
			ParamB (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addDamageOliver(self, Threshold, ParamA, DamageRatio, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			Threshold (IFVariationAttr or float): 
			ParamA (IFVariationAttr or float): 
			DamageRatio (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addDamageHashin(self, StrengthXT, StrengthXC, ShearStrength, StrengthYT, StrengthYC, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			StrengthXT (IFVariationAttr or float): 
			StrengthXC (IFVariationAttr or float): 
			ShearStrength (IFVariationAttr or float): 
			StrengthYT (IFVariationAttr or float): 
			StrengthYC (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addShrinkageConcrete(self, CementType, RH, H, Fcm, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RH (IFVariationAttr or float): relative humidity
			H (IFVariationAttr or float): member geometry parameter
			Fcm (IFVariationAttr or float): mean compressive strength
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addShrinkageGeneral(self, type, F, Vs, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			type (str): type of shrinkage curve either "Time" or "DOC"
			F (IFVariationAttr or float): array of time/degree of cure at each point on curve
			Vs (IFVariationAttr or float): array of linear shrinkage at time/degree of cure at each point on curve
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addViscousStandard(self, ShearModulus, DecayConstant, temperature=None) -> IFMaterialTropicSet:
		r"""
		 
		Params:
			ShearModulus (IFVariationAttr or float): 
			DecayConstant (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def setTwoPhaseSuctionPressure(self, suction) -> IFMaterialTropicSet:
		r"""
		set the maximum suction pressure for the Two Phase material component 
		Params:
			suction (IFVariationAttr or float): maximum suction pressure
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def setTwoPhaseCavitationPressure(self, cavitation) -> IFMaterialTropicSet:
		r"""
		set the maximum cavitation pressure for the Two Phase material component 
		Params:
			cavitation (IFVariationAttr or float): maximum cavitation pressure
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addTwoPhaseStandard(self, BulkModulusSolid, BulkModulusFluid, Porosity, UnitWeightFluid, PermeabilityX, PermeabilityY, PermeabilityZ, fluidDensity=None, temp=None, fluidBulkModulusType=None, twoPhaseDensityType=None) -> IFMaterialTropicSet:
		r"""
		add an undrained Two Phase material component 
		Params:
			BulkModulusSolid (IFVariationAttr or float): Solid bulk modulus
			BulkModulusFluid (IFVariationAttr or float): Fluid bulk modulus
			Porosity (IFVariationAttr or float): 
			UnitWeightFluid (IFVariationAttr or float): 
			PermeabilityX (IFVariationAttr or float): 
			PermeabilityY (IFVariationAttr or float): 
			PermeabilityZ (IFVariationAttr or float): 
			fluidDensity (IFVariationAttr or float, optional): 
			temp (float, optional): temperature
			fluidBulkModulusType (str, optional): "absolute","factor","Poisson"
			twoPhaseDensityType (str, optional): "Soil grain","Fully saturated"
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addPartiallyDrainedTwoPhase(self, pBulkModulusSolid, pBulkModulusFluid, pPorosity, pUnitWeightFluid, pPermeabilityX, pPermeabilityY, pPermeabilityZ, fluidDensity, irreducibleSat, satSaturation, scanningCurveFactor, temp=None, fluidBulkModulusType=None, type=None, defnType=None, twoPhaseDensityType=None) -> IFMaterialTropicSet:
		r"""
		add a partially drained Two Phase material component 
		Params:
			pBulkModulusSolid (IFVariationAttr or float): 
			pBulkModulusFluid (IFVariationAttr or float): 
			pPorosity (IFVariationAttr or float): 
			pUnitWeightFluid (IFVariationAttr or float): 
			pPermeabilityX (IFVariationAttr or float): 
			pPermeabilityY (IFVariationAttr or float): 
			pPermeabilityZ (IFVariationAttr or float): 
			fluidDensity (IFVariationAttr or float): 
			irreducibleSat (IFVariationAttr or float): 
			satSaturation (IFVariationAttr or float): 
			scanningCurveFactor (float): 
			temp (float, optional): temperature
			fluidBulkModulusType (str, optional): "absolute","factor","Poisson"
			type (str, optional): "Valiantzas", "VanGanuchtenMaulem","BrooksCorey"
			defnType (str, optional): "saturation", "water content"
			twoPhaseDensityType (str, optional): "Soil grain","Fully saturated"
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addConstantWaterContentTwoPhase(self, pBulkModulusSolid, pBulkModulusFluid, pPorosity, pUnitWeightFluid, pPermeabilityX, pPermeabilityY, pPermeabilityZ, fluidDensity, irreducibleSat, satSaturation, permeabilityFactor, temp=None, fluidBulkModulusType=None, defnType=None, twoPhaseDensityType=None) -> IFMaterialTropicSet:
		r"""
		add a constnat water content Two Phase material component 
		Params:
			pBulkModulusSolid (IFVariationAttr or float): 
			pBulkModulusFluid (IFVariationAttr or float): 
			pPorosity (IFVariationAttr or float): 
			pUnitWeightFluid (IFVariationAttr or float): 
			pPermeabilityX (IFVariationAttr or float): 
			pPermeabilityY (IFVariationAttr or float): 
			pPermeabilityZ (IFVariationAttr or float): 
			fluidDensity (IFVariationAttr or float): 
			irreducibleSat (IFVariationAttr or float): 
			satSaturation (IFVariationAttr or float): 
			permeabilityFactor (IFVariationAttr or float): 
			temp (float, optional): temperature
			fluidBulkModulusType (str, optional): "absolute","factor","Poisson"
			defnType (str, optional): "saturation", "water content"
			twoPhaseDensityType (str, optional): "Soil grain","Fully saturated"
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addValiantzasDrainingCurve(self, rowIndex, extraction, weightFactor, airEntry, permeability) -> IFMaterialTropicSet:
		r"""
		add the Valiantzas draining curve to the two phase material component 
		Params:
			rowIndex (int): row index
			extraction (IFVariationAttr or float): 
			weightFactor (IFVariationAttr or float): 
			airEntry (IFVariationAttr or float): 
			permeability (IFVariationAttr or float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addValiantzasFillingCurve(self, rowIndex, extraction, weightFactor, airEntry, permeability) -> IFMaterialTropicSet:
		r"""
		add the Valiantzas filling curve to the two phase material component 
		Params:
			rowIndex (int): row index
			extraction (IFVariationAttr or float): 
			weightFactor (IFVariationAttr or float): 
			airEntry (IFVariationAttr or float): 
			permeability (IFVariationAttr or float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addVanGanuchtenDrainingCurve(self, rowIndex, parameterN, parameterAlpha, permeability) -> IFMaterialTropicSet:
		r"""
		add the Van Ganuchten-Maulam draining curve to the two phase material component 
		Params:
			rowIndex (int): row index
			parameterN (IFVariationAttr or float): 
			parameterAlpha (IFVariationAttr or float): 
			permeability (IFVariationAttr or float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addVanGanuchtenFillingCurve(self, rowIndex, parameterN, parameterAlpha, permeability) -> IFMaterialTropicSet:
		r"""
		add the Van Ganuchten-Maulam filling curve to the two phase material component 
		Params:
			rowIndex (int): row index
			parameterN (IFVariationAttr or float): 
			parameterAlpha (IFVariationAttr or float): 
			permeability (IFVariationAttr or float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addBrooksCoreyDrainingCurve(self, rowIndex, poreSizeDistr, airEntry) -> IFMaterialTropicSet:
		r"""
		add the Brooks Coley draining curve to the two phase material component 
		Params:
			rowIndex (int): row index
			poreSizeDistr (IFVariationAttr or float): 
			airEntry (IFVariationAttr or float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addBrooksCoreyFillingCurve(self, rowIndex, poreSizeDistr, airEntry) -> IFMaterialTropicSet:
		r"""
		add the Brooks Coley filling curve to the two phase material component 
		Params:
			rowIndex (int): row index
			poreSizeDistr (IFVariationAttr or float): 
			airEntry (IFVariationAttr or float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addPiecewiseDrainedTwoPhase(self, pBulkModulusSolid, pBulkModulusFluid, pPorosity, pUnitWeightFluid, pPermeabilityX, pPermeabilityY, pPermeabilityZ, fluidDensity, irreducibleSat, satSaturation, scanningCurveFactor, curveTolerance, temp=None, fluidBulkModulusType=None, defnType=None, twoPhaseDensityType=None) -> IFMaterialTropicSet:
		r"""
		add a piecewise Two Phase material component 
		Params:
			pBulkModulusSolid (IFVariationAttr or float): 
			pBulkModulusFluid (IFVariationAttr or float): 
			pPorosity (IFVariationAttr or float): 
			pUnitWeightFluid (IFVariationAttr or float): 
			pPermeabilityX (IFVariationAttr or float): 
			pPermeabilityY (IFVariationAttr or float): 
			pPermeabilityZ (IFVariationAttr or float): 
			fluidDensity (IFVariationAttr or float): 
			irreducibleSat (IFVariationAttr or float): 
			satSaturation (IFVariationAttr or float): 
			scanningCurveFactor (float): 
			curveTolerance (float): 
			temp (float, optional): temperature
			fluidBulkModulusType (str, optional): "absolute","factor","Poisson"
			defnType (str, optional): "saturation", "water content"
			twoPhaseDensityType (str, optional): "Soil grain","Fully saturated"
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addPiecewiseDrainedCurve(self, rowIndex, curveData) -> IFMaterialTropicSet:
		r"""
		add the drained curve to the piecewise Two Phase material component 
		Params:
			rowIndex (int): row index
			curveData (array of float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addPiecewiseFillingCurve(self, rowIndex, curveData) -> IFMaterialTropicSet:
		r"""
		add the filling curve to the piecewise Two Phase material component 
		Params:
			rowIndex (int): row index
			curveData (array of float): 
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addKoElasticRow(self, YoungsModulus, lateralEarthPressure) -> IFMaterialTropicSet:
		r"""
		Ko Initialisation material row for isotropic elastic materials 
		Params:
			YoungsModulus (IFVariationAttr or float): Youngs modulus
			lateralEarthPressure (IFVariationAttr or float): lateral earth pressure
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addKoCamClayRow(self, calcInitialVoidRatio, YoungsModulus, lateralEarthPressure, specificVolume) -> IFMaterialTropicSet:
		r"""
		Ko Initialisation material row for Cam_Clay material 
		Params:
			calcInitialVoidRatio (bool): true to calculate initial void raio in Ko material
			YoungsModulus (IFVariationAttr or float): Youngs modulus
			lateralEarthPressure (IFVariationAttr or float): Lateral earth pressure
			specificVolume (IFVariationAttr or float): Specific volume on NCL
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addKoCamClayOcrRow(self, calcInitialVoidRatio, overConsolidationRatio, YoungsModulus, PoissonsRatio, lateralEarthPressure, specificVolume) -> IFMaterialTropicSet:
		r"""
		Ko Initialiatsion material row for Cam_Clay OCR standard material 
		Params:
			calcInitialVoidRatio (bool): true to calculate initial void ratio in Ko material
			overConsolidationRatio (IFVariationAttr or float): Solid bulk modulus
			YoungsModulus (IFVariationAttr or float): Youngs modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio for unloading
			lateralEarthPressure (IFVariationAttr or float): Lateral earth pressure
			specificVolume (IFVariationAttr or float): Specific volume on NCL
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addKoCamClayOcrSinRow(self, calcInitialVoidRatio, overConsolidationRatio, YoungsModulus, PoissonsRatio, lateralEarthPressure, specificVolume, sineAngleFriction=None) -> IFMaterialTropicSet:
		r"""
		Ko Initialiatsion material row for Cam_Clay OCR SIN material 
		Params:
			calcInitialVoidRatio (bool): true to calculate initial void ratio in Ko material
			overConsolidationRatio (IFVariationAttr or float): Solid bulk modulus
			YoungsModulus (IFVariationAttr or float): Youngs modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio for unloading
			lateralEarthPressure (IFVariationAttr or float): Lateral earth pressure
			specificVolume (IFVariationAttr or float): Specific volume on NCL
			sineAngleFriction (IFVariationAttr or float, optional): Sine of angle of friction
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addKoCamClayOcrGeneralRow(self, calcInitialVoidRatio, overConsolidationRatio, YoungsModulus, PoissonsRatio, lateralEarthPressure, specificVolume, coeffEarthPressure=None) -> IFMaterialTropicSet:
		r"""
		Ko Initialiatsion material row for Cam_Clay OCR general material 
		Params:
			calcInitialVoidRatio (bool): true to calculate initial void ratio in Ko material
			overConsolidationRatio (IFVariationAttr or float): Solid bulk modulus
			YoungsModulus (IFVariationAttr or float): Youngs modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio for unloading
			lateralEarthPressure (IFVariationAttr or float): Lateral earth pressure
			specificVolume (IFVariationAttr or float): Specific volume on NCL
			coeffEarthPressure (IFVariationAttr or float, optional): Coefficient of earth pressure
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addKoPreOverburdenPressureRow(self, calcInitialVoidRatio, PreOverburdenPressure, YoungsModulus, PoissonsRatio, lateralEarthPressure, specificVolume) -> IFMaterialTropicSet:
		r"""
		pre-overburden pressure Ko Initialiatsion material row 
		Params:
			calcInitialVoidRatio (bool): true to calculate initial void ratio in Ko material
			PreOverburdenPressure (IFVariationAttr or float): pre-overburden pressure
			YoungsModulus (IFVariationAttr or float): Youngs modulus
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio for unloading
			lateralEarthPressure (IFVariationAttr or float): Lateral earth pressure
			specificVolume (IFVariationAttr or float): Specific volume on NCL
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def addTwoPhaseInterface(self, hydraulicConductivity) -> IFMaterialTropicSet:
		r"""
		add soil structure interface two hhase material component 
		Params:
			hydraulicConductivity (IFVariationAttr or float): hydraulic conductivity across interface
		Returns:
			IFMaterialTropicSet: 
		"""
		pass


	def hasElasticComponent(self) -> bool:
		r"""
		return true if this material has a elastic component 
		Returns:
			bool: 
		"""
		pass


	def hasThermalComponent(self) -> bool:
		r"""
		return true if this material has a thermal component 
		Returns:
			bool: 
		"""
		pass


	def hasPlasticComponent(self) -> bool:
		r"""
		return true if this material has a plastic component 
		Returns:
			bool: 
		"""
		pass


	def hasCreepComponent(self) -> bool:
		r"""
		return true if this material has a creep component 
		Returns:
			bool: 
		"""
		pass


	def hasShrinkageComponent(self) -> bool:
		r"""
		return true if this material has a shrinkage component 
		Returns:
			bool: 
		"""
		pass


	def hasDamageComponent(self) -> bool:
		r"""
		return true if this material has a damage component 
		Returns:
			bool: 
		"""
		pass


	def hasViscousComponent(self) -> bool:
		r"""
		return true if this material has a viscous component 
		Returns:
			bool: 
		"""
		pass


	def hasTwoPhaseComponent(self) -> bool:
		r"""
		return true if this material has a two phase component 
		Returns:
			bool: 
		"""
		pass


	def hasKoComponent(self) -> bool:
		r"""
		return true if this material has a Ko initialisation component 
		Returns:
			bool: 
		"""
		pass


	def getSolverMaterialModelNumber(self) -> int:
		r"""
		return the material model number (ties up with the Solver Reference Manual) 
		Returns:
			int: 
		"""
		pass


	def getDesignCodeName(self) -> str:
		r"""
		return the name of the code of practice (only appropriate for models 86, 105 and 109) 
		Returns:
			str: 
		"""
		pass


class IFMaterialIsotropic(IFMaterialTropicSet):
	"""
	Additional isotropic material attribute data 
	"""

	def addElastic(self, Young, Poisson, Density, temperature, thermalExp=None, massDamping=None, stiffDamping=None) -> IFMaterialIsotropic:
		r"""
		Add elastic properties to isotropic material 
		Params:
			Young (IFVariationAttr or float): Young's modulus
			Poisson (IFVariationAttr or float): Poisson's ratio
			Density (IFVariationAttr or float): density
			temperature (float): temperature
			thermalExp (object, optional): coefficient of thermal expansion
			massDamping (IFVariationAttr or float, optional): Mass Rayleigh damping constant
			stiffDamping (IFVariationAttr or float, optional): Stiffness Rayleigh damping constant
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticStressPotentialVonMises(self, InitialTension, HeatFraction, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear stress potential von Mises properties to isotropic material attribute 
		Params:
			InitialTension (IFVariationAttr or float): Initial tensile yield stress
			HeatFraction (IFVariationAttr or float): Heat fraction coefficient
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticStressPotentialVonMisesModified(self, InitialTension, InitialCompression, HeatFraction, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear stress potential modified von Mises properties to isotropic material attribute 
		Params:
			InitialTension (IFVariationAttr or float): Initial tensile yield stress
			InitialCompression (IFVariationAttr or float): Initial compressive yield stress
			HeatFraction (IFVariationAttr or float): Heat fraction coefficient
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticTresca(self, StressSlope, PlasticStrain, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add Tresca properties to isotropic material attribute 
		Params:
			StressSlope (IFVariationAttr or float): 
			PlasticStrain (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticMohrCoulomb(self, InitialCohesion, InitialFriction, FinalFraction, DilationAngle, CohesionSlope, PlasticStrain, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add Mohr Colulomb properties to isotropic material attribute 
		Params:
			InitialCohesion (IFVariationAttr or float): 
			InitialFriction (IFVariationAttr or float): 
			FinalFraction (IFVariationAttr or float): 
			DilationAngle (IFVariationAttr or float): 
			CohesionSlope (IFVariationAttr or float): 
			PlasticStrain (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticDruckerPrager(self, InitialCohesion, InitialFriction, HeatFraction, CohesionSlope, FrictionSlope, PlasticStrain, temperature=None, modelNumber=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear Drucker Prager properties to isotropic material attribute (Mdl=64) 
		Params:
			InitialCohesion (IFVariationAttr or float): Initial cohesion
			InitialFriction (IFVariationAttr or float): Initial friction angle
			HeatFraction (IFVariationAttr or float): Heat fraction coefficient
			CohesionSlope (IFVariationAttr or float): Slope of cohesion against plastic strain
			FrictionSlope (IFVariationAttr or float): Slope of friction angle against plastic strain
			PlasticStrain (IFVariationAttr or float): Limit of hardening curve
			temperature (float, optional): temperature
			modelNumber (int, optional): model 64 or 74, 74 bt default
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticConcrete94(self, CompressiveStrength, TensileStrength, PeakStrain, EffectiveStrain, FractureEnergy, PrincipalRatio, YieldSurface, Dilatancy, InterlockState, ContactMultiplier, FinalMultiplier, ShearIntercept, FrictionSlope, AngularLimit, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear concrete properties to isotropic material attribute (Mdl=94) 
		Params:
			CompressiveStrength (IFVariationAttr or float): 
			TensileStrength (IFVariationAttr or float): 
			PeakStrain (IFVariationAttr or float): 
			EffectiveStrain (IFVariationAttr or float): 
			FractureEnergy (IFVariationAttr or float): 
			PrincipalRatio (IFVariationAttr or float): 
			YieldSurface (IFVariationAttr or float): 
			Dilatancy (IFVariationAttr or float): 
			InterlockState (IFVariationAttr or float): 
			ContactMultiplier (IFVariationAttr or float): 
			FinalMultiplier (IFVariationAttr or float): 
			ShearIntercept (IFVariationAttr or float): 
			FrictionSlope (IFVariationAttr or float): 
			AngularLimit (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticConcrete109(self, CompressiveStrength, TensileStrength, PeakStrain, EffectiveStrain, FractureEnergy, PrincipalRatio, YieldSurface, Dilatancy, InterlockState, ContactMultiplier, FinalMultiplier, ShearIntercept, limitingFriction, crackFixityStrain, zoneWidth, softeningFactor, materialConstAp, materialConstV, shapenessCoeffZ1, shapenessCoeffZ2, shapenessCoeffLM, numberIterations, maximumIterations, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear concrete properties 109 to isotropic material attribute 
		Params:
			CompressiveStrength (IFVariationAttr or float): 
			TensileStrength (IFVariationAttr or float): 
			PeakStrain (IFVariationAttr or float): 
			EffectiveStrain (IFVariationAttr or float): 
			FractureEnergy (IFVariationAttr or float): 
			PrincipalRatio (IFVariationAttr or float): 
			YieldSurface (IFVariationAttr or float): 
			Dilatancy (IFVariationAttr or float): 
			InterlockState (IFVariationAttr or float): 
			ContactMultiplier (IFVariationAttr or float): 
			FinalMultiplier (IFVariationAttr or float): 
			ShearIntercept (IFVariationAttr or float): 
			limitingFriction (IFVariationAttr or float): 
			crackFixityStrain (IFVariationAttr or float): 
			zoneWidth (IFVariationAttr or float): 
			softeningFactor (IFVariationAttr or float): 
			materialConstAp (IFVariationAttr or float): 
			materialConstV (IFVariationAttr or float): 
			shapenessCoeffZ1 (IFVariationAttr or float): 
			shapenessCoeffZ2 (IFVariationAttr or float): 
			shapenessCoeffLM (IFVariationAttr or float): 
			numberIterations (int): 
			maximumIterations (int): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addChinesePlasticConcrete109(self, CompressiveStrength, TensileStrength, PeakStrain, EffectiveStrain, FractureEnergy, PrincipalRatio, YieldSurface, Dilatancy, InterlockState, ContactMultiplier, FinalMultiplier, ShearIntercept, limitingFriction, crackFixityStrain, zoneWidth, softeningFactor, materialConstAp, materialConstV, shapenessCoeffZ1, shapenessCoeffZ2, shapenessCoeffLM, vParamA, vParamB, numberIterations, maximumIterations, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear concrete properties 109 with Chinese creep to isotropic material attribute 
		Params:
			CompressiveStrength (IFVariationAttr or float): 
			TensileStrength (IFVariationAttr or float): 
			PeakStrain (IFVariationAttr or float): 
			EffectiveStrain (IFVariationAttr or float): 
			FractureEnergy (IFVariationAttr or float): 
			PrincipalRatio (IFVariationAttr or float): 
			YieldSurface (IFVariationAttr or float): 
			Dilatancy (IFVariationAttr or float): 
			InterlockState (IFVariationAttr or float): 
			ContactMultiplier (IFVariationAttr or float): 
			FinalMultiplier (IFVariationAttr or float): 
			ShearIntercept (IFVariationAttr or float): 
			limitingFriction (IFVariationAttr or float): 
			crackFixityStrain (IFVariationAttr or float): 
			zoneWidth (IFVariationAttr or float): 
			softeningFactor (IFVariationAttr or float): 
			materialConstAp (IFVariationAttr or float): 
			materialConstV (IFVariationAttr or float): 
			shapenessCoeffZ1 (IFVariationAttr or float): 
			shapenessCoeffZ2 (IFVariationAttr or float): 
			shapenessCoeffLM (IFVariationAttr or float): 
			vParamA (IFVariationAttr or float): 
			vParamB (IFVariationAttr or float): 
			numberIterations (int): 
			maximumIterations (int): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticConcrete119(self, pCompressiveStrength, pTensileStrength, pPeakStrain, pEffectiveStrain, pFractureEnergy, pPrincipalRatio, pYieldSurface, pDilatancy, pInterlockState, pContactMultiplier, pFinalMultiplier, pShearIntercept, pLimitingFriction, pCrackFixityStrain, pZoneWidth, pSofteningFactor, pMaterialConstAp, pMaterialConstV, pShapenessCoeffZ1, pShapenessCoeffZ2, pShapenessCoeffLM, pFibreYoungsModulus, pFibreVolumeFraction, pFibreLength, pFibreDiameter, pFibreMatrixParameter, pFibreMatrixRatio, pFibreSlidingStress, pFibreSnubbingParameter, pFibreSurParametere1, pFibreSurParametere2, pEffectivePullOut, pLimitCrackOpening, numberIterations, maximumIterations, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear concrete properties 119 to this isotropic material attribute 
		Params:
			pCompressiveStrength (IFVariationAttr or float): fc
			pTensileStrength (IFVariationAttr or float): ft
			pPeakStrain (IFVariationAttr or float): Ec
			pEffectiveStrain (IFVariationAttr or float): E0
			pFractureEnergy (IFVariationAttr or float): Gf
			pPrincipalRatio (IFVariationAttr or float): Br
			pYieldSurface (IFVariationAttr or float): Zo
			pDilatancy (IFVariationAttr or float): E
			pInterlockState (IFVariationAttr or float): mg
			pContactMultiplier (IFVariationAttr or float): mhi
			pFinalMultiplier (IFVariationAttr or float): mful
			pShearIntercept (IFVariationAttr or float): ro
			pLimitingFriction (IFVariationAttr or float): p
			pCrackFixityStrain (IFVariationAttr or float): mcf
			pZoneWidth (IFVariationAttr or float): fpz
			pSofteningFactor (IFVariationAttr or float): Rs
			pMaterialConstAp (IFVariationAttr or float): Ap
			pMaterialConstV (IFVariationAttr or float): An
			pShapenessCoeffZ1 (IFVariationAttr or float): Cz1
			pShapenessCoeffZ2 (IFVariationAttr or float): Cz2
			pShapenessCoeffLM (IFVariationAttr or float): Clm
			pFibreYoungsModulus (IFVariationAttr or float): Ef
			pFibreVolumeFraction (IFVariationAttr or float): Vf
			pFibreLength (IFVariationAttr or float): Lf
			pFibreDiameter (IFVariationAttr or float): df
			pFibreMatrixParameter (IFVariationAttr or float): Beta
			pFibreMatrixRatio (IFVariationAttr or float): Betarf
			pFibreSlidingStress (IFVariationAttr or float): Tau0
			pFibreSnubbingParameter (IFVariationAttr or float): fsn
			pFibreSurParametere1 (IFVariationAttr or float): alphapf
			pFibreSurParametere2 (IFVariationAttr or float): alphanf
			pEffectivePullOut (IFVariationAttr or float): rpl
			pLimitCrackOpening (IFVariationAttr or float): rdb
			numberIterations (int): ifcf
			maximumIterations (int): itmx
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addChinesePlasticConcrete119(self, pCompressiveStrength, pTensileStrength, pPeakStrain, pEffectiveStrain, pFractureEnergy, pPrincipalRatio, pYieldSurface, pDilatancy, pInterlockState, pContactMultiplier, pFinalMultiplier, pShearIntercept, pLimitingFriction, pCrackFixityStrain, pZoneWidth, pSofteningFactor, pMaterialConstAp, pMaterialConstV, pShapenessCoeffZ1, pShapenessCoeffZ2, pShapenessCoeffLM, pFibreYoungsModulus, pFibreVolumeFraction, pFibreLength, pFibreDiameter, pFibreMatrixParameter, pFibreMatrixRatio, pFibreSlidingStress, pFibreSnubbingParameter, pFibreSurParametere1, pFibreSurParametere2, pEffectivePullOut, pLimitCrackOpening, vParamA, vParamB, numberIterations, maximumIterations, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear concrete properties 119 with Chinese creep to thieisotropic material attribute 
		Params:
			pCompressiveStrength (IFVariationAttr or float): fc
			pTensileStrength (IFVariationAttr or float): ft
			pPeakStrain (IFVariationAttr or float): Ec
			pEffectiveStrain (IFVariationAttr or float): E0
			pFractureEnergy (IFVariationAttr or float): Gf
			pPrincipalRatio (IFVariationAttr or float): Br
			pYieldSurface (IFVariationAttr or float): Zo
			pDilatancy (IFVariationAttr or float): E
			pInterlockState (IFVariationAttr or float): mg
			pContactMultiplier (IFVariationAttr or float): mhi
			pFinalMultiplier (IFVariationAttr or float): mful
			pShearIntercept (IFVariationAttr or float): ro
			pLimitingFriction (IFVariationAttr or float): p
			pCrackFixityStrain (IFVariationAttr or float): mcf
			pZoneWidth (IFVariationAttr or float): fpz
			pSofteningFactor (IFVariationAttr or float): Rs
			pMaterialConstAp (IFVariationAttr or float): Ap
			pMaterialConstV (IFVariationAttr or float): An
			pShapenessCoeffZ1 (IFVariationAttr or float): Cz1
			pShapenessCoeffZ2 (IFVariationAttr or float): Cz2
			pShapenessCoeffLM (IFVariationAttr or float): Clm
			pFibreYoungsModulus (IFVariationAttr or float): Ef
			pFibreVolumeFraction (IFVariationAttr or float): Vf
			pFibreLength (IFVariationAttr or float): Lf
			pFibreDiameter (IFVariationAttr or float): df
			pFibreMatrixParameter (IFVariationAttr or float): Beta
			pFibreMatrixRatio (IFVariationAttr or float): Betarf
			pFibreSlidingStress (IFVariationAttr or float): Tau0
			pFibreSnubbingParameter (IFVariationAttr or float): fsn
			pFibreSurParametere1 (IFVariationAttr or float): alphapf
			pFibreSurParametere2 (IFVariationAttr or float): alphanf
			pEffectivePullOut (IFVariationAttr or float): rpl
			pLimitCrackOpening (IFVariationAttr or float): rdb
			vParamA (IFVariationAttr or float): A
			vParamB (IFVariationAttr or float): B
			numberIterations (int): ifcf
			maximumIterations (int): itmx
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticConcrete105(self, CompressiveStrength, TensileStrength, PeakStrain, EffectiveStrain, FractureEnergy, PrincipalRatio, YieldSurface, Dilatancy, InterlockState, ContactMultiplier, FinalMultiplier, ShearIntercept, limitingFriction, crackFixityStrain, zoneWidth, softeningFactor, materialConstAp, materialConstV, shapenessCoeffZ1, shapenessCoeffZ2, shapenessCoeffLM, ultimateHydration, dryingShrinkage, chemicalShrinkage, scalingConstant, creep28factor, relaxationMultiplier, creepMultiplier, picketpMultiplier, degreePercolation, degreeFirstCure, moisturePickett, saturationPickett, ageCreepStarts, shortRelaxtion, firstLongRelax, secondLongRelax, shortTermViscous, longTermElastic, numberIterations, maximumIterations, creepFactorType, temperature=None, ageStartType=None, vEvolvutionType=None, vLogisticCoeff_E=None, vPowerCoeff_FC=None, vPowerCoeff_FT=None, vTempDegStarts=None, vTempDegFinish=None, vDegraCoeff_E=None, vDegraCoeff_FC=None, vDegraCoeff_FT=None, vUseDefaultCreepData=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear concrete properties 105 to isotropic material attribute 
		Params:
			CompressiveStrength (IFVariationAttr or float): 
			TensileStrength (IFVariationAttr or float): 
			PeakStrain (IFVariationAttr or float): 
			EffectiveStrain (IFVariationAttr or float): 
			FractureEnergy (IFVariationAttr or float): 
			PrincipalRatio (IFVariationAttr or float): 
			YieldSurface (IFVariationAttr or float): 
			Dilatancy (IFVariationAttr or float): 
			InterlockState (IFVariationAttr or float): 
			ContactMultiplier (IFVariationAttr or float): 
			FinalMultiplier (IFVariationAttr or float): 
			ShearIntercept (IFVariationAttr or float): 
			limitingFriction (IFVariationAttr or float): 
			crackFixityStrain (IFVariationAttr or float): 
			zoneWidth (IFVariationAttr or float): 
			softeningFactor (IFVariationAttr or float): 
			materialConstAp (IFVariationAttr or float): 
			materialConstV (IFVariationAttr or float): 
			shapenessCoeffZ1 (IFVariationAttr or float): 
			shapenessCoeffZ2 (IFVariationAttr or float): 
			shapenessCoeffLM (IFVariationAttr or float): 
			ultimateHydration (IFVariationAttr or float): 
			dryingShrinkage (IFVariationAttr or float): 
			chemicalShrinkage (IFVariationAttr or float): 
			scalingConstant (IFVariationAttr or float): 
			creep28factor (IFVariationAttr or float): 
			relaxationMultiplier (IFVariationAttr or float): 
			creepMultiplier (IFVariationAttr or float): 
			picketpMultiplier (IFVariationAttr or float): 
			degreePercolation (IFVariationAttr or float): 
			degreeFirstCure (IFVariationAttr or float): 
			moisturePickett (IFVariationAttr or float): 
			saturationPickett (IFVariationAttr or float): 
			ageCreepStarts (IFVariationAttr or float): 
			shortRelaxtion (IFVariationAttr or float): 
			firstLongRelax (IFVariationAttr or float): 
			secondLongRelax (IFVariationAttr or float): 
			shortTermViscous (IFVariationAttr or float): 
			longTermElastic (IFVariationAttr or float): 
			numberIterations (int): 
			maximumIterations (int): 
			creepFactorType (int): 
			temperature (float, optional): temperature
			ageStartType (int, optional): age when nonlinear creep starts type
			vEvolvutionType (int, optional): evolution of properties
			vLogisticCoeff_E (IFVariationAttr or float, optional): 
			vPowerCoeff_FC (IFVariationAttr or float, optional): 
			vPowerCoeff_FT (IFVariationAttr or float, optional): 
			vTempDegStarts (IFVariationAttr or float, optional): 
			vTempDegFinish (IFVariationAttr or float, optional): 
			vDegraCoeff_E (IFVariationAttr or float, optional): 
			vDegraCoeff_FC (IFVariationAttr or float, optional): 
			vDegraCoeff_FT (IFVariationAttr or float, optional): 
			vUseDefaultCreepData (bool, optional): 
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticStressResultant(self, sectionShape, YieldStress, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear stress resultant properties to isotropic material attribute (Mdl=29) 
		Params:
			sectionShape (str): 
			YieldStress (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticOptimisedVonMises(self, YieldStress, HeatFraction, TensionIsotropic, TensionKinematic, TensionPlastic, temperature=None) -> IFMaterialIsotropic:
		r"""
		Add nonlinear optimised von Mises properties to isotropic material attribute (Mdl=75) 
		Params:
			YieldStress (IFVariationAttr or float): 
			HeatFraction (IFVariationAttr or float): Heat fraction coefficient
			TensionIsotropic (IFVariationAttr or float): 
			TensionKinematic (IFVariationAttr or float): 
			TensionPlastic (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def setPhaseChange(self, phase) -> IFMaterialIsotropic:
		r"""
		set the thermal properties phase change type 
		Params:
			phase (str): Phase change type "None", "Del Giudice" or "Lemmon"
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addFieldIsoMaterial(self, K, C, H, temp, rho=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Thermal conductivity
			C (IFVariationAttr or float): Volumetric heat coefficient if density not specified or specific heat capacity if density specified
			H (IFVariationAttr or float): Enthalpy
			temp (float): Reference temperature
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addHygroIsoMaterial(self, K, temp, C, rho, H, P1, P2, T, gravityX=None, gravityY=None, gravityZ=None, gravityType=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Thermal conductivity
			temp (float): Reference temperature
			C (IFVariationAttr or float): Specific heat capacity
			rho (IFVariationAttr or float): Density
			H (IFVariationAttr or float): Enthalpy
			P1 (IFVariationAttr or float): Porosity
			P2 (IFVariationAttr or float): Permeability
			T (IFVariationAttr or float): Tortuosity
			gravityX (IFVariationAttr or float, optional): x direction component of gravity
			gravityY (IFVariationAttr or float, optional): y direction component of gravity
			gravityZ (IFVariationAttr or float, optional): z direction component of gravity
			gravityType (str, optional): gravity type
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addFieldResinGenericMaterial(self, K, temp, C, H, V, A1, A2, A3, E1, E2, E3, R, B1, B2, m1, n1, rho=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Thermal conductivity
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): 
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			A3 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			E3 (IFVariationAttr or float): 
			R (float): 
			B1 (IFVariationAttr or float): 
			B2 (IFVariationAttr or float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addFieldResinNthMaterial(self, K, temp, C, H, V, A1, A2, E1, E2, R, m1, n1, n2, rho=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Thermal conductivity
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			n2 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addFieldResinEcmMaterial(self, K, temp, C, H, V, A1, A2, E1, E2, R, G, p1, q1, r1, p2, r2, Cr, S, Z, Tmx, Tc, FE, D, Q, G0, rho=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Thermal conductivity
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			G (IFVariationAttr or float): 
			p1 (IFVariationAttr or float): 
			q1 (IFVariationAttr or float): 
			r1 (IFVariationAttr or float): 
			p2 (IFVariationAttr or float): 
			r2 (IFVariationAttr or float): 
			Cr (IFVariationAttr or float): 
			S (IFVariationAttr or float): 
			Z (IFVariationAttr or float): 
			Tmx (IFVariationAttr or float): 
			Tc (IFVariationAttr or float): 
			FE (IFVariationAttr or float): 
			D (IFVariationAttr or float): 
			Q (IFVariationAttr or float): 
			G0 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addFieldResinMfkMaterial(self, K, temp, C, H, V, rho=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Thermal conductivity
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addFieldResinMfkCurveData(self, rowIndex, time, cure, temp) -> IFMaterialIsotropic:
		r"""
		Add curve data to the MFK resin material 
		Params:
			rowIndex (int): 
			time (float): 
			cure (float): 
			temp (float): 
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addConcreteMaterial(self, K, temp, C, H, CementType, wcem, wcra, wslg, wpfa, pfacao, Tr, rho=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			Tr (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addConcreteUserMaterial(self, K, temp, C, H, CementType, wcem, wcra, wslg, wpfa, pfacao, Tr, C3S, C2S, C3A, C4AF, FreeCao, SO3, MgO, Blaine, rho=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			Tr (IFVariationAttr or float): 
			C3S (IFVariationAttr or float): 
			C2S (IFVariationAttr or float): 
			C3A (IFVariationAttr or float): 
			C4AF (IFVariationAttr or float): 
			FreeCao (IFVariationAttr or float): 
			SO3 (IFVariationAttr or float): 
			MgO (IFVariationAttr or float): 
			Blaine (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addPlasticModifiedMohrCoulomb(self, type, frictionAngleDegs, dilationAngleDegs, temp, dampingFactor=None) -> IFMaterialIsotropic:
		r"""
		add Modified Mohr Coulomb model 
		Params:
			type (str): material type
			frictionAngleDegs (IFVariationAttr or float): friction angle degrees
			dilationAngleDegs (IFVariationAttr or float): dilation angle degrees
			temp (float): temperature
			dampingFactor (IFVariationAttr or float, optional): damping factor (default 0.0)
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addModifiedMohrCoulombCohesion(self, rowIndex, cohesion) -> IFMaterialIsotropic:
		r"""
		set the cohesion value for Modified Mohr Coulomb model for the give row index 
		Params:
			rowIndex (int): 
			cohesion (IFVariationAttr or float): cohesion
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addModifiedMohrCoulombTensile(self, rowIndex, tensile) -> IFMaterialIsotropic:
		r"""
		set the tensiloe stress value for Modified Mohr Coulomb model for the give row index 
		Params:
			rowIndex (int): 
			tensile (IFVariationAttr or float): tensiloe stress
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addModifiedMohrCoulombCompressive(self, rowIndex, compressive) -> IFMaterialIsotropic:
		r"""
		set the compressive stress value for Modified Mohr Coulomb model for the give row index 
		Params:
			rowIndex (int): 
			compressive (IFVariationAttr or float): compressive stress
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addModifiedMohrCoulombCohesionCurve(self, rowIndex, curve) -> IFMaterialIsotropic:
		r"""
		add Cohesion graph to Modified Mohr Coulomb model 
		Params:
			rowIndex (int): 
			curve (array of float): (strain, stress) array
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addModifiedMohrCoulombTensileCurve(self, rowIndex, curve) -> IFMaterialIsotropic:
		r"""
		add Cohesion graph to Modified Mohr Coulomb model 
		Params:
			rowIndex (int): 
			curve (array of float): (strain, stress) array
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addModifiedMohrCoulombCompressiveCurve(self, rowIndex, curve) -> IFMaterialIsotropic:
		r"""
		add Compressive graph to Modified Mohr Coulomb model 
		Params:
			rowIndex (int): 
			curve (array of float): (strain, stress) array
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addHygroConcreteMaterial(self, K, temp, C, rho, H, P1, P2, T, K1, C1, rho1, entrappedAir, W, UH, CementType, wcem, wcra, wslg, wpfa, pfacao, admix, gravityX=None, gravityY=None, gravityZ=None, gravityType=None, densityType=None, conductivityType=None, porosityType=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Initial conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Initial specific heat capacity
			rho (IFVariationAttr or float): Initial density
			H (IFVariationAttr or float): Enthalpy
			P1 (IFVariationAttr or float): Initial porosity
			P2 (IFVariationAttr or float): Permeability
			T (IFVariationAttr or float): Tortuosity
			K1 (IFVariationAttr or float): factored K
			C1 (IFVariationAttr or float): factored specific heat capacity
			rho1 (IFVariationAttr or float): factored density
			entrappedAir (IFVariationAttr or float): entrapped are volume ratio
			W (IFVariationAttr or float): water saturation
			UH (IFVariationAttr or float): ultimate hydration
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			admix (IFVariationAttr or float): 
			gravityX (IFVariationAttr or float, optional): x direction component of gravity
			gravityY (IFVariationAttr or float, optional): y direction component of gravity
			gravityZ (IFVariationAttr or float, optional): z direction component of gravity
			gravityType (str, optional): gravity type
			densityType (str, optional): density type, "kiln" or "ambient"
			conductivityType (str, optional): conductivity type, "dependent" or "constant"
			porosityType (str, optional): porosity type, "automatic" or "specify"
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addHygroConcreteUserMaterial(self, K, temp, C, rho, H, P1, P2, T, K1, C1, rho1, entrappedAir, W, UH, CementType, wcem, wcra, wslg, wpfa, pfacao, admix, C3S, C2S, C3A, C4AF, FreeCao, SO3, MgO, Blaine, gravityX=None, gravityY=None, gravityZ=None, gravityType=None, densityType=None, conductivityType=None, porosityType=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialIsotropic:
		r"""
		Add thermal properties to isotropic material attribute 
		Params:
			K (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Initial specific heat capacity
			rho (IFVariationAttr or float): Initial density
			H (IFVariationAttr or float): Enthalpy
			P1 (IFVariationAttr or float): initial porosity
			P2 (IFVariationAttr or float): initial permeability
			T (IFVariationAttr or float): tortuosity
			K1 (IFVariationAttr or float): factored K
			C1 (IFVariationAttr or float): factored specific heat capacity
			rho1 (IFVariationAttr or float): factored density
			entrappedAir (IFVariationAttr or float): entrapped are volume ratio
			W (IFVariationAttr or float): water sat
			UH (IFVariationAttr or float): ultimate hydr
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			admix (IFVariationAttr or float): 
			C3S (IFVariationAttr or float): 
			C2S (IFVariationAttr or float): 
			C3A (IFVariationAttr or float): 
			C4AF (IFVariationAttr or float): 
			FreeCao (IFVariationAttr or float): 
			SO3 (IFVariationAttr or float): 
			MgO (IFVariationAttr or float): 
			Blaine (IFVariationAttr or float): 
			gravityX (IFVariationAttr or float, optional): x direction component of gravity
			gravityY (IFVariationAttr or float, optional): y direction component of gravity
			gravityZ (IFVariationAttr or float, optional): z direction component of gravity
			gravityType (str, optional): gravity type
			densityType (str, optional): density type, "kiln" or "ambient"
			conductivityType (str, optional): conductivity type, "dependent" or "constant"
			porosityType (str, optional): porosity type, "automatic" or "specify"
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addCebfipConcreteCreep(self, MeanConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, UseNominalThickness, InteriorPerimFactor, UseFullPerimeter, Temperature, adjustForTemperature=None) -> IFMaterialIsotropic:
		r"""
		add codified creep for CEB-FIP 
		Params:
			MeanConcreteCompStrength (IFVariationAttr or float): 
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RelativeHumidity (IFVariationAttr or float): 
			NominalThickness (IFVariationAttr or float): 
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			UseFullPerimeter (bool): if using section perimeter this sets the interior factor to 1
			Temperature (float): temperature
			adjustForTemperature (bool, optional): if T tabulate temperature else ignore temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addEurocode2ConcreteCreep(self, MeanConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, UseNominalThickness, InteriorPerimFactor, UseFullPerimeter, SilicaFumeType, Temperature) -> IFMaterialIsotropic:
		r"""
		add codified creep for Eurocode2 
		Params:
			MeanConcreteCompStrength (IFVariationAttr or float): compressive strength
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RelativeHumidity (IFVariationAttr or float): relative humidity
			NominalThickness (IFVariationAttr or float): nominal thickness
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			UseFullPerimeter (bool): if using section perimeter this sets the interior factor to 1
			SilicaFumeType (int): silica fume type
			Temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addIndiaConcreteCreep(self, MeanConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, UseNominalThickness, InteriorPerimFactor, UseFullPerimeter, temperature) -> IFMaterialIsotropic:
		r"""
		add codified creep for India IRC:112-2011 
		Params:
			MeanConcreteCompStrength (IFVariationAttr or float): compressive strength
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RelativeHumidity (IFVariationAttr or float): relative humidity
			NominalThickness (IFVariationAttr or float): nominal thickness
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			UseFullPerimeter (bool): if using section perimeter this sets the interior factor to 1
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addJTG3362_2018ConcreteCreep(self, MeanConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, UseNominalThickness, InteriorPerimFactor, UseFullPerimeter, FlyAshPer, Temperature, AdjustForTemperature=None) -> IFMaterialIsotropic:
		r"""
		add codified creep for JTG3362 2018 
		Params:
			MeanConcreteCompStrength (IFVariationAttr or float): compressive strength
			CementType (str): "Slow hardening", "Normal or Rapid Hardening", or "Rapid Hardening High Strength"
			RelativeHumidity (IFVariationAttr or float): relative humidity
			NominalThickness (IFVariationAttr or float): nominal thickness
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			UseFullPerimeter (bool): if using section perimeter this sets the interior factor to 1
			FlyAshPer (IFVariationAttr or float): fly ash percentage
			Temperature (float): temperature
			AdjustForTemperature (bool, optional): if T tabulate temperature else ignore temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addfib2010ConcreteCreep(self, UniaxialConcreteCompStrength, CementType, RelativeHumidity, NominalThickness, UseNominalThickness, InteriorPerimFactor, UseFullPerimeter, AggregateType, AdjustTemperature, Moisture, OverDryDensity, PermanentLoadsDominate, PrevailingTemperature) -> IFMaterialIsotropic:
		r"""
		add codified creep for fib 2010 
		Params:
			UniaxialConcreteCompStrength (IFVariationAttr or float): uniaxial compressive strength
			CementType (str): "32.5 N", "32.5 R, 42.5 N", or "42.5 R, 52.5 N, 52.5 R"
			RelativeHumidity (IFVariationAttr or float): relative humidity
			NominalThickness (IFVariationAttr or float): nominal thickness
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			UseFullPerimeter (bool): if using section perimeter this sets the interior factor to 1
			AggregateType (str): "Normal", "Lightweight low strength","Lightweight high strength"
			AdjustTemperature (bool): adjust for temperature during service life
			Moisture (IFVariationAttr or float): moisture content for cryogenic conditions (by % mass)
			OverDryDensity (IFVariationAttr or float): over dry density
			PermanentLoadsDominate (bool): permanent loads dominate
			PrevailingTemperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addCebFipPlasticMaterial86(self, heatFraction, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 CEBFIP code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addEurocodePlasticMaterial86(self, heatFraction, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 Euro code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addJTG3362_2018PlasticMaterial86(self, heatFraction, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 JTG3362 2018 code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addfib2010PlasticMaterial86(self, heatFraction, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 fib 2010 code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addIndiaPlasticMaterial86(self, heatFraction, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 IRC code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addAashtoPlasticMaterial86(self, heatFraction, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 AASHTO code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addChinesePlasticMaterial86(self, heatFraction, vParamA, vParamB, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 Chinese code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			vParamA (IFVariationAttr or float): parameter A
			vParamB (IFVariationAttr or float): parameter A
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addAS5100PlasticMaterial86(self, heatFraction, temperature) -> IFMaterialIsotropic:
		r"""
		add plastic component for material model 86 AS5100 code 
		Params:
			heatFraction (IFVariationAttr or float): heat fraction
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addChineseConcreteCreep(self, vF1, vG1, vP1, vR1, vF2, vG2, vP2, vR2, vF3, vR3, temperature) -> IFMaterialIsotropic:
		r"""
		add Chinese creep component 
		Params:
			vF1 (IFVariationAttr or float): parameter F1
			vG1 (IFVariationAttr or float): parameter G1
			vP1 (IFVariationAttr or float): parameter P1
			vR1 (IFVariationAttr or float): parameter R1
			vF2 (IFVariationAttr or float): parameter F2
			vG2 (IFVariationAttr or float): parameter G2
			vP2 (IFVariationAttr or float): parameter P2
			vR2 (IFVariationAttr or float): parameter R2
			vF3 (IFVariationAttr or float): parameter F3
			vR3 (IFVariationAttr or float): parameter R3
			temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addAS5100ConcreteCreep(self, environmentalFactorType, EnvironmentalFactor, MeanConcreteCompStrength, NominalThickness, UseNominalThickness, InteriorPerimFactor, UseFullPerimeter, Temperature) -> IFMaterialIsotropic:
		r"""
		add codified creep for AS5100.5 
		Params:
			environmentalFactorType (str): defining the environmental factor type, "Arid","Interior","Temperate","Tropical","Custom"
			EnvironmentalFactor (IFVariationAttr or float): environmental Factor rk4, only use if the environmental factor type = "Custom", else ignored
			MeanConcreteCompStrength (IFVariationAttr or float): mean compressive strength fr
			NominalThickness (IFVariationAttr or float): nominal;l thickness Hr
			UseNominalThickness (bool): if true use the specified nominal thickness, if false use section perimeter
			InteriorPerimFactor (IFVariationAttr or float): if using section perimeter this is the factor on the holes
			UseFullPerimeter (bool): if using section perimeter this sets the interior factor to 1
			Temperature (float): temperature
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addAashtoConcreteCreep(self, rowIndex, vMeanConcreteCompStrength, vRelativeHumidity, temperature, whichEdition=None) -> IFMaterialIsotropic:
		r"""
		add AASHTO creep component 
		Params:
			rowIndex (int): 
			vMeanConcreteCompStrength (IFVariationAttr or float): compressive strength
			vRelativeHumidity (IFVariationAttr or float): relative humidity
			temperature (float): temperature
			whichEdition (str, optional): AASHTO edition
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def setAashtoCreepType(self, rowIndex, useCreepCommentary, whichEdition=None) -> IFMaterialIsotropic:
		r"""
		set AASHTO creep type 
		Params:
			rowIndex (int): 
			useCreepCommentary (bool): use creep commentary
			whichEdition (str, optional): AASHTO edition
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def setAashtoCreepVolumeToSurfaceRatio(self, rowIndex, useNotionalThickness, UseFullPerimeter, value, whichEdition=None) -> IFMaterialIsotropic:
		r"""
		set AASHTO notional size data 
		Params:
			rowIndex (int): row index
			useNotionalThickness (bool): using nominal thickness
			UseFullPerimeter (bool): use the full perimeter
			value (IFVariationAttr or float): nominal thickness or interior perimeter factor
			whichEdition (str, optional): AASHTO edition
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def setAashtoCreepPre28days(self, rowIndex, use28dayCreepValues, CementType, whichEdition=None) -> IFMaterialIsotropic:
		r"""
		set AASHTO creep data 
		Params:
			rowIndex (int): row index
			use28dayCreepValues (bool): using 28 day creep values
			CementType (str): cement type
			whichEdition (str, optional): AASHTO edition
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def setAashtoCreepWeightClass(self, rowIndex, K1, weightClass, whichEdition=None) -> IFMaterialIsotropic:
		r"""
		set AASHTO weight class 
		Params:
			rowIndex (int): row index
			K1 (IFVariationAttr or float): aggregate correction
			weightClass (str): weight class
			whichEdition (str, optional): AASHTO edition
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def setAashtoCreepInputElastic(self, rowIndex, whichEdition=None) -> IFMaterialIsotropic:
		r"""
		set AASHTO creep input type 
		Params:
			rowIndex (int): row index
			whichEdition (str, optional): AASHTO edition
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addCebfipConcreteShrinkage(self) -> IFMaterialIsotropic:
		r"""
		add CEB-FIP shrinkage component 
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addEurocode2ConcreteShrinkage(self, vIncludeAutogenous) -> IFMaterialIsotropic:
		r"""
		add EuropCode2 shrinkage component 
		Params:
			vIncludeAutogenous (bool): include autogenous
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addIndiaConcreteShrinkage(self, vIncludeAutogenous) -> IFMaterialIsotropic:
		r"""
		add India IRC shrinkage component 
		Params:
			vIncludeAutogenous (bool): include autogenous
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addAashtoConcreteShrinkage(self, useCommentary, whichEdition=None) -> IFMaterialIsotropic:
		r"""
		add AASHTO shrinkage component 
		Params:
			useCommentary (bool): use shrinkage commentary
			whichEdition (str, optional): AASHTO edition
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addJTG3362_2018ConcreteShrinkage(self) -> IFMaterialIsotropic:
		r"""
		add JTG3362 2018 shrinkage component 
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addfib2010ConcreteShrinkage(self) -> IFMaterialIsotropic:
		r"""
		add fib 2010 shrinkage component 
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


	def addAS5100ConcreteShrinkage(self, aggregateSourceType, ecsdb, rhos) -> IFMaterialIsotropic:
		r"""
		add AS5100.5 shrinkage component 
		Params:
			aggregateSourceType (str): defining the aggregate source for the shrinkage strain, "Sydney","Melbourne","Elsewhere","Custom"
			ecsdb (IFVariationAttr or float): final drying basic shrinkage strain, only use if the aggregate source type = "Custom", else ignored
			rhos (IFVariationAttr or float): percentage of reinforcement
		Returns:
			IFMaterialIsotropic: 
		"""
		pass


class IFMaterialOrthotropic(IFMaterialTropicSet):
	"""
	Additional orthotropic material attribute data 
	"""

	def addElasticPlaneStressMaterial(self, YoungX, YoungY, ShearXY, PoissonXY, Angle, Density, temperature, defnPageType=None) -> IFMaterialOrthotropic:
		r"""
		Add elastic plane stress properties to orthotropic material attribute 
		Params:
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			ShearXY (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float): temperature
			defnPageType (str, optional): "Plane stress", "Axisymmetric shell"
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addElasticPlaneStrainMaterial(self, YoungX, YoungY, YoungZ, ShearXY, PoissonXY, PoissonYZ, PoissonXZ, Angle, Density, temperature) -> IFMaterialOrthotropic:
		r"""
		Add elastic plane strain properties to orthotropic material attribute 
		Params:
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			YoungZ (IFVariationAttr or float): Young's modulus in Z
			ShearXY (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			PoissonYZ (IFVariationAttr or float): Poisson's ratio in YZ
			PoissonXZ (IFVariationAttr or float): Poisson's ratio in XZ
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float): 
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addElasticSheetMaterial(self, YoungX, YoungY, PoissonXY, Angle, Density, temperature) -> IFMaterialOrthotropic:
		r"""
		Add elastic sheet properties to orthotropic material attribute 
		Params:
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float): 
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addElasticThickMaterial(self, YoungX, YoungY, ShearXY, ShearYZ, ShearXZ, PoissonXY, Angle, Density, temperature) -> IFMaterialOrthotropic:
		r"""
		Add elastic thick shell properties to orthotropic material attribute 
		Params:
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			ShearXY (IFVariationAttr or float): 
			ShearYZ (IFVariationAttr or float): 
			ShearXZ (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float): 
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addElasticAxisymmetricMaterial(self, YoungX, YoungY, YoungZ, ShearXY, PoissonXY, PoissonYZ, PoissonXZ, Angle, Density, temperature) -> IFMaterialOrthotropic:
		r"""
		Add elastic axisymmetric solid properties to orthotropic material attribute 
		Params:
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			YoungZ (IFVariationAttr or float): Young's modulus in Z
			ShearXY (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			PoissonYZ (IFVariationAttr or float): Poisson's ratio in YZ
			PoissonXZ (IFVariationAttr or float): Poisson's ratio in XZ
			Angle (IFVariationAttr or float): 
			Density (IFVariationAttr or float): density
			temperature (float): 
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addElasticSolidMaterial(self, YoungX, YoungY, YoungZ, ShearXY, ShearYZ, ShearXZ, PoissonXY, PoissonYZ, PoissonXZ, Density, temperature) -> IFMaterialOrthotropic:
		r"""
		Add elastic solid properties to orthotropic material attribute 
		Params:
			YoungX (IFVariationAttr or float): Young's modulus in X
			YoungY (IFVariationAttr or float): Young's modulus in Y
			YoungZ (IFVariationAttr or float): Young's modulus in Z
			ShearXY (IFVariationAttr or float): 
			ShearYZ (IFVariationAttr or float): 
			ShearXZ (IFVariationAttr or float): 
			PoissonXY (IFVariationAttr or float): Poisson's ratio in XY
			PoissonYZ (IFVariationAttr or float): Poisson's ratio in YZ
			PoissonXZ (IFVariationAttr or float): Poisson's ratio in XZ
			Density (IFVariationAttr or float): density
			temperature (float): 
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addPlasticStressPotentialHill(self, StressX, StressY, StressZ, StressXY, StressYZ, StressXZ, temperature=None) -> IFMaterialOrthotropic:
		r"""
		Add nonlinear plastic stress potential properties for Hill criteria to orthotropic material attribute 
		Params:
			StressX (IFVariationAttr or float): 
			StressY (IFVariationAttr or float): 
			StressZ (IFVariationAttr or float): 
			StressXY (IFVariationAttr or float): 
			StressYZ (IFVariationAttr or float): 
			StressXZ (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addPlasticStressPotentialHoffman(self, StressXTension, StressXCompression, StressYTension, StressYCompression, StressZTension, StressZCompression, StressXY, StressYZ, StressXZ, temperature=None) -> IFMaterialOrthotropic:
		r"""
		Add nonlinear plastic stress potential properties for Hoffman criteria to orthotropic material attribute 
		Params:
			StressXTension (IFVariationAttr or float): 
			StressXCompression (IFVariationAttr or float): 
			StressYTension (IFVariationAttr or float): 
			StressYCompression (IFVariationAttr or float): 
			StressZTension (IFVariationAttr or float): 
			StressZCompression (IFVariationAttr or float): 
			StressXY (IFVariationAttr or float): 
			StressYZ (IFVariationAttr or float): 
			StressXZ (IFVariationAttr or float): 
			temperature (float, optional): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def setPhaseChange(self, phase) -> IFMaterialOrthotropic:
		r"""
		set thermal/field material phase change 
		Params:
			phase (str): 
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField2dOrthoMaterial(self, KX, KY, THETA, temp, C, H, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 2D thermal/field properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField3dOrthoMaterial(self, KX, KY, KZ, temp, C, H, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 3D thermal/field properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField2dResinGenericMaterial(self, KX, KY, THETA, temp, C, H, V, A1, A2, A3, E1, E2, E3, R, B1, B2, m1, n1, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 2D thermal/field generic resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			A3 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			E3 (IFVariationAttr or float): 
			R (float): 
			B1 (IFVariationAttr or float): 
			B2 (IFVariationAttr or float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField3dResinGenericMaterial(self, KX, KY, KZ, temp, C, H, V, A1, A2, A3, E1, E2, E3, R, B1, B2, m1, n1, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 3D thermal/field generic resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			A3 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			E3 (IFVariationAttr or float): 
			R (float): 
			B1 (IFVariationAttr or float): 
			B2 (IFVariationAttr or float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField2dResinNthMaterial(self, KX, KY, THETA, temp, C, H, V, A1, A2, E1, E2, R, m1, n1, n2, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 2D thermal/field Nth resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			n2 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField3dResinNthMaterial(self, KX, KY, KZ, temp, C, H, V, A1, A2, E1, E2, R, m1, n1, n2, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 3D thermal/field Nth resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			n2 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField2dResinEcmMaterial(self, KX, KY, THETA, temp, C, H, V, A1, A2, E1, E2, R, G, p1, q1, r1, p2, r2, Cr, S, Z, Tmx, Tc, FE, D, Q, G0, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 2D thermal/field ECM resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			G (IFVariationAttr or float): 
			p1 (IFVariationAttr or float): 
			q1 (IFVariationAttr or float): 
			r1 (IFVariationAttr or float): 
			p2 (IFVariationAttr or float): 
			r2 (IFVariationAttr or float): 
			Cr (IFVariationAttr or float): 
			S (IFVariationAttr or float): 
			Z (IFVariationAttr or float): 
			Tmx (IFVariationAttr or float): 
			Tc (IFVariationAttr or float): 
			FE (IFVariationAttr or float): 
			D (IFVariationAttr or float): 
			Q (IFVariationAttr or float): 
			G0 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField3dResinEcmMaterial(self, KX, KY, KZ, temp, C, H, V, A1, A2, E1, E2, R, G, p1, q1, r1, p2, r2, Cr, S, Z, Tmx, Tc, FE, D, Q, G0, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 3D thermal/field ECM resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			G (IFVariationAttr or float): 
			p1 (IFVariationAttr or float): 
			q1 (IFVariationAttr or float): 
			r1 (IFVariationAttr or float): 
			p2 (IFVariationAttr or float): 
			r2 (IFVariationAttr or float): 
			Cr (IFVariationAttr or float): 
			S (IFVariationAttr or float): 
			Z (IFVariationAttr or float): 
			Tmx (IFVariationAttr or float): 
			Tc (IFVariationAttr or float): 
			FE (IFVariationAttr or float): 
			D (IFVariationAttr or float): 
			Q (IFVariationAttr or float): 
			G0 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField2dResinMfkMaterial(self, KX, KY, THETA, temp, C, H, V, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 2D thermal/field MFK resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addField3dResinMfkMaterial(self, KX, KY, KZ, temp, C, H, V, rho=None) -> IFMaterialOrthotropic:
		r"""
		Add 3D thermal/field MFK resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addFieldResinMfkCurveData(self, rowIndex, time, cure, temp) -> IFMaterialOrthotropic:
		r"""
		Add curve data to the MFK resin material 
		Params:
			rowIndex (int): 
			time (float): 
			cure (float): 
			temp (float): 
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addConcrete2dMaterial(self, KX, KY, THETA, temp, C, H, CementType, wcem, wcra, wslg, wpfa, pfacao, Tr, rho=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialOrthotropic:
		r"""
		Add thermal properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			Tr (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addConcrete3dMaterial(self, KX, KY, KZ, temp, C, H, CementType, wcem, wcra, wslg, wpfa, pfacao, Tr, rho=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialOrthotropic:
		r"""
		Add thermal properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			Tr (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addConcreteUser2dMaterial(self, KX, KY, THETA, temp, C, H, CementType, wcem, wcra, wslg, wpfa, pfacao, Tr, C3S, C2S, C3A, C4AF, FreeCao, SO3, MgO, Blaine, rho=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialOrthotropic:
		r"""
		Add thermal properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			Tr (IFVariationAttr or float): 
			C3S (IFVariationAttr or float): 
			C2S (IFVariationAttr or float): 
			C3A (IFVariationAttr or float): 
			C4AF (IFVariationAttr or float): 
			FreeCao (IFVariationAttr or float): 
			SO3 (IFVariationAttr or float): 
			MgO (IFVariationAttr or float): 
			Blaine (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addConcreteUser3dMaterial(self, KX, KY, KZ, temp, C, H, CementType, wcem, wcra, wslg, wpfa, pfacao, Tr, C3S, C2S, C3A, C4AF, FreeCao, SO3, MgO, Blaine, rho=None, rdh=None, rhh=None, rht=None, rae=None, rhs=None) -> IFMaterialOrthotropic:
		r"""
		Add thermal properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			CementType (str): 
			wcem (IFVariationAttr or float): 
			wcra (IFVariationAttr or float): 
			wslg (IFVariationAttr or float): 
			wpfa (IFVariationAttr or float): 
			pfacao (IFVariationAttr or float): 
			Tr (IFVariationAttr or float): 
			C3S (IFVariationAttr or float): 
			C2S (IFVariationAttr or float): 
			C3A (IFVariationAttr or float): 
			C4AF (IFVariationAttr or float): 
			FreeCao (IFVariationAttr or float): 
			SO3 (IFVariationAttr or float): 
			MgO (IFVariationAttr or float): 
			Blaine (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
			rdh (float, optional): Ultimate Degree of Hydration correction factor (default 1.0)
			rhh (float, optional): Heat of hydration correction factor (default 1.0)
			rht (float, optional): Hydration time correction factor (default 1.0)
			rae (float, optional): Activation Energy correction factor (default 1.0)
			rhs (float, optional): Hydration slope correction factor (default 1.0)
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addMasonryPlaneStressRow(self, Ftxx, Fcxx, Ftyy, Fcyy, Ftxy, Fcxy, ht, alphaf, alphap, gammad, Gftx, Gfcx, Gfty, Gfcy, idp, nIter, temperature) -> IFMaterialOrthotropic:
		r"""
		Add plane stress masonry material properties to this orthotropic material attribute 
		Params:
			Ftxx (IFVariationAttr or float): tensile strength in x direction
			Fcxx (IFVariationAttr or float): compressive strength in x direction
			Ftyy (IFVariationAttr or float): tensile strength in y direction
			Fcyy (IFVariationAttr or float): compressive strength in y direction
			Ftxy (IFVariationAttr or float): tensile shear strength xy
			Fcxy (IFVariationAttr or float): compressive shear strength xy
			ht (IFVariationAttr or float): tensile hardening/softerning parameter
			alphaf (IFVariationAttr or float): friction angle or bi/uniaxial compressive strength
			alphap (IFVariationAttr or float): dilancy angle parameter
			gammad (IFVariationAttr or float): initial compressive damage threshold parameter
			Gftx (IFVariationAttr or float): tenside fracture energy per unit area in x direction
			Gfcx (IFVariationAttr or float): compressive fracture energy per unit area in x direction
			Gfty (IFVariationAttr or float): tenside fracture energy per unit area in y direction
			Gfcy (IFVariationAttr or float): compressive fracture energy per unit area in y direction
			idp (str): damage-plasticity coupling
			nIter (int): number of iterations
			temperature (float): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addMasonryPlaneStrainRow(self, Ftxx, Fcxx, Ftyy, Fcyy, Ftzz, Fczz, Ftxy, Fcxy, ht, alphaf, alphap, gammad, Gftx, Gfcx, Gfty, Gfcy, idp, nIter, temperature) -> IFMaterialOrthotropic:
		r"""
		Add plane strain masonry material properties to this orthotropic material attribute 
		Params:
			Ftxx (IFVariationAttr or float): tensile strength in x direction
			Fcxx (IFVariationAttr or float): compressive strength in x direction
			Ftyy (IFVariationAttr or float): tensile strength in y direction
			Fcyy (IFVariationAttr or float): compressive strength in y direction
			Ftzz (IFVariationAttr or float): tensile strength in z direction
			Fczz (IFVariationAttr or float): compressive strength in z direction
			Ftxy (IFVariationAttr or float): tensile shear strength xy
			Fcxy (IFVariationAttr or float): compressive shear strength xy
			ht (IFVariationAttr or float): tensile hardening/softerning parameter
			alphaf (IFVariationAttr or float): friction angle or bi/uniaxial compressive strength
			alphap (IFVariationAttr or float): dilancy angle parameter
			gammad (IFVariationAttr or float): initial compressive damage threshold parameter
			Gftx (IFVariationAttr or float): tenside fracture energy per unit area in x direction
			Gfcx (IFVariationAttr or float): compressive fracture energy per unit area in x direction
			Gfty (IFVariationAttr or float): tenside fracture energy per unit area in y direction
			Gfcy (IFVariationAttr or float): compressive fracture energy per unit area in y direction
			idp (str): damage-plasticity coupling
			nIter (int): number of iterations
			temperature (float): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addMasonryThickShellRow(self, Ftxx, Fcxx, Ftyy, Fcyy, Ftxy, Fcxy, Ftxz, Fcxz, Ftyz, Fcyz, ht, alphaf, alphap, gammad, Gftx, Gfcx, Gfty, Gfcy, idp, nIter, temperature) -> IFMaterialOrthotropic:
		r"""
		Add thick shell masonry material properties to this orthotropic material attribute 
		Params:
			Ftxx (IFVariationAttr or float): tensile strength in x direction
			Fcxx (IFVariationAttr or float): compressive strength in x direction
			Ftyy (IFVariationAttr or float): tensile strength in y direction
			Fcyy (IFVariationAttr or float): compressive strength in y direction
			Ftxy (IFVariationAttr or float): tensile shear strength xy
			Fcxy (IFVariationAttr or float): compressive shear strength xy
			Ftxz (IFVariationAttr or float): tensile shear strength xz
			Fcxz (IFVariationAttr or float): compressive shear strength xz
			Ftyz (IFVariationAttr or float): tensile shear strength yz
			Fcyz (IFVariationAttr or float): compressive shear strength yz
			ht (IFVariationAttr or float): tensile hardening/softerning parameter
			alphaf (IFVariationAttr or float): friction angle or bi/uniaxial compressive strength
			alphap (IFVariationAttr or float): dilancy angle parameter
			gammad (IFVariationAttr or float): initial compressive damage threshold parameter
			Gftx (IFVariationAttr or float): tenside fracture energy per unit area in x direction
			Gfcx (IFVariationAttr or float): compressive fracture energy per unit area in x direction
			Gfty (IFVariationAttr or float): tenside fracture energy per unit area in y direction
			Gfcy (IFVariationAttr or float): compressive fracture energy per unit area in y direction
			idp (str): damage-plasticity coupling
			nIter (int): number of iterations
			temperature (float): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addMasonrySolidRow(self, Ftxx, Fcxx, Ftyy, Fcyy, Ftzz, Fczz, Ftxy, Fcxy, Ftyz, Fcyz, Ftxz, Fcxz, ht, alphaf, alphap, gammad, Gftx, Gfcx, Gfty, Gfcy, idp, nIter, temperature) -> IFMaterialOrthotropic:
		r"""
		Add solid masonry material properties to this orthotropic material attribute 
		Params:
			Ftxx (IFVariationAttr or float): tensile strength in x direction
			Fcxx (IFVariationAttr or float): compressive strength in x direction
			Ftyy (IFVariationAttr or float): tensile strength in y direction
			Fcyy (IFVariationAttr or float): compressive strength in y direction
			Ftzz (IFVariationAttr or float): tensile strength in z direction
			Fczz (IFVariationAttr or float): compressive strength in z direction
			Ftxy (IFVariationAttr or float): tensile shear strength xy
			Fcxy (IFVariationAttr or float): compressive shear strength xy
			Ftyz (IFVariationAttr or float): tensile shear strength yz
			Fcyz (IFVariationAttr or float): compressive shear strength yz
			Ftxz (IFVariationAttr or float): tensile shear strength xz
			Fcxz (IFVariationAttr or float): compressive shear strength xz
			ht (IFVariationAttr or float): tensile hardening/softerning parameter
			alphaf (IFVariationAttr or float): friction angle or bi/uniaxial compressive strength
			alphap (IFVariationAttr or float): dilancy angle parameter
			gammad (IFVariationAttr or float): initial compressive damage threshold parameter
			Gftx (IFVariationAttr or float): tenside fracture energy per unit area in x direction
			Gfcx (IFVariationAttr or float): compressive fracture energy per unit area in x direction
			Gfty (IFVariationAttr or float): tenside fracture energy per unit area in y direction
			Gfcy (IFVariationAttr or float): compressive fracture energy per unit area in y direction
			idp (str): damage-plasticity coupling
			nIter (int): number of iterations
			temperature (float): temperature
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def removeMasonryPlasticCurve(self, rowIndex) -> IFMaterialOrthotropic:
		r"""
		remove the hardening/softening curve from the masonry material properties to this orthotropic material attribute 
		Params:
			rowIndex (int): zero base index of the row to which to add data
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def setMasonryPlasticCurve(self, rowIndex, Kpc, hc) -> IFMaterialOrthotropic:
		r"""
		define the hardening/softening curve parameters for the masonry material properties to this orthotropic material attribute 
		Params:
			rowIndex (int): zero base index of the row to which to add data
			Kpc (IFVariationAttr or float): plastic hardening parameter for compressive strength
			hc (IFVariationAttr or float): compressive hardening/softening parameter
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


	def addMasonryPlasticCurve(self, rowIndex, Kpi, fci) -> IFMaterialOrthotropic:
		r"""
		add a point on the hardening/softening curve for the masonry material properties to this orthotropic material attribute 
		Params:
			rowIndex (int): zero base index of the row to which to add data
			Kpi (float): hardening parameter of hardening/softening curve
			fci (float): conpressive uniaxial yield stress of hardening/softening curve
		Returns:
			IFMaterialOrthotropic: 
		"""
		pass


class IFCoupledWovenMaterial(IFMaterialTropicSet):
	"""
	 
	"""

	def setPhaseChange(self, phase) -> IFCoupledWovenMaterial:
		r"""
		set thermal/field material phase change 
		Params:
			phase (str): 
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField2dOrthoMaterial(self, KX, KY, THETA, temp, C, H, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 2D thermal/field properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField3dOrthoMaterial(self, KX, KY, KZ, temp, C, H, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 3D thermal/field properties to orthotropic material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField2dResinGenericMaterial(self, KX, KY, THETA, temp, C, H, V, A1, A2, A3, E1, E2, E3, R, B1, B2, m1, n1, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 2D thermal/field generic resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			A3 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			E3 (IFVariationAttr or float): 
			R (float): 
			B1 (IFVariationAttr or float): 
			B2 (IFVariationAttr or float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField3dResinGenericMaterial(self, KX, KY, KZ, temp, C, H, V, A1, A2, A3, E1, E2, E3, R, B1, B2, m1, n1, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 3D thermal/field generic resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			A3 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			E3 (IFVariationAttr or float): 
			R (float): 
			B1 (IFVariationAttr or float): 
			B2 (IFVariationAttr or float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField2dResinNthMaterial(self, KX, KY, THETA, temp, C, H, V, A1, A2, E1, E2, R, m1, n1, n2, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 2D thermal/field Nth resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			n2 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField3dResinNthMaterial(self, KX, KY, KZ, temp, C, H, V, A1, A2, E1, E2, R, m1, n1, n2, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 3D thermal/field Nth resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			m1 (IFVariationAttr or float): 
			n1 (IFVariationAttr or float): 
			n2 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField2dResinEcmMaterial(self, KX, KY, THETA, temp, C, H, V, A1, A2, E1, E2, R, G, p1, q1, r1, p2, r2, Cr, S, Z, Tmx, Tc, FE, D, Q, G0, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 2D thermal/field ECM resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			G (IFVariationAttr or float): 
			p1 (IFVariationAttr or float): 
			q1 (IFVariationAttr or float): 
			r1 (IFVariationAttr or float): 
			p2 (IFVariationAttr or float): 
			r2 (IFVariationAttr or float): 
			Cr (IFVariationAttr or float): 
			S (IFVariationAttr or float): 
			Z (IFVariationAttr or float): 
			Tmx (IFVariationAttr or float): 
			Tc (IFVariationAttr or float): 
			FE (IFVariationAttr or float): 
			D (IFVariationAttr or float): 
			Q (IFVariationAttr or float): 
			G0 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField3dResinEcmMaterial(self, KX, KY, KZ, temp, C, H, V, A1, A2, E1, E2, R, G, p1, q1, r1, p2, r2, Cr, S, Z, Tmx, Tc, FE, D, Q, G0, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 3D thermal/field ECM resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			A1 (IFVariationAttr or float): 
			A2 (IFVariationAttr or float): 
			E1 (IFVariationAttr or float): 
			E2 (IFVariationAttr or float): 
			R (float): 
			G (IFVariationAttr or float): 
			p1 (IFVariationAttr or float): 
			q1 (IFVariationAttr or float): 
			r1 (IFVariationAttr or float): 
			p2 (IFVariationAttr or float): 
			r2 (IFVariationAttr or float): 
			Cr (IFVariationAttr or float): 
			S (IFVariationAttr or float): 
			Z (IFVariationAttr or float): 
			Tmx (IFVariationAttr or float): 
			Tc (IFVariationAttr or float): 
			FE (IFVariationAttr or float): 
			D (IFVariationAttr or float): 
			Q (IFVariationAttr or float): 
			G0 (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField2dResinMfkMaterial(self, KX, KY, THETA, temp, C, H, V, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 2D thermal/field MFK resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			THETA (IFVariationAttr or float): Angle of orthotropy (anticlockwise +ve)
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addField3dResinMfkMaterial(self, KX, KY, KZ, temp, C, H, V, rho=None) -> IFCoupledWovenMaterial:
		r"""
		Add 3D thermal/field MFK resin properties material attribute 
		Params:
			KX (IFVariationAttr or float): Conductivity in x
			KY (IFVariationAttr or float): Conductivity in x
			KZ (IFVariationAttr or float): Conductivity in x
			temp (float): Reference temperature
			C (IFVariationAttr or float): Volumetric heat coefficient (specific heat capacity * density)
			H (IFVariationAttr or float): Enthalpy
			V (IFVariationAttr or float): 
			rho (IFVariationAttr or float, optional): density
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


	def addFieldResinMfkCurveData(self, rowIndex, time, cure, temp) -> IFCoupledWovenMaterial:
		r"""
		Add curve data to the MFK resin material 
		Params:
			rowIndex (int): 
			time (float): 
			cure (float): 
			temp (float): 
		Returns:
			IFCoupledWovenMaterial: 
		"""
		pass


class IFMaterialNonlinearUser(IFMaterialTropicSet):
	"""
	Add properties to user material attribute 
	"""

	def addElastic(self, Young, Poisson, Density, temperature) -> IFMaterialNonlinearUser:
		r"""
		Add elastic properties to user material attribute 
		Params:
			Young (IFVariationAttr or float): Young's modulus
			Poisson (IFVariationAttr or float): Poisson's ratio
			Density (IFVariationAttr or float): density
			temperature (float): 
		Returns:
			IFMaterialNonlinearUser: 
		"""
		pass


class IFMaterialResultantUser(IFMaterialTropicSet):
	"""
	Add properties to user resultant material attribute 
	"""

	def addElastic(self, Young, Poisson, Density, temperature) -> IFMaterialResultantUser:
		r"""
		Add elastic properties to user resultant attribute 
		Params:
			Young (IFVariationAttr or float): Young's modulus
			Poisson (IFVariationAttr or float): Poisson's ratio
			Density (IFVariationAttr or float): density
			temperature (float): 
		Returns:
			IFMaterialResultantUser: 
		"""
		pass


	def addResultantUserComponent(self, modelID, nState) -> IFMaterialResultantUser:
		r"""
		 
		Params:
			modelID (int): Refer to the LUSAS Solver manual for details
			nState (int): Number of state variable
		Returns:
			IFMaterialResultantUser: 
		"""
		pass


	def addResultantUserCurve(self, Moment, Curvature, axialForce, row) -> IFMaterialResultantUser:
		r"""
		 
		Params:
			Moment (IFVariationAttr or float): 
			Curvature (IFVariationAttr or float): 
			axialForce (float): 
			row (int): 
		Returns:
			IFMaterialResultantUser: 
		"""
		pass


class IFFieldIsotropicMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFFieldOrthotropicMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFInterfaceMaterial(IFMaterial):
	"""
	 
	"""

	pass


class IFRubberMaterial(IFMaterial):
	"""
	 
	"""

	def addRow(self, rubberConst1, rubberConst2) -> IFRubberMaterial:
		r"""
		 
		Params:
			rubberConst1 (float): 
			rubberConst2 (float): 
		Returns:
			IFRubberMaterial: 
		"""
		pass


class IFVolumeCrushingMaterial(IFMaterial):
	"""
	 
	"""

	def addRow(self, relativeVol, pressureCoord) -> IFVolumeCrushingMaterial:
		r"""
		 
		Params:
			relativeVol (float): 
			pressureCoord (float): 
		Returns:
			IFVolumeCrushingMaterial: 
		"""
		pass


class IFMaterialMass(IFMaterial):
	"""
	 
	"""

	def isThreeDimensional(self) -> bool:
		r"""
		 
		Returns:
			bool: 
		"""
		pass


class IFPolymerMaterial(IFMaterial):
	"""
	 
	"""

	def addTensionRow(self, springConstant, viscousParameter) -> IFPolymerMaterial:
		r"""
		 
		Params:
			springConstant (float): 
			viscousParameter (float): 
		Returns:
			IFPolymerMaterial: 
		"""
		pass


	def addCompressionRow(self, springConstant, viscousParameter) -> IFPolymerMaterial:
		r"""
		 
		Params:
			springConstant (float): 
			viscousParameter (float): 
		Returns:
			IFPolymerMaterial: 
		"""
		pass


class IFGPMdamageMaterial(IFMaterial):
	"""
	 
	"""

	def addTensionRow(self, shearModulus, viscousParameter) -> IFGPMdamageMaterial:
		r"""
		 
		Params:
			shearModulus (float): Tension Maxwell element
			viscousParameter (float): 
		Returns:
			IFGPMdamageMaterial: 
		"""
		pass


	def addCompressionRow(self, shearModulus, viscousParameter) -> IFGPMdamageMaterial:
		r"""
		 
		Params:
			shearModulus (float): Compression Maxwell element
			viscousParameter (float): 
		Returns:
			IFGPMdamageMaterial: 
		"""
		pass


	def addDamageTensionRow(self, xCrdDamageFunc, yCrdDamageFunc) -> IFGPMdamageMaterial:
		r"""
		 
		Params:
			xCrdDamageFunc (float): Coordinates on the tension damage function
			yCrdDamageFunc (float): 
		Returns:
			IFGPMdamageMaterial: 
		"""
		pass


	def addDamageCompressionRow(self, xCrdDamageFunc, yCrdDamageFunc) -> IFGPMdamageMaterial:
		r"""
		 
		Params:
			xCrdDamageFunc (float): Coordinates on the compression damage function
			yCrdDamageFunc (float): 
		Returns:
			IFGPMdamageMaterial: 
		"""
		pass


class IFComposite(IFAttribute):
	"""
	 
	"""

	def visualise(self) -> IFComposite:
		r"""
		display a dialog containing a visualisation of the definition of this composite 
		Returns:
			IFComposite: 
		"""
		pass


	def setSymmetric(self, bSymmetric) -> IFComposite:
		r"""
		specify whether or not this composite is symmetric. Setting this flag true causes LUSAS to automatically create another copy of each lamina, appended to the end and in reverse order 
		Params:
			bSymmetric (bool): Symmetry flag
		Returns:
			IFComposite: 
		"""
		pass


class IFCompositeBeam(IFComposite):
	"""
	 
	"""

	def addLayer(self, layerName, material) -> IFCompositeBeam:
		r"""
		 
		Params:
			layerName (str): Layer name
			material (IFMaterial): The name or ID of a material, or a pointer to a IFMaterial object.
		Returns:
			IFCompositeBeam: 
		"""
		pass


class IFCompositeShell(IFComposite):
	"""
	 
	"""

	def addLayer(self, layerName, thickness, angle, material, volumeFraction=None) -> IFCompositeShell:
		r"""
		 
		Params:
			layerName (str): Layer name
			thickness (float): Relative thickness
			angle (float): Angle of fibre relative to reference axis
			material (IFMaterial): The name or ID of a material, or a pointer to a IFMaterial object.
			volumeFraction (float, optional): volume fraction for a non-draped composite
		Returns:
			IFCompositeShell: 
		"""
		pass


class IFCompositeWoven(IFComposite):
	"""
	 
	"""

	def addLayer(self, layerName, thickness, volumeFraction, startPoint, startDirection, material, lyrOffsetDir=None) -> IFCompositeWoven:
		r"""
		Adds a layer of material 
		Params:
			layerName (str): 
			thickness (float): 
			volumeFraction (float): 
			startPoint (IFPoint): The name or ID of a point, or a pointer to a IFPoint object.
			startDirection (array of float): An array of 3 real numbers, representing 3d coordinates
			material (IFMaterial): The name or ID of a material, or a pointer to a IFMaterial object.
			lyrOffsetDir (str, optional): layer drape offset direction "default", "positive" or "negative"
		Returns:
			IFCompositeWoven: 
		"""
		pass


class IFCompositeFiberSIM(IFComposite):
	"""
	A composite created and defined by importing a FiberSIM XML file. It is not possible to add, rename or remove laminae, but thickness and material information for each lamina must be added 
	"""

	def setLayerInfo(self, layerName, thickness, volumeFraction, material, refOffsetLayerName=None, lyrOffsetDir=None) -> IFCompositeFiberSIM:
		r"""
		Sets layer info 
		Params:
			layerName (str): name of the layer to change
			thickness (float): thickness of the layer
			volumeFraction (float): initial volume fibre fraction
			material (IFMaterial): The name or ID of a material, or a pointer to a IFMaterial object. material of the layer
			refOffsetLayerName (str, optional): name of the layer from which this layer is offset
			lyrOffsetDir (str, optional): layer drape offset direction "default", "positive" or "negative"
		Returns:
			IFCompositeFiberSIM: 
		"""
		pass


class IFCompositeSimulayt(IFComposite):
	"""
	A composite created and defined by importing a Simulayt layup file. It is not possible to add, rename or remove laminae, but thickness and material information for each lamina must be added 
	"""

	def setLayerInfo(self, layerName, thickness, volumeFraction, material, refOffsetLayerName=None, lyrOffsetDir=None) -> IFCompositeSimulayt:
		r"""
		Sets layer info 
		Params:
			layerName (str): name of the layer to change
			thickness (float): thickness of the layer
			volumeFraction (float): initial volume fibre fraction
			material (IFMaterial): The name or ID of a material, or a pointer to a IFMaterial object. material of the layer
			refOffsetLayerName (str, optional): name of the layer from which this layer is offset
			lyrOffsetDir (str, optional): layer drape offset direction "default", "positive" or "negative"
		Returns:
			IFCompositeSimulayt: 
		"""
		pass


class IFInfluence(IFAttribute):
	"""
	influence line 
	"""

	def setInfluence(self, type, influenceDir, positive) -> IFInfluence:
		r"""
		Sets up an influence line. 
		Params:
			type (str): 'Moment', 'Force', 'Reaction', 'Displacement'
			influenceDir (str): 'Longitudinal', 'Transverse', 'Vertical'
			positive (bool): direction; TRUE if positive
		Returns:
			IFInfluence: 
		"""
		pass


class IFInfluenceEnvelope(IFAttribute):
	"""
	Direct Method Influence Envelope Attribute (DMIE) 
	"""

	def setEntity(self, entityName) -> None:
		r"""
		Set the results entity 
		Params:
			entityName (str): results entity name
		Returns:
			None: 
		"""
		pass


	def addComponentNames(self, cmpNames) -> None:
		r"""
		Set the results component names 
		Params:
			cmpNames (array of strs): result component names
		Returns:
			None: 
		"""
		pass


	def includeCoincident(self, doINclude) -> None:
		r"""
		Set whether to include coincident components 
		Params:
			doINclude (bool): include coincident components
		Returns:
			None: 
		"""
		pass


	def getAllInfluenceAssignsToAnalyse(self, pIEnvRun, determineHoggingFlags) -> list[IFVLOInfluenceAssignEntry]:
		r"""
		Returns all influence assignments to be analysed 
		Params:
			pIEnvRun (IFTLOEnvelopeRun): the TLO envelope run for which these are requested; needed to get the inf factors that apply to all the influences
			determineHoggingFlags (bool): true if you want to determine if the node at the influence assignment is in hogging under a gravity load applied on the deck
		Returns:
			array of IFVLOInfluenceAssignEntry objects: The returned array
		"""
		pass


	def getAnalysis(self) -> IFAnalysisBaseClass:
		r"""
		Return the analysis within which this is assigned in 
		Returns:
			IFAnalysisBaseClass: 
		"""
		pass


	def assignToBeamShellSlice(self, sliceName, dmiAnalysisName) -> None:
		r"""
		Assigns this attribute to the beam shell slice specified 
		Params:
			sliceName (str): name of the slice
			dmiAnalysisName (str): DMI analysis name where the influence att is assigned
		Returns:
			None: 
		"""
		pass


	def deassignFromBeamShellSlice(self, sliceName, dmiAnalysisName) -> None:
		r"""
		Deassigns this attribute from the beam shell slice specified 
		Params:
			sliceName (str): name of the slice
			dmiAnalysisName (str): DMI analysis name where the slice to deassign from
		Returns:
			None: 
		"""
		pass


	def setResultsTransformElement(self) -> None:
		r"""
		Uses element local axes as the results transformation for this attribute. (For continuous results, such as displacement, nodal axes (transformed freedoms) are used) 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformNone(self) -> None:
		r"""
		Switches off all results transformation for this attribute. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformXYAngle(self, XYAngle) -> None:
		r"""
		Uses the specified angle (in the XY plane - i.e. about Z) as the results transformation for this sub-chapter. 
		Params:
			XYAngle (float): 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformLocal(self, localCoords, shellPlane) -> None:
		r"""
		Uses the specified local coordinate as the results transformation for this attribute. 
		Params:
			localCoords (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
			shellPlane (int): Shell plane for resultants (1, 2 or 3)
		Returns:
			None: 
		"""
		pass


	def setResultsTransformPath(self, path, skew=None) -> None:
		r"""
		Uses the specified path as the results transformation for this attribute. 
		Params:
			path (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
			skew (bool, optional): True if local y = transverse
		Returns:
			None: 
		"""
		pass


	def setResultsTransformFeature(self) -> None:
		r"""
		Uses the parent feature's local directions as the results transformation for this attribute. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformGlobal(self) -> None:
		r"""
		Uses the global axes directions as the results transformation for this attribute. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformAttributeType(self, type) -> None:
		r"""
		Uses the given attribute type to obtain the results transformation for this attribute. 
		Params:
			type (object): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def getResultsTransformData(self, sType, rXYAngle, extraInfo1, extraInfo2) -> None:
		r"""
		Get the transformation settings that are stored with this object 
		Params:
			sType (str): 
			rXYAngle (float): only useful when type is "XY angle"
			extraInfo1 (IFLocalCoord or IFReferencePath or str): Will be set to a local coord if type is "Local coord" or to a path if type is "Path", or to a string if type is "Attribute type", otherwise not used
			extraInfo2 (int): Will be set to the shell plane  if type is "Local coord" or to a boolean skewed/not skewed if type is "Path", otherwise not used
		Returns:
			None: 
		"""
		pass


class IFDirectMethodInfluence(IFAttribute):
	"""
	Direct Method Influence Line 
	"""

	def setInfluence(self, entityName, componentName) -> None:
		r"""
		Set the results entity and the component 
		Params:
			entityName (str): results entity name
			componentName (str): results component name
		Returns:
			None: 
		"""
		pass


	def setResultsTransformNone(self) -> None:
		r"""
		Switches off all results transformation for this attribute. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformElement(self) -> None:
		r"""
		Uses element local axes as the results transformation for this attribute. (For continuous results, such as displacement, nodal axes (transformed freedoms) are used) 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformXYAngle(self, XYAngle) -> None:
		r"""
		Uses the specified angle (in the XY plane - i.e. about Z) as the results transformation for this sub-chapter. 
		Params:
			XYAngle (float): 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformLocal(self, localCoords, shellPlane) -> None:
		r"""
		Uses the specified local coordinate as the results transformation for this attribute. 
		Params:
			localCoords (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
			shellPlane (int): Shell plane for resultants (1, 2 or 3)
		Returns:
			None: 
		"""
		pass


	def setResultsTransformPath(self, path, skew=None) -> None:
		r"""
		Uses the specified path as the results transformation for this attribute. 
		Params:
			path (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
			skew (bool, optional): True if local y = transverse
		Returns:
			None: 
		"""
		pass


	def setResultsTransformFeature(self) -> None:
		r"""
		Uses the parent feature's local directions as the results transformation for this attribute. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformGlobal(self) -> None:
		r"""
		Uses the global axes directions as the results transformation for this attribute. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformAttributeType(self, type) -> None:
		r"""
		Uses the given attribute type to obtain the results transformation for this attribute. 
		Params:
			type (object): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def getResultsTransformData(self, sType, rXYAngle, extraInfo1, extraInfo2) -> None:
		r"""
		Get the transformation settings that are stored with this object 
		Params:
			sType (str): 
			rXYAngle (float): only useful when type is "XY angle"
			extraInfo1 (IFLocalCoord or IFReferencePath or str): Will be set to a local coord if type is "Local coord" or to a path if type is "Path", or to a string if type is "Attribute type", otherwise not used
			extraInfo2 (int): Will be set to the shell plane  if type is "Local coord" or to a boolean skewed/not skewed if type is "Path", otherwise not used
		Returns:
			None: 
		"""
		pass


	def isDerivedComponent(self) -> bool:
		r"""
		returns true if the result component used in the influence attribute is a derived component 
		Returns:
			bool: 
		"""
		pass


	def assignToBeamShellSlice(self, sliceName, dmiAnalysisName) -> None:
		r"""
		Assigns this attribute to beam shell slice specified 
		Params:
			sliceName (str): name of the slice
			dmiAnalysisName (str): DMI analysis name where the influence att is assigned in
		Returns:
			None: 
		"""
		pass


	def deassignFromBeamShellSlice(self, sliceName, dmiAnalysisName) -> None:
		r"""
		Deassigns this attribute from the beam shell slice specified 
		Params:
			sliceName (str): name of the slice
			dmiAnalysisName (str): DMI analysis name where the slice to deassign from
		Returns:
			None: 
		"""
		pass


	def assignToBeamShellSliceAtPos(self, sliceName, position, dmiAnalysisName) -> None:
		r"""
		Assigns this attribute to given beam shell slice at the slice position specified 
		Params:
			sliceName (str): name of the slice
			position (int): slice position (index)
			dmiAnalysisName (str): DMI analysis name where the influence att is assigned in
		Returns:
			None: 
		"""
		pass


	def deassignFromBeamShellSliceAtPos(self, sliceName, position, dmiAnalysisName) -> None:
		r"""
		Deassigns this attribute from beam shell slice at the slice position specified 
		Params:
			sliceName (str): name of the slice
			position (int): slice position (index)
			dmiAnalysisName (str): DMI analysis name where the influence attr will be deassign from
		Returns:
			None: 
		"""
		pass


	def assignToInspLocation(self, inspLocName, dmiAnalysisName) -> None:
		r"""
		Assigns this attribute to inspection location attribute specified 
		Params:
			inspLocName (str): name of the inspection location attribute
			dmiAnalysisName (str): DMI analysis name where the influence attr is assigned in
		Returns:
			None: 
		"""
		pass


	def deassignFromInspLocation(self, inspLocName, dmiAnalysisName) -> None:
		r"""
		Deassigns this attribute from the inspection location attribute specified 
		Params:
			inspLocName (str): name of the inspection location attribute
			dmiAnalysisName (str): DMI analysis name where the influence attr will be deassign from
		Returns:
			None: 
		"""
		pass


	def addCoincidentCmp(self, cmpName) -> None:
		r"""
		Add a coincident results component 
		Params:
			cmpName (str): name of the component
		Returns:
			None: 
		"""
		pass


	def resetCoincidentCmp(self) -> None:
		r"""
		Remove existing coincident components 
		Returns:
			None: 
		"""
		pass


	def isInternal(self) -> bool:
		r"""
		returns true if this is an internal attribute created by a DMIE (Direct Method Influence Attribute) when running TLO 
		Returns:
			bool: 
		"""
		pass


class IFTendonProperties(IFAttribute):
	"""
	 
	"""

	def setDesignCode(self, designCode, timeEffects=None) -> None:
		r"""
		Set the design code for this properties object Design codes currently supported for "time inputs" are:, "AASHTO LRFD 5th -> 7th Editions", "AASHTO LRFD 8th -> 9th Editions", "EN1992-1-1:2004 / 2014 Eurocode 2", "IRC:112-2011", "CEB-FIP Model Code 1990", "JTG 3362-2018", and "fib Model Code 2010" Design codes currently supported for "input stresses" are: "AASHTO LRFD 2nd Edition", "AASHTO LRFD 5th -> 7th Editions", "AASHTO LRFD 8th -> 9th Editions", "EN1992-1-1:1992 Eurocode 2", "EN1992-1-1:2004 / 2014 Eurocode 2", "BS5400-4:1990", "JTG D62-2004"  
		Params:
			designCode (str): 
			timeEffects (bool, optional): True: Losses based on time inputs and calculated stresses. False: Approximate losses, requiring input of estimated stresses
		Returns:
			None: 
		"""
		pass


	def getDesignCode(self) -> str:
		r"""
		Retrieve the design code previously set using IFTendonProperties.setDesignCode 
		Returns:
			str: 
		"""
		pass


	def isTimeEffects(self) -> bool:
		r"""
		Retrieve the "time inputs" / "input stresses" flag previously set using IFTendonProperties.setDesignCode 
		Returns:
			bool: 
		"""
		pass


class IFTendonProfile(IFAttribute):
	"""
	 
	"""

	def addCoords(self, X, Y=None, Z=None) -> IFTendonProfile:
		r"""
		Adds tendon coordinates 
		Params:
			X (object): Two dimensional array of doubles. The first dimension is the number coordinates to be added, the second dimension must be 3 (X,Y,Z).
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			IFTendonProfile: 
		"""
		pass


	def getCoords(self) -> list:
		r"""
		Return an array of tendon coordinates 
		Returns:
			array of arrays of float: vector of coordinates ((x1, y1, z1), ... (xn, yn, zn)) Each coordinate is an array of three numbers
		"""
		pass


	def getDefn(self) -> IFPolylineDefn:
		r"""
		Return the definition of this polyline 
		Returns:
			IFPolylineDefn: 
		"""
		pass


	def setLocal(self, isLocal) -> None:
		r"""
		Define that this profile is given in local coords (otherwise it is assumed to be in global coords) 
		Params:
			isLocal (bool): true for local, false for global
		Returns:
			None: 
		"""
		pass


	def isLocal(self) -> bool:
		r"""
		Return whether or not this profile is given in local coords (otherwise it is assumed to be in global coords) 
		Returns:
			bool: true for local, false for global
		"""
		pass


class IFScriptedAttribute(IFAttribute):
	"""
	An attribute with no initial behaviour. LUSAS will not visualise or tabulate this attribute, but it may be created, edited and assigned just like any other attribute. It is the users responsibility to attach any meaning, calculation, behaviour etc 
	"""

	pass


class IFFailureComposite(IFAttribute):
	"""
	 
	"""

	def setFailure(self, uxt, uyt, uxc, uyc, usc, icowwu, fxy, inter) -> IFFailureComposite:
		r"""
		
		Params:
			uxt (float): Tensile Strength parallel to the fibre
			uyt (float): Tensile Strength normal to the fibre
			uxc (float): Compressive Strength parallel to the fibre
			uyc (float): Compressive Strength normal to the fibre
			usc (float): Shear Strength
			icowwu (str): Biaxial Term For Tsai-Wu - must be "Input By User" or "Cowin's Formula"
			fxy (float): Biaxial Interaction Term (for Tsai-Wu)
			inter (int): Interaction Type
		Returns:
			IFFailureComposite: 
		"""
		pass


class IFVLOVehicleLibrary(IFAttribute):
	"""
	Interface for a VLO Vehicle library; contains traffic loads that can be used for a particular VLO design code 
	"""

	def init(self) -> IFVLOVehicleLibrary:
		r"""
		Removes all string data representing the headers and footer for the xml file, and also all the traffic loads from this library 
		Returns:
			IFVLOVehicleLibrary: 
		"""
		pass


	def addXMLCommand(self, xmlLine) -> IFVLOVehicleLibrary:
		r"""
		Used to transfer the contents of the vehicles.xml file into this object 
		Params:
			xmlLine (str): xml command, which is a line in the xml file;
		Returns:
			IFVLOVehicleLibrary: 
		"""
		pass


	def writeXMLFile(self) -> IFVLOVehicleLibrary:
		r"""
		Write the xml file for this library 
		Returns:
			IFVLOVehicleLibrary: 
		"""
		pass


	def setLibID(self, libID) -> IFVLOVehicleLibrary:
		r"""
		Set the library ID 
		Params:
			libID (int): VLO vehicle library ID
		Returns:
			IFVLOVehicleLibrary: 
		"""
		pass


	def deleteVLOVehicle(self, vehicleName) -> IFVLOVehicleLibrary:
		r"""
		Delete the VLO vehicle (traffic load) with the given name 
		Params:
			vehicleName (str): VLO vehicle name to be deleted from this library
		Returns:
			IFVLOVehicleLibrary: 
		"""
		pass


	def addVLOVehicle(self, vehicleName) -> IFVLOVehicle:
		r"""
		Add a VLO vehicle (traffic load) with the given name 
		Params:
			vehicleName (str): VLO vehicle name to be added to this library
		Returns:
			IFVLOVehicle: 
		"""
		pass


class IFVLOVehicle(IFAttribute):
	"""
	Interface for a VLO traffic load that can be used for a particular VLO design code 
	"""

	def init(self) -> IFVLOVehicle:
		r"""
		Remove the the xml strings that define this vehicle (traffic load) 
		Returns:
			IFVLOVehicle: 
		"""
		pass


	def addXMLCommand(self, xmlCmd) -> IFVLOVehicle:
		r"""
		Add an xml string that defines this vehicle (traffic load) 
		Params:
			xmlCmd (str): xml command
		Returns:
			IFVLOVehicle: 
		"""
		pass


class IFDesignFactor(IFAttribute):
	"""
	 
	"""

	def setDesignFactor(self, asxt, asyt, aszt, asxyt, asyzt, asxzt, as1t, as2t, as3t, aset, asxc, asyc, aszc, asxyc, asyzc, asxzc, as1c, as2c, as3c, asec, df, pratio) -> IFDesignFactor:
		r"""
		
		Params:
			asxt (float): Acceptable Tensile sigmaX
			asyt (float): Acceptable Tensile sigmaY
			aszt (float): Acceptable Tensile sigmaZ
			asxyt (float): Acceptable Tensile sigmaXY
			asyzt (float): Acceptable Tensile sigmaYZ
			asxzt (float): Acceptable Tensile sigmaXZ
			as1t (float): Acceptable Tensile sigma1
			as2t (float): Acceptable Tensile sigma2
			as3t (float): Acceptable Tensile sigma3
			aset (float): Acceptable Tensile sigmaE
			asxc (float): Acceptable Compressive sigmaX
			asyc (float): Acceptable Compressive sigmaY
			aszc (float): Acceptable Compressive sigmaZ
			asxyc (float): Acceptable Compressive sigmaXY
			asyzc (float): Acceptable Compressive sigmaYZ
			asxzc (float): Acceptable Compressive sigmaXZ
			as1c (float): Acceptable Compressive sigma1
			as2c (float): Acceptable Compressive sigma2
			as3c (float): Acceptable Compressive sigma3
			asec (float): Acceptable Compressive sigmaE
			df (float): Design Factor
			pratio (float): Poisson's Ratio
		Returns:
			IFDesignFactor: 
		"""
		pass


class IFDesignAttribute(IFAttribute):
	"""
	 
	"""

	def setSubType(self, typeName, scopeName) -> IFDesignAttribute:
		r"""
		Set the user defined SubType for this design attribute. 
		Params:
			typeName (str): Full SubType name as it appears in the tree
			scopeName (str): SubType name used as User Defined Results scope
		Returns:
			IFDesignAttribute: 
		"""
		pass


	def setAssignType(self, assignType) -> IFDesignAttribute:
		r"""
		Set the allowable assign types for this design attribute. 
		Params:
			assignType (str): "Points", "Lines", "Surfaces", "Volumes"
		Returns:
			IFDesignAttribute: 
		"""
		pass


class IFShearTorsionAdvPropsDefinition(IFAttribute):
	"""
	Advanced shear and torsion properties definition utility. 
	"""

	pass


class IFMBWDefinition(IFAttribute):
	"""
	MBW Tank definition utility. 
	"""

	pass


class IFTankDefinition(IFAttribute):
	"""
	LNG Tank definition utility. 
	"""

	pass


class IFKogasTankDefinition(IFAttribute):
	"""
	Kogas Tank definition utility. 
	"""

	pass


class IFTankReinforcementDefinition(IFAttribute):
	"""
	LNG Tank reinforcement definition utility. 
	"""

	pass


class IFBridgeWizardDefinition(IFAttribute):
	"""
	Base class for Bridge Wizard definition utilities 
	"""

	pass


class IFBridgeWizardBridgeDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Bridge definition utility. 
	"""

	pass


class IFBridgeWizardSupportDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Support definition utility. 
	"""

	pass


class IFBridgeWizardStiffenerDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Stiffener definition utility. 
	"""

	pass


class IFBridgeWizardSpanDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Span definition utility 
	"""

	pass


class IFBridgeWizardSectionDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Composite Plate Girer definition utility 
	"""

	pass


class IFBridgeWizardTubSectionDefinition(IFBridgeWizardDefinition):
	"""
	Not implemented 
	"""

	pass


class IFBridgeWizardGirderDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Girder definition utility 
	"""

	pass


class IFBridgeWizardBracingDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Bracing Assembly definition utility 
	"""

	pass


class IFBridgeWizardBracingRunDefinition(IFBridgeWizardDefinition):
	"""
	Bridge Wizard Bracing Run definition utility 
	"""

	pass


class IFBridgeDesignDefinition(IFAttribute):
	"""
	Base class for all bridge design utility classes 
	"""

	pass


class IFBridgeDesignGirderMaterial(IFBridgeDesignDefinition):
	"""
	Composite bridge material definition used for design 
	"""

	pass


class IFBridgeDesignTransverseStiffener(IFBridgeDesignDefinition):
	"""
	Transverse stiffener definition used in design 
	"""

	pass


class IFBridgeDesignLongitudinalStiffener(IFBridgeDesignDefinition):
	"""
	Longitudinal stiffener definition used in design 
	"""

	pass


class IFRailTrackAnalysisUtilities(IFAttribute):
	"""
	Base class for all Rail Track Analysis (RTA) utilities 
	"""

	pass


class IFRailTrackAnalysisZlrRlrProperties(IFRailTrackAnalysisUtilities):
	"""
	Definition of ZLR/RLR Properties for use in RailTrack Analyses 
	"""

	def setProperties(self, resistanceType, hasSameLoadedAsUnloaded, elasticStiffUnLoaded, yieldForceUnLoaded, hardeningStiffnessUnLoaded, elasticStiffLoaded, yieldForceLoaded, hardeningStiffnessLoaded) -> IFRailTrackAnalysisZlrRlrProperties:
		r"""
		Set the properties 
		Params:
			resistanceType (int): 0 = ZLR or 1 = RLR
			hasSameLoadedAsUnloaded (bool): Indicates if the loaded properties are the same as the unloaded
			elasticStiffUnLoaded (float): Elastic stiffness of the unloaded joint
			yieldForceUnLoaded (float): Yield force of the unloaded joint
			hardeningStiffnessUnLoaded (float): Hardening stiffness of the unloaded joint
			elasticStiffLoaded (float): Elastic stiffness of the loaded joint
			yieldForceLoaded (float): Yield force of the loaded joint
			hardeningStiffnessLoaded (float): Hardening stiffness of the loaded joint
		Returns:
			IFRailTrackAnalysisZlrRlrProperties: 
		"""
		pass


	def getProperties(self, resistanceType, hasSameLoadedAndUnloaded, elasticStiffUnLoaded, yieldForceUnLoaded, hardeningStiffnessUnLoaded, elasticStiffLoaded, yieldForceLoaded, hardeningStiffnessLoaded) -> IFRailTrackAnalysisZlrRlrProperties:
		r"""
		Gets the properties. 
		Params:
			resistanceType (int): 0 = ZLR or 1 = RLR
			hasSameLoadedAndUnloaded (bool): Indicates if the loaded properties are the same as the unloaded
			elasticStiffUnLoaded (float): Elastic stiffness of the unloaded joint
			yieldForceUnLoaded (float): Yield force of the unloaded joint
			hardeningStiffnessUnLoaded (float): Hardening stiffness of the unloaded joint
			elasticStiffLoaded (float): Elastic stiffness of the loaded joint
			yieldForceLoaded (float): Yield force of the loaded joint
			hardeningStiffnessLoaded (float): Hardening stiffness of the loaded joint
		Returns:
			IFRailTrackAnalysisZlrRlrProperties: 
		"""
		pass


class IFRailTrackAnalysisZlrRlrRegions(IFRailTrackAnalysisUtilities):
	"""
	Definition of ZLR/RLR Regions for use in RailTrack Analyses 
	"""

	def addRegion(self, trackID, startPos, endPos, props) -> IFRailTrackAnalysisZlrRlrRegions:
		r"""
		adds a region to the global definition 
		Params:
			trackID (int): Track ID to which ZLR/RLR region applies
			startPos (float): Start position of the ZLR/RLR region from the structure start
			endPos (float): End position of the ZLR/RLR region from the structure start
			props (IFRailTrackAnalysisZlrRlrProperties): Properties of the ZLR/RLR region.
		Returns:
			IFRailTrackAnalysisZlrRlrRegions: 
		"""
		pass


	def getRegion(self, index, trackID, startPos, endPos, props) -> IFRailTrackAnalysisZlrRlrRegions:
		r"""
		gets the region definition at the current index. Use countRegions to ensure you access on the available indices 
		Params:
			index (int): Zero based index of the region
			trackID (int): Track ID to which ZLR/RLR region applies
			startPos (float): Start position of the ZLR/RLR region from the structure start
			endPos (float): End position of the ZLR/RLR region from the structure start
			props (IFRailTrackAnalysisZlrRlrProperties): Properties of the ZLR/RLR region.
		Returns:
			IFRailTrackAnalysisZlrRlrRegions: Reference to this object
		"""
		pass


	def countRegions(self) -> int:
		r"""
		Gets the number of regions in the current attribute 
		Returns:
			int: Number of regions defined in this attribute
		"""
		pass


class IFPushoverCurve(IFAttribute):
	"""
	 
	"""

	pass


class IFBuildingLoading(IFAttribute):
	"""
	 
	"""

	def assignToModel(self, data) -> IFBuildingLoading:
		r"""
		assigns this attribute to the model as a whole 
		Params:
			data (IFAssignment): 
		Returns:
			IFBuildingLoading: 
		"""
		pass


	def deassignFromModel(self, data) -> IFBuildingLoading:
		r"""
		de-assigns this attribute from the model 
		Params:
			data (IFAssignment): 
		Returns:
			IFBuildingLoading: 
		"""
		pass


class IFBeamStressRecovery(IFAttribute):
	"""
	 
	"""

	def setBeamStressRecovery(self, area, z1, z2, _yield) -> IFBeamStressRecovery:
		r"""
		
		Params:
			area (float): Cross Section Area
			z1 (float): Section Modulus Zxy
			z2 (float): Section Modulus Zxz
			_yield (float): Yield Stress
		Returns:
			IFBeamStressRecovery: 
		"""
		pass


class IFNonlinearUserThermal(IFMaterial):
	"""
	 
	"""

	def addRow(self, pProps, pTemp=None) -> IFNonlinearUserThermal:
		r"""
		 
		Params:
			pProps (IFVariationAttr or float): 
			pTemp (float, optional): optional temperature
		Returns:
			IFNonlinearUserThermal: 
		"""
		pass


class IFCamClayMaterialSet(IFMaterialTropicSet):
	"""
	
	"""

	def addCamClay(self, pInitialVoidRatio, pSwellingIndex, pCompressionIndex, pGradientCriticalStateLine, pPreConsolidationPressure, pPoissonsRatio, pCoeffThermalExpansion, pMassDensity, pMassRayleighDampingConst, pStiffRayleighDampingConst, temp) -> IFCamClayMaterialSet:
		r"""
		
		Params:
			pInitialVoidRatio (IFVariationAttr or float): 
			pSwellingIndex (IFVariationAttr or float): 
			pCompressionIndex (IFVariationAttr or float): 
			pGradientCriticalStateLine (IFVariationAttr or float): 
			pPreConsolidationPressure (IFVariationAttr or float): 
			pPoissonsRatio (IFVariationAttr or float): 
			pCoeffThermalExpansion (IFVariationAttr or float): 
			pMassDensity (IFVariationAttr or float): 
			pMassRayleighDampingConst (IFVariationAttr or float): 
			pStiffRayleighDampingConst (IFVariationAttr or float): 
			temp (float): reference temperature
		Returns:
			IFCamClayMaterialSet: 
		"""
		pass


class IFSoilStructureMaterialSet(IFMaterialTropicSet):
	"""
	
	"""

	def setSoilInterfacePropertiesType(self, type) -> IFSoilStructureMaterialSet:
		r"""
		set the properties type this function hidden as currently we are only allowing "displacement" type 
		Params:
			type (str): "Factor","Increment Update","Iteration Update"
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def addSoilNrmInterfaceRow(self, pNormalStiffFactor, pTangentStiffFactor, pConstCohesion, pConstAngleFriction, pConstDilatancy, pVirtualThick, pTensionLimit, temp) -> IFSoilStructureMaterialSet:
		r"""
		add properties to a normal type soil structure interface material 
		Params:
			pNormalStiffFactor (IFVariationAttr or float): normal stiffness
			pTangentStiffFactor (IFVariationAttr or float): tangential stiffness
			pConstCohesion (IFVariationAttr or float): cohesion if constant not a graph
			pConstAngleFriction (IFVariationAttr or float): angle of friction if constant not a graph
			pConstDilatancy (IFVariationAttr or float): dilatancy if constant not a graph
			pVirtualThick (IFVariationAttr or float): virtual thickness if strain type graphs
			pTensionLimit (IFVariationAttr or float): cut off tension limit
			temp (float): reference temperature
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def addSoilDispInterfaceRow(self, pNormalStiffFactor, pNormalPressure, pConstCohesion, pConstDilatancy, pVirtualThick, pTensionLimit, temp) -> IFSoilStructureMaterialSet:
		r"""
		add properties to a displacement type soil structure interface material 
		Params:
			pNormalStiffFactor (IFVariationAttr or float): normal stiffness
			pNormalPressure (IFVariationAttr or float): normal compressive pressure
			pConstCohesion (IFVariationAttr or float): cohesion if constant not a graph
			pConstDilatancy (IFVariationAttr or float): dilatancy if constant not a graph
			pVirtualThick (IFVariationAttr or float): virtual thickness if strain type graphs
			pTensionLimit (IFVariationAttr or float): cut off tension limit
			temp (float): reference temperature
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def removeSoilCohesionPoints(self, rowIndex) -> IFSoilStructureMaterialSet:
		r"""
		empty the cohesion graph 
		Params:
			rowIndex (int): row index of the parent material
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def removeSoilFrictionPoints(self, rowIndex) -> IFSoilStructureMaterialSet:
		r"""
		empty the angle of friction graph 
		Params:
			rowIndex (int): row index of the parent material
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def removeSoilDilatancyPoints(self, rowIndex) -> IFSoilStructureMaterialSet:
		r"""
		empty the dilatancy graph 
		Params:
			rowIndex (int): row index of the parent material
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def removeSoilShearStressPoints(self, rowIndex) -> IFSoilStructureMaterialSet:
		r"""
		empty the shear stress graph 
		Params:
			rowIndex (int): row index of the parent material
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def addSoilCohesionPoint(self, rowIndex, xVal, cohesion) -> IFSoilStructureMaterialSet:
		r"""
		add a pair of values to the cohesion graph 
		Params:
			rowIndex (int): row index of the parent material
			xVal (float): displacement or strain value
			cohesion (float): cohesion value
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def addSoilFrictionPoint(self, rowIndex, xVal, angleOfFriction) -> IFSoilStructureMaterialSet:
		r"""
		add a pair of values to the angle of friction graph 
		Params:
			rowIndex (int): row index of the parent material
			xVal (float): displacement or strain value
			angleOfFriction (float): angle of friction value
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def addSoilDilatancyPoint(self, rowIndex, xVal, dilatancy) -> IFSoilStructureMaterialSet:
		r"""
		add a pair of values to the dilatancy graph 
		Params:
			rowIndex (int): row index of the parent material
			xVal (float): displacement or strain value
			dilatancy (float): dilatancy value
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


	def addSoilShearStressPoint(self, rowIndex, xVal, shearStress) -> IFSoilStructureMaterialSet:
		r"""
		add a pair of values to the hear stress graph 
		Params:
			rowIndex (int): row index of the parent material
			xVal (float): displacement or strain value
			shearStress (float): hear stress value
		Returns:
			IFSoilStructureMaterialSet: 
		"""
		pass


class IFPiecewiseLinearBarMaterial(IFMaterial):
	"""
	
	"""

	def setType(self, type) -> IFPiecewiseLinearBarMaterial:
		r"""
		define the material type, tension, compression or piecewise 
		Params:
			type (str): string, tension, compression or piecewise
		Returns:
			IFPiecewiseLinearBarMaterial: 
		"""
		pass


	def addRow(self, minYoungsMod, curveTolerance, density, thermalExpansion, massRayleigh, stiffRayleigh, temperature=None) -> IFPiecewiseLinearBarMaterial:
		r"""
		add a row of data to this material 
		Params:
			minYoungsMod (float): minimum value of Young's modulus
			curveTolerance (float): curve tolerance parameter
			density (IFVariationAttr or float): density
			thermalExpansion (object): coefficient of thermal expansion
			massRayleigh (object): Mass Rayleigh damping constant
			stiffRayleigh (object): Stiffness Rayleigh damping constant
			temperature (float, optional): temperature, default 0.0
		Returns:
			IFPiecewiseLinearBarMaterial: 
		"""
		pass


	def addCurveData(self, rowIndex, strain, stress) -> IFPiecewiseLinearBarMaterial:
		r"""
		add a point on the strain/stress curve 
		Params:
			rowIndex (int): 
			strain (float): 
			stress (float): 
		Returns:
			IFPiecewiseLinearBarMaterial: 
		"""
		pass


class IFThermalLinkMaterial(IFMaterial):
	"""
	
	"""

	def addLinearRow(self, gapConductance, convectiveCoeff, radiativeCoeff, gapConductanceDeriv, convectiveCoeffDeriv, radiativeCoeffDeriv, temperature=None) -> IFThermalLinkMaterial:
		r"""
		add a row of data to this linear thermal link material 
		Params:
			gapConductance (IFVariationAttr or float): gap conductance at origin
			convectiveCoeff (IFVariationAttr or float): convective heat transfer at origin
			radiativeCoeff (IFVariationAttr or float): radiative heat transfer at origin
			gapConductanceDeriv (IFVariationAttr or float): variation of gap conductance with opening distance
			convectiveCoeffDeriv (IFVariationAttr or float): variation of convective heat transfe with opening distance
			radiativeCoeffDeriv (IFVariationAttr or float): variation of radiative heat transfe with opening distance
			temperature (float, optional): temperature, default 0.0
		Returns:
			IFThermalLinkMaterial: 
		"""
		pass


	def addNonlinearRow(self, gapConductance, convectiveCoeff, radiativeCoeff, distance, temperature=None) -> IFThermalLinkMaterial:
		r"""
		add a row of data to this nonlinear thermal link material 
		Params:
			gapConductance (IFVariationAttr or float): gap conductance for point on graph
			convectiveCoeff (IFVariationAttr or float): convective heat transfer for point on graph
			radiativeCoeff (IFVariationAttr or float): radiative heat transfer for point on graph
			distance (float): total distance for point on graph
			temperature (float, optional): temperature, default 0.0
		Returns:
			IFThermalLinkMaterial: 
		"""
		pass


class IFDuncanChangMaterialSet(IFMaterialTropicSet):
	"""
	
	"""

	def setDuncanChangPressure(self, usePressure) -> IFDuncanChangMaterialSet:
		r"""
		set the pressute option for this Duncan-Chang soil material 
		Params:
			usePressure (bool): true to use pressure option, false not to
		Returns:
			IFDuncanChangMaterialSet: 
		"""
		pass


	def addDuncanChangConstant(self, cohesion, angleFriction, changeOfAngleFriction, failureRatio, density, coeffThermalExpansion, atmosphericPressure, initYoungsModNumber, YoungsModulusNumber, initYoungsModExponent, PoissonsRatio, YoungsModulusAtFail, PoissonsRatioAtFail, RayleighMassDamping, RayleighStiffnessDamping, temperature=None, minStressSoilStiff=None, accuracyControl=None, maxStressInTension=None) -> IFDuncanChangMaterialSet:
		r"""
		add constant Poisson's ratio data to this Duncan-Chang soil material 
		Params:
			cohesion (IFVariationAttr or float): cohesion
			angleFriction (IFVariationAttr or float): angle of friction
			changeOfAngleFriction (IFVariationAttr or float): change of angle of friction with pressure
			failureRatio (IFVariationAttr or float): failure ratio
			density (IFVariationAttr or float): density
			coeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			atmosphericPressure (IFVariationAttr or float): atmospheric pressure
			initYoungsModNumber (IFVariationAttr or float): initial Young's modulus number
			YoungsModulusNumber (IFVariationAttr or float): Young's modulus number for loading/unloading
			initYoungsModExponent (IFVariationAttr or float): initial Young's modulus exponent
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio
			YoungsModulusAtFail (IFVariationAttr or float): Young's modulus when soil fails in shear
			PoissonsRatioAtFail (IFVariationAttr or float): Poisson's ratio when soil fails
			RayleighMassDamping (IFVariationAttr or float): Raleigh mass damping constant
			RayleighStiffnessDamping (IFVariationAttr or float): Raleigh stiffness damping constant
			temperature (float, optional): temperature, default 0.0
			minStressSoilStiff (IFVariationAttr or float, optional): minimum stress used to calculate soild stiffness
			accuracyControl (IFVariationAttr or float, optional): accuracy control
			maxStressInTension (IFVariationAttr or float, optional): maximum stress in tension
		Returns:
			IFDuncanChangMaterialSet: 
		"""
		pass


	def addDuncanChangDirect(self, cohesion, angleFriction, changeOfAngleFriction, failureRatio, density, coeffThermalExpansion, atmosphericPressure, initYoungsModNumber, YoungsModulusNumber, initYoungsModExponent, PoissonsRatioTangent, cellPressureFactor, PoissonsRatioAtAtmos, YoungsModulusAtFail, PoissonsRatioAtFail, RayleighMassDamping, RayleighStiffnessDamping, temperature=None, minStressSoilStiff=None, accuracyControl=None, maxStressInTension=None) -> IFDuncanChangMaterialSet:
		r"""
		add direct variation Poisson's ratio data to this Duncan-Chang soil material 
		Params:
			cohesion (IFVariationAttr or float): cohesion
			angleFriction (IFVariationAttr or float): angle of friction
			changeOfAngleFriction (IFVariationAttr or float): change of angle of friction with pressure
			failureRatio (IFVariationAttr or float): failure ratio
			density (IFVariationAttr or float): density
			coeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			atmosphericPressure (IFVariationAttr or float): atmospheric pressure
			initYoungsModNumber (IFVariationAttr or float): initial Young's modulus number
			YoungsModulusNumber (IFVariationAttr or float): Young's modulus number for loading/unloading
			initYoungsModExponent (IFVariationAttr or float): initial Young's modulus exponent
			PoissonsRatioTangent (IFVariationAttr or float): parameter used in calculation of Poisson's ratio tangent
			cellPressureFactor (IFVariationAttr or float): factor applied to cell pressure moderation component
			PoissonsRatioAtAtmos (IFVariationAttr or float): Poisson's ratio at atmospheric cell pressure
			YoungsModulusAtFail (IFVariationAttr or float): Young's modulus when soil fails in shear
			PoissonsRatioAtFail (IFVariationAttr or float): Poisson's ratio when soil fails
			RayleighMassDamping (IFVariationAttr or float): Raleigh mass damping constant
			RayleighStiffnessDamping (IFVariationAttr or float): Raleigh stiffness damping constant
			temperature (float, optional): temperature, default 0.0
			minStressSoilStiff (IFVariationAttr or float, optional): minimum stress used to calculate soild stiffness
			accuracyControl (IFVariationAttr or float, optional): accuracy control
			maxStressInTension (IFVariationAttr or float, optional): maximum stress in tension
		Returns:
			IFDuncanChangMaterialSet: 
		"""
		pass


	def addDuncanChangIndirect(self, cohesion, angleFriction, changeOfAngleFriction, failureRatio, density, coeffThermalExpansion, atmosphericPressure, initYoungsModNumber, YoungsModulusNumber, initYoungsModExponent, bulkModulusNumber, bulkModulusExponent, YoungsModulusAtFail, PoissonsRatioAtFail, RayleighMassDamping, RayleighStiffnessDamping, temperature=None, minStressSoilStiff=None, accuracyControl=None, maxStressInTension=None) -> IFDuncanChangMaterialSet:
		r"""
		add indirect variation from bulk modulus Poisson's ratio data to this Duncan-Chang soil material 
		Params:
			cohesion (IFVariationAttr or float): cohesion
			angleFriction (IFVariationAttr or float): angle of friction
			changeOfAngleFriction (IFVariationAttr or float): change of angle of friction with pressure
			failureRatio (IFVariationAttr or float): failure ratio
			density (IFVariationAttr or float): density
			coeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			atmosphericPressure (IFVariationAttr or float): atmospheric pressure
			initYoungsModNumber (IFVariationAttr or float): initial Young's modulus number
			YoungsModulusNumber (IFVariationAttr or float): Young's modulus number for loading/unloading
			initYoungsModExponent (IFVariationAttr or float): initial Young's modulus exponent
			bulkModulusNumber (IFVariationAttr or float): bulk modulus number
			bulkModulusExponent (IFVariationAttr or float): bulk modulus exponent
			YoungsModulusAtFail (IFVariationAttr or float): Young's modulus when soil fails in shear
			PoissonsRatioAtFail (IFVariationAttr or float): Poisson's ratio when soil fails
			RayleighMassDamping (IFVariationAttr or float): Raleigh mass damping constant
			RayleighStiffnessDamping (IFVariationAttr or float): Raleigh stiffness damping constant
			temperature (float, optional): temperature, default 0.0
			minStressSoilStiff (IFVariationAttr or float, optional): minimum stress used to calculate soild stiffness
			accuracyControl (IFVariationAttr or float, optional): accuracy control
			maxStressInTension (IFVariationAttr or float, optional): maximum stress in tension
		Returns:
			IFDuncanChangMaterialSet: 
		"""
		pass


class IFElastoPlasticInterfaceSet(IFMaterialTropicSet):
	"""
	
	"""

	def addElastoPlasticInterface2d(self, YoungsModulusInPlane, YoungsModulusOutPlane, ShearModulus, PoissonsRatio, MassDensity, CoeffThermalExpansion, MassRaleighDampingConst, StiffRaleighDampingConst, HeatFractionCoeff, Cohesion, FrictionAngle, UniaxialYieldStress, temperature) -> IFElastoPlasticInterfaceSet:
		r"""
		add 2D elasto plastic interface to the material set 
		Params:
			YoungsModulusInPlane (IFVariationAttr or float): Inplane Young's Modulus
			YoungsModulusOutPlane (IFVariationAttr or float): Out of plane Young's Modulus
			ShearModulus (IFVariationAttr or float): 
			PoissonsRatio (IFVariationAttr or float): Poisson's ratio
			MassDensity (IFVariationAttr or float): density
			CoeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			MassRaleighDampingConst (IFVariationAttr or float): Mass Rayleigh damping constant
			StiffRaleighDampingConst (IFVariationAttr or float): Stiffness Rayleigh damping constant
			HeatFractionCoeff (IFVariationAttr or float): Heat fraction coefficient
			Cohesion (IFVariationAttr or float): Cohesion
			FrictionAngle (IFVariationAttr or float): Friction angle
			UniaxialYieldStress (IFVariationAttr or float): Uniaxial yield stress
			temperature (float): temperature
		Returns:
			IFElastoPlasticInterfaceSet: 
		"""
		pass


	def addElastoPlasticInterface3d(self, YoungsModulusInPlane, YoungsModulusOutPlane, ShearModulusInPlane, ShearModulusOutPlane, PoissonsRatioInPlane, PoissonsRatioOutPlane, MassDensity, CoeffThermalExpansion, MassRaleighDampingConst, StiffRaleighDampingConst, HeatFractionCoeff, Cohesion, FrictionAngle, UniaxialYieldStress, temperature) -> IFElastoPlasticInterfaceSet:
		r"""
		add 3D elasto plastic interface to the material set 
		Params:
			YoungsModulusInPlane (IFVariationAttr or float): Inplane  Young's Modulus
			YoungsModulusOutPlane (IFVariationAttr or float): Out of plane  Young's Modulus
			ShearModulusInPlane (IFVariationAttr or float): Inplane shear modulus
			ShearModulusOutPlane (IFVariationAttr or float): Out of plane shear modulus
			PoissonsRatioInPlane (IFVariationAttr or float): Inplane Poisson's Ratio
			PoissonsRatioOutPlane (IFVariationAttr or float): Out of plane Poisson's Ratio
			MassDensity (IFVariationAttr or float): density
			CoeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			MassRaleighDampingConst (IFVariationAttr or float): Mass Rayleigh damping constant
			StiffRaleighDampingConst (IFVariationAttr or float): Stiffness Rayleigh damping constant
			HeatFractionCoeff (IFVariationAttr or float): Heat fraction coefficient
			Cohesion (IFVariationAttr or float): Cohesion
			FrictionAngle (IFVariationAttr or float): Friction angle
			UniaxialYieldStress (IFVariationAttr or float): Uniaxial yield stress
			temperature (float): temperature
		Returns:
			IFElastoPlasticInterfaceSet: 
		"""
		pass


class IFHoekBrownMaterialSet(IFMaterialTropicSet):
	"""
	The Hoek-Brown material set interface 
	"""

	def addHoekBrown(self) -> IFHoekBrownMaterialSet:
		r"""
		Add the Hoek-Brown material to the set 
		Returns:
			IFHoekBrownMaterialSet: 
		"""
		pass


	def addHoekBrownRow(self, youngModulus, youngModulusFailure, poissonsRatio, density, uniaxialCompressiveStrength, empiricalStrengthParameterMb, empiricalStrengthParameterMi, empiricalStrengthParameterS, empiricalStrengthParameterAlpha, geologicalStrengthIndex, damageCoefficient, dilatancyAngle, dilatancyTransitionStress, dilatancyTransitionRate, stressTolerance, coeffThermalExpansion, rayleighMassDamping, rayleighStiffnessDamping, maxNumberStressIter, strengthParameter, flowRule, referenceTemperature) -> IFHoekBrownMaterialSet:
		r"""
		Add the Hoek-Brown material data 
		Params:
			youngModulus (IFVariationAttr or float): 
			youngModulusFailure (IFVariationAttr or float): 
			poissonsRatio (IFVariationAttr or float): 
			density (IFVariationAttr or float): 
			uniaxialCompressiveStrength (IFVariationAttr or float): 
			empiricalStrengthParameterMb (IFVariationAttr or float): 
			empiricalStrengthParameterMi (IFVariationAttr or float): 
			empiricalStrengthParameterS (IFVariationAttr or float): 
			empiricalStrengthParameterAlpha (IFVariationAttr or float): 
			geologicalStrengthIndex (IFVariationAttr or float): 
			damageCoefficient (IFVariationAttr or float): 
			dilatancyAngle (IFVariationAttr or float): 
			dilatancyTransitionStress (IFVariationAttr or float): 
			dilatancyTransitionRate (IFVariationAttr or float): 
			stressTolerance (IFVariationAttr or float): 
			coeffThermalExpansion (IFVariationAttr or float): 
			rayleighMassDamping (IFVariationAttr or float): 
			rayleighStiffnessDamping (IFVariationAttr or float): 
			maxNumberStressIter (int): 
			strengthParameter (str): 
			flowRule (str): 
			referenceTemperature (float): 
		Returns:
			IFHoekBrownMaterialSet: 
		"""
		pass


class IFBarcelonaBasicMaterialSet(IFMaterialTropicSet):
	"""
	The Barcelona Basic material set interface 
	"""

	def addBarcelonaBasic(self, compressionIndexFullySaturated, swellingIndex, poissonsRatio, gradientCriticalStateLine, infiniteSuctionStiffControl, stiffIncreaseWithSuctionControl, referencePressure, elasticStiffSuctionChanges, atmosphericPressure, preConsolidationPressure, initialVoidRatio, coeffThermalExpansion, massDensity, massRayleighDampingConst, stiffRayleighDampingConst, referenceTemperature) -> IFBarcelonaBasicMaterialSet:
		r"""
		Add the Barcelona Basic material data 
		Params:
			compressionIndexFullySaturated (IFVariationAttr or float): compression index at fully saturated state
			swellingIndex (IFVariationAttr or float): swelling index
			poissonsRatio (IFVariationAttr or float): poisson�s ratio
			gradientCriticalStateLine (IFVariationAttr or float): gradient of critical state line
			infiniteSuctionStiffControl (IFVariationAttr or float): stiffness at infinite suction control
			stiffIncreaseWithSuctionControl (IFVariationAttr or float): increase in stiffness with suction control
			referencePressure (IFVariationAttr or float): reference pressure
			elasticStiffSuctionChanges (IFVariationAttr or float): elastic stiffness for changes in suction
			atmosphericPressure (IFVariationAttr or float): atmospheric pressure
			preConsolidationPressure (IFVariationAttr or float): pre-consolidation pressure
			initialVoidRatio (IFVariationAttr or float): initial void ratio
			coeffThermalExpansion (IFVariationAttr or float): coefficient of thermal expansion
			massDensity (IFVariationAttr or float): density
			massRayleighDampingConst (IFVariationAttr or float): mass Rayleigh damping constant
			stiffRayleighDampingConst (IFVariationAttr or float): stiffness Rayleigh damping constant
			referenceTemperature (float): reference temperature
		Returns:
			IFBarcelonaBasicMaterialSet: 
		"""
		pass


class IFCompoundMaterial(IFMaterial):
	"""
	This material is a simple list of other materials. The materials within this list may be referenced by position (a 0-based integer) When adding materials, it is possible to specify a reference name, which can subsequently be used (instead of the position index) to clarify which material is of interest 
	"""

	def addMaterial(self, material, nameReference=None) -> IFCompoundMaterial:
		r"""
		Add a material to this compound material 
		Params:
			material (IFMaterial): The name or ID of a loadset, or a pointer to a IFMaterial object. material attribute to add
			nameReference (str, optional): A simple name to reference the material within this attribute
		Returns:
			IFCompoundMaterial: 
		"""
		pass


	def setActiveMaterial(self, refIndex) -> IFCompoundMaterial:
		r"""
		Choose which material within this compound material is considered active. The choice is made by specifying the position or reference name. 
		Params:
			refIndex (str or int): index(integer) or reference name(string)
		Returns:
			IFCompoundMaterial: 
		"""
		pass


	def setActiveMaterialAttr(self, material) -> IFCompoundMaterial:
		r"""
		Choose which material within this compound material is considered active. The choice is made by specifying the material directly. 
		Params:
			material (IFMaterial): The name or ID of a loadset, or a pointer to a IFMaterial object. material attribute to make active
		Returns:
			IFCompoundMaterial: 
		"""
		pass


	def getMaterialsCount(self) -> int:
		r"""
		Return the number of materials within this attribute 
		Returns:
			int: 
		"""
		pass


	def getMaterial(self, refIndex, nameReference=None) -> IFMaterial:
		r"""
		return the material at the given position, or reference name 
		Params:
			refIndex (str or int): index(integer) or reference name(string)
			nameReference (str, optional): optionally return the material reference name
		Returns:
			IFMaterial: 
		"""
		pass


	def setMaterial(self, refIndex, material, affectsSolution=None) -> IFCompoundMaterial:
		r"""
		Set the material at a particular position within this. This method is provided to make changes to an existing compound material, therefore it is an error if the given index / reference name is not already in use. (i.e. you must call IFCompoundMaterial.addMaterial() before you can call IFCompoundMaterial.setMaterial() with the same position or reference name) 
		Params:
			refIndex (str or int): index(integer) or reference name(string)
			material (IFMaterial): The name or ID of a loadset, or a pointer to a IFMaterial object. material attribute to add
			affectsSolution (bool, optional): Default true. Usually any change to any assigned attribute causes modeller to think that one or more analyses need to be solved. This flag allows you to indicate that the material being modified does not, in fact, affect solution (e.g. a reinforcing material which is only used in design calcs)
		Returns:
			IFCompoundMaterial: 
		"""
		pass


	def setReinforcedConcrete(self) -> IFCompoundMaterial:
		r"""
		set the type to reinforced concrete 
		Returns:
			IFCompoundMaterial: 
		"""
		pass


class IFBridgeDeckMaterial(IFCompoundMaterial):
	"""
	Interface for the bridge material attribute 
	"""

	def setUsingStiffness(self, refIndex, useStiffness) -> IFBridgeDeckMaterial:
		r"""
		Sets whether the material contributes stiffness during analysis 
		Params:
			refIndex (object): index(integer) or name(string) ["Slab"/"Girder"]
			useStiffness (bool): True/False whether using stiffness during analysis
		Returns:
			IFBridgeDeckMaterial: 
		"""
		pass


	def getUsingStiffness(self, refIndex) -> bool:
		r"""
		Gets whether the material contributes stiffness during analysis 
		Params:
			refIndex (object): index(integer) or name(string) ["Slab"/"Girder"]
		Returns:
			bool: True/False whether using stiffness during analysis
		"""
		pass


	def setUsingMass(self, refIndex, useWeight) -> IFBridgeDeckMaterial:
		r"""
		Sets whether the material contributes mass during analysis 
		Params:
			refIndex (object): index(integer) or name(string) ["Slab"/"Girder"]
			useWeight (bool): True/False whether using mass during analysis
		Returns:
			IFBridgeDeckMaterial: 
		"""
		pass


	def getUsingMass(self, refIndex) -> bool:
		r"""
		Gets whether the material contributes mass during analysis 
		Params:
			refIndex (object): index(integer) or name(string) ["Slab"/"Girder"]
		Returns:
			bool: True/False whether using mass during analysis
		"""
		pass


class IFPYCurve(IFAttribute):
	"""
	 
	"""

	def getPublication(self) -> str:
		r"""
		Return publication name 
		Returns:
			str: 
		"""
		pass


	def getSoilType(self) -> str:
		r"""
		Return soil type 
		Returns:
			str: 
		"""
		pass


	def getPropertiesFirst(self) -> int:
		r"""
		Return first property index 
		Returns:
			int: 
		"""
		pass


	def getPropertiesLast(self) -> int:
		r"""
		Return last property index 
		Returns:
			int: 
		"""
		pass


	def getPropertyName(self, index) -> str:
		r"""
		Return name of property at index, or empty string is this should not be shown 
		Params:
			index (int): 
		Returns:
			str: 
		"""
		pass


	def getPropertyValue(self, index) -> str:
		r"""
		Return value string of property at index, or empty string is this should not be shown 
		Params:
			index (int): 
		Returns:
			str: 
		"""
		pass


class IFPileMaterialLayup(IFMaterial):
	"""
	Representation of the pile material layup, being (essentially) an array of IFPYCurve objects 
	"""

	def setLayupData(self, manyCycles, pluggedBase, waterLevel, surchargeTopLayer, fullDisplacement=None) -> IFPileMaterialLayup:
		r"""
		define pile layup data 
		Params:
			manyCycles (bool): many cycles parameter
			pluggedBase (str): options "plugged", unplugged"
			waterLevel (float): water level
			surchargeTopLayer (float): surcharge top layer level
			fullDisplacement (bool, optional): Default true. Full displacement piles parameter for plugged piles.
		Returns:
			IFPileMaterialLayup: 
		"""
		pass


	def addPYCurve(self, pyCurve, topOfLayer) -> IFPileMaterialLayup:
		r"""
		add a PY curve and level to the layup 
		Params:
			pyCurve (IFPYCurve): The name or ID of a localcoordinate, or a pointer to a IFPYCurve object.
			topOfLayer (float): 
		Returns:
			IFPileMaterialLayup: 
		"""
		pass


	def getPYCurveValue(self, index, varName) -> object:
		r"""
		Gets the value for the given index segment 
		Params:
			index (int): material's index starting from 0
			varName (str): name of the value (e.g. "pyCurve")
		Returns:
			object: The type given will depend on the value specified
		"""
		pass


	def getPYCurvesCount(self) -> int:
		r"""
		Return the number of PY curve materials 
		Returns:
			int: 
		"""
		pass


	def getWaterLevel(self) -> float:
		r"""
		Return water level of this embedded pile material layup 
		Returns:
			float: 
		"""
		pass


	def getSurcharge(self) -> float:
		r"""
		Return surcharge at top of first layer 
		Returns:
			float: 
		"""
		pass


	def getBaseOfPile(self) -> str:
		r"""
		Return base of pile: plugged (solid) or unplugged (hollow piles) 
		Returns:
			str: 
		"""
		pass


	def getFullDisplacement(self) -> bool:
		r"""
		Return full displacement piles (i.e. driven, fully plugged or closed ended) 
		Returns:
			bool: 
		"""
		pass


	def getManyCycles(self) -> bool:
		r"""
		Return response after many cycles of loading 
		Returns:
			bool: 
		"""
		pass


	def getCurveGraph(self, joint, dof, pXs, pYs) -> None:
		r"""
		curve graph for one click report given internal point and element 
		Params:
			joint (IFElement): Element to report graphs at
			dof (int): Degree of freedom
			pXs (array of floats): Array of X values
			pYs (array of floats): Array of Y values
		Returns:
			None: 
		"""
		pass


class IFEigenControl(IFControl):
	"""
	 
	"""

	def getSolutionType(self) -> str:
		r"""
		return the Solution type of this control. Possible values are "Frequency", "Frequency (complex)", "Buckling load", or "Eigenvalues of stiffness matrix" 
		Returns:
			str: returned type
		"""
		pass


	def getRequiredType(self) -> str:
		r"""
		return the 'Eigenvalues required' type of this control. Possible values are "Range", "Maximum" or "Minimum" 
		Returns:
			str: returned type
		"""
		pass


	def getSolverType(self) -> str:
		r"""
		return the Eigensolver type of this control. Possible values are "Default", "Fast Block Lanczos", "Lanczos", "Subspace Jacobi", "Subspace QL" 
		Returns:
			str: returned type
		"""
		pass


	def setModalDampingSpecified(self, dampingtype, defaultDampingFactor, Modes) -> IFEigenControl:
		r"""
		 
		Params:
			dampingtype (str): 
			defaultDampingFactor (float): 
			Modes (array of loadcases): 
		Returns:
			IFEigenControl: 
		"""
		pass


	def setModalDampingAll(self, dampingtype, defaultDampingFactor) -> IFEigenControl:
		r"""
		 
		Params:
			dampingtype (str): 
			defaultDampingFactor (float): 
		Returns:
			IFEigenControl: 
		"""
		pass


	def setModalDampingNone(self, dampingtype, defaultDampingFactor) -> IFEigenControl:
		r"""
		 
		Params:
			dampingtype (str): 
			defaultDampingFactor (float): 
		Returns:
			IFEigenControl: 
		"""
		pass


	def setModalDampingValue(self, varName, Value, Units=None) -> IFEigenControl:
		r"""
		 
		Params:
			varName (str): 
			Value (object): 
			Units (IFUnitSet, optional): 
		Returns:
			IFEigenControl: 
		"""
		pass


	def getModalDampingValue(self, varName) -> object:
		r"""
		 
		Params:
			varName (str): 
		Returns:
			object: 
		"""
		pass


	def removeModalDamping(self) -> IFEigenControl:
		r"""
		 
		Returns:
			IFEigenControl: 
		"""
		pass


class IFFourierControl(IFControl):
	"""
	 
	"""

class IFTransientControl(IFControl):
	"""
	 
	"""

	def setNonlinearManual(self) -> IFTransientControl:
		r"""
		 
		Returns:
			IFTransientControl: 
		"""
		pass


	def setNonlinearAutomatic(self, startLoadFactor) -> IFTransientControl:
		r"""
		 
		Params:
			startLoadFactor (float): 
		Returns:
			IFTransientControl: 
		"""
		pass


	def removeNonlinear(self) -> IFTransientControl:
		r"""
		 
		Returns:
			IFTransientControl: 
		"""
		pass


	def hasNonlinear(self) -> bool:
		r"""
		Return true if this transient control has nonlinear data 
		Returns:
			bool: 
		"""
		pass


	def setTimeDomainConsolidation(self, initialTimeStep) -> IFTransientControl:
		r"""
		 
		Params:
			initialTimeStep (float): 
		Returns:
			IFTransientControl: 
		"""
		pass


	def setTimeDomainDynamics(self, initialTimeStep, IsExplicit=None) -> IFTransientControl:
		r"""
		 
		Params:
			initialTimeStep (float): 
			IsExplicit (bool, optional): 
		Returns:
			IFTransientControl: 
		"""
		pass


	def setTimeDomainThermal(self, initialTimeStep) -> IFTransientControl:
		r"""
		 
		Params:
			initialTimeStep (float): 
		Returns:
			IFTransientControl: 
		"""
		pass


	def setTimeDomainViscous(self, initialTimeStep) -> IFTransientControl:
		r"""
		 
		Params:
			initialTimeStep (float): 
		Returns:
			IFTransientControl: 
		"""
		pass


	def removeTimeDomain(self) -> IFTransientControl:
		r"""
		 
		Returns:
			IFTransientControl: 
		"""
		pass


	def hasTimeDomain(self) -> bool:
		r"""
		Return true if this transient control has time domain data 
		Returns:
			bool: 
		"""
		pass


	def removeIncTermData(self) -> IFTransientControl:
		r"""
		remove all stored time step data 
		Returns:
			IFTransientControl: 
		"""
		pass


	def addIncTermData(self, initTimeStep, maxTimeSteps, totalResponseTime) -> IFTransientControl:
		r"""
		add time step data 
		Params:
			initTimeStep (float): initial time step
			maxTimeSteps (int): maximum number of time steps
			totalResponseTime (float): total responce time
		Returns:
			IFTransientControl: 
		"""
		pass


	def setOutput(self) -> IFTransientControl:
		r"""
		 
		Returns:
			IFTransientControl: 
		"""
		pass


	def removeOutput(self) -> IFTransientControl:
		r"""
		 
		Returns:
			IFTransientControl: 
		"""
		pass


	def setConstants(self) -> IFTransientControl:
		r"""
		 
		Returns:
			IFTransientControl: 
		"""
		pass


	def removeConstants(self) -> IFTransientControl:
		r"""
		 
		Returns:
			IFTransientControl: 
		"""
		pass


class IFResultsLoadset(IFLoadset):
	"""
	A representation of an increment, time-step or loadcase as created by LUSAS Solver. In normal use, results loadcases sit within the pre-processing loadcase that created them. 
	"""

	def getLoadcase(self) -> IFLoadcase:
		r"""
		Return the pre-processing loadcase that created this results loadset 
		Returns:
			IFLoadcase: 
		"""
		pass


	def hasLoadcase(self) -> bool:
		r"""
		Return whether or not there is a pre-processing loadcase that created this results loadset. Generally, this will be true, however there are a few cases where it is not - e.g. VLO, loading results without a model, etc. 
		Returns:
			bool: 
		"""
		pass


class IFPreLoadset(IFLoadset):
	"""
	common interface for the IFLoadcase and IFLoadcurve 
	"""

	def copyAssignmentsFrom(self, sourceLoadcase, attrType=None, attributes=None) -> None:
		r"""
		Copy assignments from the given loadcase/load curve into this loadcase/load curve. If only the source load curve is given then all assignments from all attributes will be copied. 
		Params:
			sourceLoadcase (object): Load curve to copy assignments from
			attrType (str, optional): Type of attribute whose assignments will be copied
			attributes (array, optional): Names and/or numbers of the attributes whose assignments will be copied
		Returns:
			None: 
		"""
		pass


	def addGravity(self, isGravity) -> None:
		r"""
		Automatically add gravity to this loadcase/load curve 
		Params:
			isGravity (bool): gravity 'on' or 'off'
		Returns:
			None: 
		"""
		pass


	def hasGravity(self) -> bool:
		r"""
		Determine whether gravity is automatically added to this loadcase/load curve 
		Returns:
			bool: gravity 'on' or 'off'
		"""
		pass


	def setGravityFactor(self, gravityFactor) -> None:
		r"""
		Sets the gravity factor for this loadcase/load curve(default is 1.0) 
		Params:
			gravityFactor (float): gravity factor
		Returns:
			None: 
		"""
		pass


	def getGravityFactor(self) -> float:
		r"""
		Gets the gravity factor for this loadcase/load curve 
		Returns:
			float: gravity factor
		"""
		pass


	def changeLoadFactor(self, attribute, fromLoadFactor, toLoadFactor) -> None:
		r"""
		change the load factors on the loadcase assignments from the given value to the given value 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. attribute to change load factor
			fromLoadFactor (float): existing load factor
			toLoadFactor (float): new load factor
		Returns:
			None: 
		"""
		pass


class IFLoadcase(IFPreLoadset):
	"""
	LPI access to the loadcase objects visible in LUSAS Modeller's loadcase treeview. Each loadcase may have one or more controls attached to it. Each control is independently accessed as an object, and has its own section of the LPI 
	"""

	def moveAfter(self, ID, updateCombs=None) -> IFLoadcase:
		r"""
		Move this loadcase to be below the given loadcase in the LUSAS datafile 
		Params:
			ID (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object.
			updateCombs (bool, optional): update combinations and envelopes to reflect the change?
		Returns:
			IFLoadcase: 
		"""
		pass


	def moveToFirst(self, updateCombs=None) -> IFLoadcase:
		r"""
		Move this loadcase to be the first loadcase in the LUSAS datafile 
		Params:
			updateCombs (bool, optional): update combinations and envelopes to reflect the change?
		Returns:
			IFLoadcase: 
		"""
		pass


	def setTransientControl(self, maxTimeSteps) -> IFLoadcase:
		r"""
		Create or modify the transient/non-linear control attached to this loadcase 
		Params:
			maxTimeSteps (int): 
		Returns:
			IFLoadcase: 
		"""
		pass


	def removeTransientControl(self) -> IFLoadcase:
		r"""
		Remove any transient/non-linear control attached 
		Returns:
			IFLoadcase: 
		"""
		pass


	def getTransientControl(self) -> IFTransientControl:
		r"""
		Return the transient/non-linear control attached to this loadcase It is an error to call this function if no transient/non-linear control is attached 
		Returns:
			IFTransientControl: 
		"""
		pass


	def hasTransientControl(self) -> bool:
		r"""
		Return true if this loadcase has a transient/non-linear control attached 
		Returns:
			bool: 
		"""
		pass


	def setEigenvalueMaxMinControl(self, eigenvaluetype, maxMinType, numberOfEigenvalues) -> IFLoadcase:
		r"""
		Create or modify the eigenvalue control attached to this loadcase 
		Params:
			eigenvaluetype (str): 
			maxMinType (str): 
			numberOfEigenvalues (int): 
		Returns:
			IFLoadcase: 
		"""
		pass


	def setEigenvalueRangeControl(self, eigenvalueType, rangeType, maxVal, minVal, numberOfEigenvalues) -> IFLoadcase:
		r"""
		Create or modify the eigenvalue control attached to this loadcase 
		Params:
			eigenvalueType (str): 
			rangeType (str): 
			maxVal (float): 
			minVal (float): 
			numberOfEigenvalues (int): 
		Returns:
			IFLoadcase: 
		"""
		pass


	def removeEigenvalueControl(self) -> IFLoadcase:
		r"""
		Remove any eigenvalue control attached 
		Returns:
			IFLoadcase: 
		"""
		pass


	def getEigenvalueControl(self) -> IFEigenControl:
		r"""
		Return the eigenvalue control attached to this loadcase It is an error to call this function if no eigenvalue control is attached 
		Returns:
			IFEigenControl: 
		"""
		pass


	def hasEigenvalueControl(self) -> bool:
		r"""
		Return true if this loadcase has an eigenvalue control attached 
		Returns:
			bool: 
		"""
		pass


	def setFourierControl(self, harmonicComponents, first, last, diff) -> IFLoadcase:
		r"""
		Create or modify the fourier control attached to this loadcase 
		Params:
			harmonicComponents (str): 
			first (array of ints): 
			last (array of ints): 
			diff (array of ints): 
		Returns:
			IFLoadcase: 
		"""
		pass


	def removeFourierControl(self) -> IFLoadcase:
		r"""
		Remove any fourier control attached 
		Returns:
			IFLoadcase: 
		"""
		pass


	def getFourierControl(self) -> IFFourierControl:
		r"""
		Return the fourier control attached to this loadcase It is an error to call this function if no fourier control is attached 
		Returns:
			IFFourierControl: 
		"""
		pass


	def hasFourierControl(self) -> bool:
		r"""
		Return true if this loadcase has a fourier control attached 
		Returns:
			bool: 
		"""
		pass


	def getAssignments(self, attributeType=None, andAssignedObjects=None) -> list[IFAssignment]:
		r"""
		Creates and returns an array of IFAssignment objects, each of which represents one attribute assignment within this loadcase. The array can be restricted by using the optional argument to specify a given attribute type, e.g. "loading". If not given, all loadcase dependant assignments are returned. Note that the IFAssignment objects returned are copies of the ones in actual use - modifying them will have no effect. If you wish to modify assignment details it is necessary to re-assign the attribute to the object 
		Params:
			attributeType (object, optional): "Loading", "Support", "Material", etc
			andAssignedObjects (bool, optional): default false, if true add the assigned objects to the IFAssignment objects returned
		Returns:
			array of IFAssignment objects: The returned array
		"""
		pass


	def removeAssignments(self, attributeType) -> None:
		r"""
		Removes any assignments of the given type 
		Params:
			attributeType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def hasResultsLoadcase(self, nameID, location) -> bool:
		r"""
		return true if this loadset has results with the given name/ID 
		Params:
			nameID (str or int): Name or ID of a timestep or increment within this
			location (str or int): Name or ID of a location (results file) of a timestep or increment within this
		Returns:
			bool: 
		"""
		pass


	def getResultsLoadcase(self, nameID, location) -> IFResultsLoadset:
		r"""
		Finds and returns a NL/transient results within this loadcase, using the given name/ID and location 
		Params:
			nameID (str or int): 
			location (str or int): 
		Returns:
			IFResultsLoadset: 
		"""
		pass


	def getResultsLoadcases(self) -> list[IFResultsLoadset]:
		r"""
		Return an array of all the results loadcases (IFResultsLoadset) that were created by solving this loadcase (will be empty if results are not loaded or not appropriate) 
		Returns:
			array of IFResultsLoadset: the array
		"""
		pass


	def setDoSolve(self, tabulate) -> IFLoadcase:
		r"""
		Sets flag indicating if this loadcase will be processed by solver when the parent analysis is solved. Note this flag will be ignored unless IFTabulateDataObj.setSolveAllLoadcases(false) is also called. 
		Params:
			tabulate (bool): 
		Returns:
			IFLoadcase: 
		"""
		pass


	def getAnalysis(self) -> IFAnalysisBaseClass:
		r"""
		Return the analysis within which this loadcase sits 
		Returns:
			IFAnalysisBaseClass: 
		"""
		pass


	def isFirst(self, type=None) -> bool:
		r"""
		Return true if this loadcase will be tabulated first More accurately, return false if a loadcase of the given type will be tabulated before this one. Note that the first loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you really want to know about any loadcase before this one, regardless of type, pass in -1. If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			bool: 
		"""
		pass


	def isLast(self, type=None) -> bool:
		r"""
		Return true if this loadcase will be tabulated last More accurately, return false if a loadcase of the given type will be tabulated after this one. Note that the last loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you really want to know about any loadcase after this one, regardless of type, pass in -1. If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			bool: 
		"""
		pass


	def getPrevious(self, type=None) -> IFLoadset:
		r"""
		Return the loadcase that will be tabulated before this one (it is an error to call on the first one) Note that the previous loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you really want the previous one, regardless of type, pass in -1. If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			IFLoadset: 
		"""
		pass


	def getNext(self, type=None) -> IFLoadset:
		r"""
		Return the loadcase that will be tabulated after this one (it is an error to call on the last one) Note that the next loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			IFLoadset: 
		"""
		pass


	def createCopy(self, analysis, loadcase=None, update=None, copyMaterials=None) -> IFLoadcase:
		r"""
		Creates a clone loadcase 
		Params:
			analysis (IFAnalysisBaseClass): The name or ID of a "Analysis", or a pointer to a IFAnalysisBaseClass object. Analysis in which to create copy
			loadcase (IFLoadcase, optional): The name or ID of a "Loadcase", or a pointer to a IFLoadcase object. Loadcase after which the copy will be inserted (if NULL, insert at the beginning).
			update (bool, optional): Set this to true to update combinations and envelopes to reflect the re-ordering change
			copyMaterials (str, optional): "copy","no copy","inherit" material and composite assignments
		Returns:
			IFLoadcase: the new loadcase that has been created
		"""
		pass


	def setLoadcaseAge(self, age) -> IFLoadcase:
		r"""
		Specify the age of the structure at the end of this loadcase (the value of "total response time" for a viscous control) 
		Params:
			age (float): 
		Returns:
			IFLoadcase: 
		"""
		pass


	def getLoadcaseAge(self) -> float:
		r"""
		Returns the age of the structure at the end of this loadcase (the value of "total response time" for a viscous control) 
		Returns:
			float: 
		"""
		pass


	def getModificationTime(self, analysisOnly) -> int:
		r"""
		Returns the number of seconds between Jan 1st 1970 and the time at which this loadcase was most recently modified - either directly (e.g. assignment) or indirectly (e.g. assignment to a previous loadcase) There are two possible answers - one excludes assignments of attributes that do not affect the solution (this is the same as the flag that is used internally to know whether the loadcase needs solving or not). The other includes all attributes, even those that do not affect solution. 
		Params:
			analysisOnly (bool): if true, the value returned excludes attributes which do not affect solution
		Returns:
			int: 
		"""
		pass


class IFLoadCurve(IFPreLoadset):
	"""
	 
	"""

	def setStandardLoadCurve(self, activationValue, peakValue, frequency, phaseAngle, assignmentFactor, curveType, haveTermination=None, terminationValue=None, meanApplitude=None) -> IFLoadCurve:
		r"""
		Set this load curve to be of standard type - the shape of the curve will be defined by standard functions 
		Params:
			activationValue (float): 
			peakValue (float): 
			frequency (float): 
			phaseAngle (float): 
			assignmentFactor (float): 
			curveType (str): 
			haveTermination (bool, optional): true if the curve has a termination value
			terminationValue (float, optional): termination value if "haveTermination" is true, else ignored
			meanApplitude (float, optional): mean applitude, default zero
		Returns:
			IFLoadCurve: 
		"""
		pass


	def setVariationLoadCurve(self, activationValue, terminationValue, incrementValue, assignmentFactor, variation) -> IFLoadCurve:
		r"""
		Set this load curve to be of variation type - the shape of the curve will be defined by the given variation 
		Params:
			activationValue (float): 
			terminationValue (float): 
			incrementValue (float): 
			assignmentFactor (float): 
			variation (IFVariationAttr): The name or ID of a variation, or a pointer to a IFVariationAttr object.
		Returns:
			IFLoadCurve: 
		"""
		pass


	def setTableLoadCurve(self, activationValue, assignmentFactor) -> IFLoadCurve:
		r"""
		Set this load curve to be of table type - the shape of the curve will be defined by a table of (x,y) pairs 
		Params:
			activationValue (float): 
			assignmentFactor (float): 
		Returns:
			IFLoadCurve: 
		"""
		pass


	def removeTableRows(self) -> IFLoadCurve:
		r"""
		Remove all previously added table values 
		Returns:
			IFLoadCurve: 
		"""
		pass


	def addTableRow(self, x, y) -> IFLoadCurve:
		r"""
		Add one (x,y) pair to the shape of this table load curve. Equivalent to one row in the table on the definition dialog. Note - if you have many pairs, it is much more efficient to call IFLoadCurve.setTableData. 
		Params:
			x (float): 
			y (float): 
		Returns:
			IFLoadCurve: 
		"""
		pass


	def setTableData(self, x, y) -> IFLoadCurve:
		r"""
		Use the given arrays to set all the shape of this table load curve. Equivalent to the entire contents of the table on the definition dialog. 
		Params:
			x (array of float): 
			y (array of float): 
		Returns:
			IFLoadCurve: 
		"""
		pass


	def removeLastTableRow(self) -> IFLoadCurve:
		r"""
		Remove the most recently added table value pair 
		Returns:
			IFLoadCurve: 
		"""
		pass


	def getAssignments(self, andAssignedObjects=None) -> list[IFAssignment]:
		r"""
		creates and returns an array of IFAssignment objects, each of which represents one loading assignment within this load curve. Note that the IFAssignment objects returned are copies of the ones in actual use - modifying them will have no effect. If you wish to modify assignment details it is necessary to re-assign the attribute to the object 
		Params:
			andAssignedObjects (bool, optional): default false, if true add the assigned objects to the IFAssignment objects returned
		Returns:
			array of IFAssignment objects: The returned array
		"""
		pass


	def removeAssignments(self) -> None:
		r"""
		Removes any loading assignments 
		Returns:
			None: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def getAnalysis(self) -> IFAnalysisBaseClass:
		r"""
		Return the analysis within which this load curve sits 
		Returns:
			IFAnalysisBaseClass: 
		"""
		pass


	def createCopy(self, analysis) -> IFLoadCurve:
		r"""
		Creates a clone load curve 
		Params:
			analysis (IFAnalysisBaseClass): The name or ID of a "Analysis", or a pointer to a IFAnalysisBaseClass object. Analysis in which to create copy
		Returns:
			IFLoadCurve: the new load curve that has been created
		"""
		pass


	def setLoadComponent(self, loadComponent) -> IFLoadCurve:
		r"""
		set the load component 
		Params:
			loadComponent (str): load component name
		Returns:
			IFLoadCurve: 
		"""
		pass


	def setCutOff(self, doCutOff, cutOffValue=None, keepAbove=None, nSamplingPts=None) -> IFLoadCurve:
		r"""
		set the cut off value for the loadcurve values 
		Params:
			doCutOff (bool): true to cut off the loadcurve above (or below - see "keep above") the given value
			cutOffValue (float, optional): cut off value, only relevant if "doCutOff" is true, default = 0.0
			keepAbove (bool, optional): if true keep the curve values above the cut off, if false keep the curve values below the cut off, default = true
			nSamplingPts (int, optional): number of tabulation points for sine and cosine curves per cycle
		Returns:
			IFLoadCurve: 
		"""
		pass


class IFBasicCombination(IFLoadset):
	"""
	 
	"""

	def removeEntries(self) -> IFBasicCombination:
		r"""
		 
		Returns:
			IFBasicCombination: 
		"""
		pass


	def addEntry(self, factor, ID, resFile=None, eigen=None, harm=None) -> IFBasicCombination:
		r"""
		Add the specified loadset.  
		Params:
			factor (float): 
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFBasicCombination: 
		"""
		pass


	def addEntries(self, factors, IDs, resFiles=None, eigens=None, harms=None) -> IFBasicCombination:
		r"""
		Add the specified loadsets.  
		Params:
			factors (array of float): 
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			IFBasicCombination: 
		"""
		pass


	def getLoadcaseIDs(self) -> list[int]:
		r"""
		Return, as an array, the IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getResultsFileIDs(self) -> list[int]:
		r"""
		Return, as an array, the result file IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getEigenvalueIDs(self) -> list[int]:
		r"""
		Return, as an array, the eigenvalue IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getHarmonicIDs(self) -> list[int]:
		r"""
		Return, as an array, the harmonic IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getFactors(self) -> list[float]:
		r"""
		Return, as an array, the factors applied to the loadcases within this combination 
		Returns:
			array of float: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder or a folder hierarchy to act as the last part of the tree location where this loadset will be shown. If the folder(s) do not already exist, they will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special" and by calling this function with the word "Special\SubFolder" it will be shown in the tree in "Loadcases\Special\SubFolder". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


	def createLoadcase(self, analysisName, loadcaseName=None) -> IFLoadcase:
		r"""
		Create a loadcase based on this combination The loadcase will contain all the loading assignments from this combination, each multiplied by the  factors that define this combination 
		Params:
			analysisName (str): Name of analysis in which to create the new loadcase
			loadcaseName (str, optional): Name of the new loadcase
		Returns:
			IFLoadcase: 
		"""
		pass


	def setMethod(self, method) -> IFBasicCombination:
		r"""
		Change the method used to calculate the value of this combination. If not specified, the default is "factored". Possible methods are:  "Factored" = A*LC1 + B*LC2                  (sum of factored values) "Average"  = (A*LC1 + B*LC2) / 2            (average of factored values) "SRSS"     = sqrt(A*(LC1**) + B*(LC2**))    (square root of sum of factored squares) "SSSR"     = (A*sqrt(LC1) + B*sqrt(LC2))**  (square of sum of factored square roots) "Absolute" = abs(A*LC1) + abs(B*LC2)        (sum of absolute factored values)  
		Params:
			method (str): see description
		Returns:
			IFBasicCombination: 
		"""
		pass


	def getModificationTime(self, analysisOnly) -> int:
		r"""
		Returns the number of seconds between Jan 1st 1970 and the time at which this combination, or any loadset within this combination, was most recently modified. This could be directly (e.g. add/remove loadcase, assignment to loadcase) or indirectly (e.g. assignment to base analysis) There are two possible answers - one excludes assignments of attributes that do not affect the solution (this is the same as the flag that is used internally to know whether the loadcase needs solving or not). The other includes all attributes, even those that do not affect solution. 
		Params:
			analysisOnly (bool): if true, the value returned excludes attributes which do not affect solution
		Returns:
			int: 
		"""
		pass


class IFSmartCombination(IFLoadset):
	"""
	 
	"""

	def removeEntries(self) -> IFSmartCombination:
		r"""
		 
		Returns:
			IFSmartCombination: 
		"""
		pass


	def addEntry(self, factor, variableFactor, ID, resFile=None, eigen=None, harm=None) -> IFSmartCombination:
		r"""
		Add the specified loadset.  
		Params:
			factor (float): 
			variableFactor (float): 
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFSmartCombination: 
		"""
		pass


	def addEntries(self, factors, variableFactors, IDs, resFiles=None, eigens=None, harms=None) -> IFSmartCombination:
		r"""
		Add the specified loadsets.  
		Params:
			factors (array of float): 
			variableFactors (array of float): 
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			IFSmartCombination: 
		"""
		pass


	def setEffects(self, nToConsider, nVariable) -> IFSmartCombination:
		r"""
		Set the maximum number of loadcases to be considered when performing the combination calculations 
		Params:
			nToConsider (int): Specifies the number of loadcases to consider
			nVariable (int): Specifies the number of loadcases with variable effects
		Returns:
			IFSmartCombination: 
		"""
		pass


	def getNumberToConsider(self) -> int:
		r"""
		Return the number of loadcases to consider set with IFSmartCombination.setEffects 
		Returns:
			int: 
		"""
		pass


	def getNumberVariable(self) -> int:
		r"""
		Return the number of loadcases with variable effects set with IFSmartCombination.setEffects  
		Returns:
			int: 
		"""
		pass


	def getLoadcaseIDs(self) -> list[int]:
		r"""
		Return, as an array, the IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getResultsFileIDs(self) -> list[int]:
		r"""
		Return, as an array, the result file IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getEigenvalueIDs(self) -> list[int]:
		r"""
		Return, as an array, the eigenvalue IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getHarmonicIDs(self) -> list[int]:
		r"""
		Return, as an array, the harmonic IDs of the loadcases within this combination 
		Returns:
			array of ints: 
		"""
		pass


	def getPermanentFactors(self) -> list[float]:
		r"""
		Return, as an array, the permanent factors applied to the loadcases within this combination 
		Returns:
			array of float: 
		"""
		pass


	def getVariableFactors(self) -> list[float]:
		r"""
		Return, as an array, the variable factors applied to the loadcases within this combination 
		Returns:
			array of float: 
		"""
		pass


	def isMax(self) -> bool:
		r"""
		Returns true if the object is the maximum for the smart combination loadsets 
		Returns:
			bool: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


	def getAssocLoadset(self) -> IFSmartCombination:
		r"""
		If this object represents the maximum, it will return the minumum representation. Similarly, if this object represents the minumum, it will return the maximum representation. 
		Returns:
			IFSmartCombination: 
		"""
		pass


	def getMaxLoadset(self) -> IFSmartCombination:
		r"""
		Return the object that represents the maximum 
		Returns:
			IFSmartCombination: 
		"""
		pass


	def getMinLoadset(self) -> IFSmartCombination:
		r"""
		Return the object that represents the minimum 
		Returns:
			IFSmartCombination: 
		"""
		pass


	def getModificationTime(self, analysisOnly) -> int:
		r"""
		Returns the number of seconds between Jan 1st 1970 and the time at which this combination, or any loadset within this combination, was most recently modified. This could be directly (e.g. add/remove loadcase, assignment to loadcase) or indirectly (e.g. assignment to base analysis) There are two possible answers - one excludes assignments of attributes that do not affect the solution (this is the same as the flag that is used internally to know whether the loadcase needs solving or not). The other includes all attributes, even those that do not affect solution. 
		Params:
			analysisOnly (bool): if true, the value returned excludes attributes which do not affect solution
		Returns:
			int: 
		"""
		pass


class IFEnvelope(IFLoadset):
	"""
	 
	"""

	def removeEntries(self) -> IFEnvelope:
		r"""
		 
		Returns:
			IFEnvelope: 
		"""
		pass


	def addEntry(self, ID, resFile=None, eigen=None, harm=None) -> IFEnvelope:
		r"""
		Add the specified loadset.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFEnvelope: 
		"""
		pass


	def addEntries(self, IDs, resFiles=None, eigens=None, harms=None) -> IFEnvelope:
		r"""
		Add the specified loadsets.  
		Params:
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			IFEnvelope: 
		"""
		pass


	def getLoadcaseIDs(self) -> list[int]:
		r"""
		Return, as an array, the IDs of the loadcases within this envelope 
		Returns:
			array of ints: 
		"""
		pass


	def getResultsFileIDs(self) -> list[int]:
		r"""
		Return, as an array, the result file IDs of the loadcases within this envelope 
		Returns:
			array of ints: 
		"""
		pass


	def getEigenvalueIDs(self) -> list[int]:
		r"""
		Return, as an array, the eigenvalue IDs of the loadcases within this envelope 
		Returns:
			array of ints: 
		"""
		pass


	def getHarmonicIDs(self) -> list[int]:
		r"""
		Return, as an array, the harmonic IDs of the loadcases within this envelope 
		Returns:
			array of ints: 
		"""
		pass


	def isMax(self) -> bool:
		r"""
		Returns true if the object is the maximum for the smart envelope loadsets 
		Returns:
			bool: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


	def getAssocLoadset(self) -> IFEnvelope:
		r"""
		If this object represents the maximum, it will return the minumum representation. Similarly, if this object represents the minumum, it will return the maximum representation. 
		Returns:
			IFEnvelope: 
		"""
		pass


	def getMaxLoadset(self) -> IFEnvelope:
		r"""
		Return the object that represents the maximum 
		Returns:
			IFEnvelope: 
		"""
		pass


	def getMinLoadset(self) -> IFEnvelope:
		r"""
		Return the object that represents the minimum 
		Returns:
			IFEnvelope: 
		"""
		pass


	def getModificationTime(self, analysisOnly) -> int:
		r"""
		Returns the number of seconds between Jan 1st 1970 and the time at which this envelope, or any loadset within this envelope, was most recently modified. This could be directly (e.g. add/remove loadcase, assignment to loadcase) or indirectly (e.g. assignment to base analysis) There are two possible answers - one excludes assignments of attributes that do not affect the solution (this is the same as the flag that is used internally to know whether the loadcase needs solving or not). The other includes all attributes, even those that do not affect solution. 
		Params:
			analysisOnly (bool): if true, the value returned excludes attributes which do not affect solution
		Returns:
			int: 
		"""
		pass


class IFTLOEnvelope(IFLoadset):
	"""
	 
	"""

	def getVisualisedLoadingLoadcase(self) -> IFLoadcase:
		r"""
		Creates a loadcase that will contain the loading attribute assignments made by TLO at a specific location 
		Returns:
			IFLoadcase: returned  loadcase
		"""
		pass


	def addInfAssignResult(self, pInfName, assignmentRank, isPositive) -> IFVLOInfAssignResult:
		r"""
		Add an influence assign result for the given influence entry 
		Params:
			pInfName (str): name of the influence envelope attribute
			assignmentRank (str): assignment rank of the influence assignment for which TLO calculated the results
			isPositive (bool): is this for a positive or negative result?
		Returns:
			IFVLOInfAssignResult: returned influence result
		"""
		pass


class IFFatigue(IFLoadset):
	"""
	 
	"""

	def setResults(self, entity, component) -> IFFatigue:
		r"""
		Specify the results entity and component which define this fatigue loadset. Note that whilst the entity must be 'stress', it can be modified to include a particular element stress model, e.g. 'stress - solid'. 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
		Returns:
			IFFatigue: 
		"""
		pass


	def setComponent(self, component) -> IFFatigue:
		r"""
		This function is now obsolete and no longer supported. Please use IFFatigue.setResults instead (which allows specification of element stress model) 
		Params:
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
		Returns:
			IFFatigue: 
		"""
		pass


	def removeEntries(self) -> IFFatigue:
		r"""
		remove all spectrum entries 
		Returns:
			IFFatigue: 
		"""
		pass


	def addEntry(self, factor, cycles, ID, resFile=None, eigen=None, harm=None) -> IFFatigue:
		r"""
		Add the specified spectrum entry.  
		Params:
			factor (float): 
			cycles (float): 
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFFatigue: 
		"""
		pass


	def addEntries(self, factor, cycles, IDs, resFiles=None, eigens=None, harms=None) -> IFFatigue:
		r"""
		Add several spectrum entries in array form.  
		Params:
			factor (array of float): 
			cycles (array of float): 
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			IFFatigue: 
		"""
		pass


	def removeSNCurve(self) -> IFFatigue:
		r"""
		Clear the SN Curve for this loadset, removing any previous SN curve data. 
		Returns:
			IFFatigue: 
		"""
		pass


	def addSNCurveRow(self, stress, cycle) -> IFFatigue:
		r"""
		Add a row to the SN Curve for this loadset, appending to any previous SN curve data. 
		Params:
			stress (float): 
			cycle (float): 
		Returns:
			IFFatigue: 
		"""
		pass


	def setSNCurve(self, stress, cycle) -> IFFatigue:
		r"""
		Set the SN Curve for this loadset, replacing any previous SN curve data. 
		Params:
			stress (array of float): 
			cycle (array of float): 
		Returns:
			IFFatigue: 
		"""
		pass


	def getLoadcaseIDs(self) -> list[int]:
		r"""
		Return, as an array, the IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getResultsFileIDs(self) -> list[int]:
		r"""
		Return, as an array, the result file IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getEigenvalueIDs(self) -> list[int]:
		r"""
		Return, as an array, the eigenvalue IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getHarmonicIDs(self) -> list[int]:
		r"""
		Return, as an array, the harmonic IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getFactors(self) -> list[float]:
		r"""
		Return, as an array, the factors of the loadcases within this loadcase 
		Returns:
			array of float: 
		"""
		pass


	def getCycles(self) -> list[float]:
		r"""
		Return, as an array, the cycles of the loadcases within this loadcase 
		Returns:
			array of float: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


class IFIMD(IFLoadset):
	"""
	 
	"""

	def setDampingType(self, type) -> IFIMD:
		r"""
		 
		Params:
			type (str): 
		Returns:
			IFIMD: 
		"""
		pass


	def removeDamping(self) -> IFIMD:
		r"""
		 
		Returns:
			IFIMD: 
		"""
		pass


	def addDampingRow(self, viscous, structural) -> IFIMD:
		r"""
		 
		Params:
			viscous (float): 
			structural (float): 
		Returns:
			IFIMD: 
		"""
		pass


	def setAllModes(self) -> IFIMD:
		r"""
		Specify that this loadset should use all available modes. Note that this setting is remembered instead of a list of modes, and thus the actual obtaining of 'all modes' is done at the time that this loadset is set active. In turn, this means that the actual modes used will change as results files are added or removed. If you wish to fix the modes to be used, use addEntries("all") or similar instead - which will add exactly those modes present at the time of the call. The 'all' setting is cleared by removing or adding entries individually. 
		Returns:
			IFIMD: 
		"""
		pass


	def removeEntries(self) -> IFIMD:
		r"""
		Remove all the modes from this loadset 
		Returns:
			IFIMD: 
		"""
		pass


	def addEntry(self, ID, resFile=None, eigen=None, harm=None) -> IFIMD:
		r"""
		Add the specified mode. An error is generated if the loadset given is not an eigenvalue result.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFIMD: 
		"""
		pass


	def addEntries(self, IDs, resFiles=None, eigens=None, harms=None) -> IFIMD:
		r"""
		Add the specified modes.  
		Params:
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			IFIMD: 
		"""
		pass


	def setPointExcitation(self, type, node, largeMass, component, amplitude=None) -> IFIMD:
		r"""
		 
		Params:
			type (str): "Force", "Displacement", "Velocity", or "Acceleration"
			node (IFNode): The name or ID of a node, or a pointer to a IFNode object.
			largeMass (float): large mass
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
			amplitude (float, optional): amplitude
		Returns:
			IFIMD: 
		"""
		pass


	def setRealLoadingExcitation(self, ID, resFile=None, eigen=None, harm=None) -> IFIMD:
		r"""
		 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFIMD: 
		"""
		pass


	def setImaginaryLoadingExcitation(self, ID, resFile=None, eigen=None, harm=None) -> IFIMD:
		r"""
		 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFIMD: 
		"""
		pass


	def setRealImaginaryLoadingExcitation(self, real, imaginary) -> IFIMD:
		r"""
		 
		Params:
			real (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
			imaginary (IFLoadset): The name or ID of a loadset, or a pointer to a IFLoadset object.
		Returns:
			IFIMD: 
		"""
		pass


	def setSupportMotionExcitation(self, type, motionType, x, y, z) -> IFIMD:
		r"""
		 
		Params:
			type (str): 
			motionType (str): 
			x (float): 
			y (float): 
			z (float): 
		Returns:
			IFIMD: 
		"""
		pass


	def setFrequencyResults(self, freq, phase, type) -> IFIMD:
		r"""
		 
		Params:
			freq (float): 
			phase (float): 
			type (str): 
		Returns:
			IFIMD: 
		"""
		pass


	def setPSD(self, psd) -> IFIMD:
		r"""
		 
		Params:
			psd (IFPSD): The name or ID of a PSD, or a pointer to a IFPSD object.
		Returns:
			IFIMD: 
		"""
		pass


	def setSpectrum(self, spectrum) -> IFIMD:
		r"""
		 
		Params:
			spectrum (IFSpectralCurve): The name or ID of a spectralcurve, or a pointer to a IFSpectralCurve object.
		Returns:
			IFIMD: 
		"""
		pass


	def setTimeResults(self, time, type) -> IFIMD:
		r"""
		 
		Params:
			time (float): 
			type (str): 
		Returns:
			IFIMD: 
		"""
		pass


	def setSpectralResults(self, type, correction) -> IFIMD:
		r"""
		 
		Params:
			type (str): 
			correction (str): 
		Returns:
			IFIMD: 
		"""
		pass


	def setPSDResults(self, start, end, step) -> IFIMD:
		r"""
		 
		Params:
			start (float): 
			end (float): 
			step (float): 
		Returns:
			IFIMD: 
		"""
		pass


	def getLoadcaseIDs(self) -> list[int]:
		r"""
		Return, as an array, the IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getResultsFileIDs(self) -> list[int]:
		r"""
		Return, as an array, the result file IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getEigenvalueIDs(self) -> list[int]:
		r"""
		Return, as an array, the eigenvalue IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getHarmonicIDs(self) -> list[int]:
		r"""
		Return, as an array, the harmonic IDs of the loadcases within this loadcase 
		Returns:
			array of ints: 
		"""
		pass


	def getModalForces(self, real, imaginary) -> None:
		r"""
		Return, as two arrays, the forces of the modes within this loadcase. Each pair of array entries represents the real and imaginary forces from one mode. 
		Params:
			real (array of floats): Real parts
			imaginary (array of floats): Imaginary parts
		Returns:
			None: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


class IFLoadsetResultsContainer(IFLoadset):
	"""
	An object which appears in the "postprocessing" section of the analysis treeview like a combination or envelope but has no ability to calculate its own results - it relies on a customisation module to call setScriptedResults on nodes and/or elements. This object then simply remembers those results and (when set active) can show them in contours and similar User interface (dialogs and context menus) must also be added by a customisation module 
	"""

	def addResult(self, entity, component, packedDim=None, unitSet=None, denominatatorUnitSet=None, hasSeparator=None) -> IFPrimaryScriptedResultsComponentSet:
		r"""
		Set the entity and first component for this object. Once added, these names can then be used in functions such as IFNode.setScriptedResults to setup values of results within this object. Note that names added in this way are only available within this one loadset. If you want your entity and component to be available in all loadsets, use IFDatabase.addScriptedResultsEntity. If you want more components, use IFPrimaryScriptedResultsComponentSet.addScriptedResults Note that calling this function resets the returned IFPrimaryScriptedResultsComponentSet object to have only this one component - any other components you may have previously added will need to be added again 
		Params:
			entity (str): Name of results entity
			component (str): Name of results component
			packedDim (int, optional): Dimensionality of the component
			unitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for this result - default is database units
			denominatatorUnitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for the optional extra 'per length/area' denominator - default is database units
			hasSeparator (bool, optional): has a separator after the component name in the components droplits
		Returns:
			IFPrimaryScriptedResultsComponentSet: object which will hold results
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


class IFScriptedLoadsetResultsContainer(IFLoadsetResultsContainer):
	"""
	A scripted results container for end user use 
	"""

	pass


class IFSlabDesignResultsContainer(IFLoadsetResultsContainer):
	"""
	A results container for Slab Design 
	"""

	pass


class IFRCDesignResultsContainer(IFLoadsetResultsContainer):
	"""
	A results container for RC Design 
	"""

	pass


class IFLoadsetTargetValues(IFLoadset):
	"""
	A target values loadset class calculates (via the specified optimisation method) factors for each of the included loadcases to ensure that the specified criteria are met (for example displacement in the point A is not bigger than B, or axial force in bar C is equal to value D etc.) 
	"""

	def removeEntries(self) -> IFLoadsetTargetValues:
		r"""
		Remove all loadsets 
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def addEntry(self, factorType, signeType, constantFactor, variableFactor, ID, resFile=None, eigen=None, harm=None) -> IFLoadsetTargetValues:
		r"""
		Add the specified loadset.  
		Params:
			factorType (str): factor type ("Variable" or "Constant")
			signeType (str): signe type ("Positive only" or "Allow negative")
			constantFactor (float): multiplier of constant variable (loadset)
			variableFactor (float): multiplier of variable (loadset)
			ID (object): IFLoadset object, loadset ID or loadset name. loadset ID
			resFile (int, optional): default = 0; results file ID
			eigen (int, optional): default = -1; eigen ID
			harm (int, optional): default = -1; harmonic ID
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def addEntries(self, factorTypes, signTypes, constantFactors, variableFactors, IDs, resFiles=None, eigens=None, harms=None) -> IFLoadsetTargetValues:
		r"""
		Add the specified loadsets.  
		Params:
			factorTypes (array of strs): array of factor types
			signTypes (array of strs): array of sign types
			constantFactors (array of float): array of multipliers
			variableFactors (array of float): array of multipliers
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names. array of loadsets ID
			resFiles (array of ints, optional): array of results files ID
			eigens (array of ints, optional): array of eigens ID
			harms (array of ints, optional): array of harmonics ID
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def removeTargets(self) -> IFLoadsetTargetValues:
		r"""
		Remove all targets. 
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def addTarget(self, type, name, entity, component, condition, value) -> IFLoadsetTargetValues:
		r"""
		Add the specified target. 
		Params:
			type (str): location type; valid values are: "point", "line start", "line end".
			name (str): location name
			entity (str): results entity
			component (str): results component
			condition (str): comparison condition; valid values are: "<<=", "=", ">="
			value (float): target value
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def addTargets(self, types, names, entitys, components, conditions, values) -> IFLoadsetTargetValues:
		r"""
		Add the specified targets. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			conditions (array of strs): array of target values
			values (array of float): 
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def getTargets(self, types, names, entitys, components, conditions, values) -> IFLoadsetTargetValues:
		r"""
		Get the specified targets. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			conditions (array of strs): array of target values
			values (array of float): 
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def getLoadcaseIDs(self) -> list[int]:
		r"""
		Return, as an array, the IDs of the loadcases within this target value loadset 
		Returns:
			array of ints: 
		"""
		pass


	def getResultsFileIDs(self) -> list[int]:
		r"""
		Return, as an array, the result file IDs of the loadcases within this target value loadset 
		Returns:
			array of ints: 
		"""
		pass


	def getEigenvalueIDs(self) -> list[int]:
		r"""
		Return, as an array, the eigenvalue IDs of the loadcases within this target value loadset 
		Returns:
			array of ints: 
		"""
		pass


	def getHarmonicIDs(self) -> list[int]:
		r"""
		Return, as an array, the harmonic IDs of the loadcases within this target value loadset 
		Returns:
			array of ints: 
		"""
		pass


	def getFactorTypes(self) -> list[str]:
		r"""
		Return, as an array, the target factor types applied to the loadcases within this target value loadset 
		Returns:
			array of strs: 
		"""
		pass


	def getSignTypes(self) -> list[str]:
		r"""
		Return, as an array, the target sign types applied to the loadcases within this target value loadset 
		Returns:
			array of strs: 
		"""
		pass


	def getConstantFactors(self) -> list[float]:
		r"""
		Return, as an array, the target constant factors applied to the loadcases within this target value loadset 
		Returns:
			array of float: 
		"""
		pass


	def getVariableFactors(self) -> list[float]:
		r"""
		Return, as an array, the target variable factors applied to the loadcases within this target value loadset 
		Returns:
			array of float: 
		"""
		pass


	def removeOptimisationCriteria(self) -> IFLoadsetTargetValues:
		r"""
		Remove all optimisation criteria 
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def addOptimisationCriterion(self, type, name, entity, component, factor) -> IFLoadsetTargetValues:
		r"""
		Add the specified optimisation criterion. The criterion will serve as the constraint in the optimisation equation set 
		Params:
			type (str): location type; valid values are: "point", "line start", "line end".
			name (str): location name
			entity (str): results entity
			component (str): results component
			factor (float): weighting factor
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def addOptimisationCriteria(self, types, names, entitys, components, factors) -> IFLoadsetTargetValues:
		r"""
		Add the specified optimisation criteria set. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			factors (array of float): array of weighting factors
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def getOptimisationCriteria(self, types, names, entitys, components, factors) -> IFLoadsetTargetValues:
		r"""
		Get the specified optimisation criteria. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			factors (array of float): array of weighting factors
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def setOptimisation(self, solutionType, method=None) -> IFLoadsetTargetValues:
		r"""
		Set optimisation parameters. 
		Params:
			solutionType (str): solution type; valid values are: "exact", "optimised", "best fit".
			method (str, optional): optimisation method; obligatory parameter if solution type is "optimised" or "best fit"; For optimised, valid values are: For best fit, valid values are: "Minimise Largest", "Minimise Sum", "Minimise Specified", "Maximise Sum", and "Maximise Specified". For best fit, valid values are "least squares" and "chebyshev".
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def optimise(self, factors=None) -> int:
		r"""
		Perform the optimisation, calculating a factor for each variable loadcase 
		Params:
			factors (array of real, optional): If given, and if optimisation succeeds, sized and filled with the calculated factors
		Returns:
			int: zero for success, non-zero indicates failure
		"""
		pass


	def createCombination(self) -> IFBasicCombination:
		r"""
		Create basic combination from this target value loadset. The basic combination will contain all the entries (loadsets) from this target value loadset, each multiplied by the corresponding factor obtained from optimisation 
		Returns:
			IFBasicCombination: 
		"""
		pass


	def createLoadcase(self, analysisName, loadcaseName=None) -> IFLoadcase:
		r"""
		Create loadcase from this target value loadset. The loadcase will contain all the loads from this target value loadset, each  multiplied by the corresponding factor obtained from optimisation 
		Params:
			analysisName (str): Analysis name
			loadcaseName (str, optional): Name of the new loadcase
		Returns:
			IFLoadcase: 
		"""
		pass


	def factorLoadcases(self) -> IFLoadsetTargetValues:
		r"""
		Apply the calculated factors to each of the loadcases included in this, by multiplying the corresponding load factors in their load assignments 
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def validateInput(self) -> bool:
		r"""
		Check data consistency, returning zero if the data is valid, and writing a message to the text output window if it is not. 
		Returns:
			bool: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


class IFCableTuningLoadcase(IFLoadset):
	"""
	A target values loadset class calculates (via the specified optimisation method) factors for each of the included loadcases to ensure that the specified criteria are met (for example displacement in the point A is not bigger than B, or axial force in bar C is equal to value D etc.) 
	"""

	def removeTargets(self) -> IFCableTuningLoadcase:
		r"""
		Remove all targets. 
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def addTarget(self, type, name, entity, component, condition, value) -> IFCableTuningLoadcase:
		r"""
		Add the specified target. 
		Params:
			type (str): location type; valid values are: "point", "line start", "line end".
			name (str): location name
			entity (str): results entity
			component (str): results component
			condition (str): comparison condition; valid values are: "<<=", "=", ">="
			value (float): target value
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def getTargets(self, types, names, entitys, components, conditions, values) -> IFCableTuningLoadcase:
		r"""
		Get the specified targets. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			conditions (array of strs): array of target values
			values (array of float): 
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def addCable(self, name, weightCoef, loadcaseID=None, jackingType=None) -> IFCableTuningLoadcase:
		r"""
		Add the specified cable. 
		Params:
			name (str): cable name
			weightCoef (float): weight coefficient
			loadcaseID (int, optional): ID of an existing loadcase to use for this cable (default = -1 means create a new one)
			jackingType (str, optional): which end of the cable receives the jacking
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def removeCables(self) -> IFCableTuningLoadcase:
		r"""
		Remove all cables 
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def removeOptimisationCriteria(self) -> IFCableTuningLoadcase:
		r"""
		Remove all optimisation criteria 
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def addOptimisationCriterion(self, type, name, entity, component, factor) -> IFCableTuningLoadcase:
		r"""
		Add the specified optimisation criterion. The criterion will serve as the constraint in the optimisation equation set 
		Params:
			type (str): location type; valid values are: "point", "line start", "line end".
			name (str): location name
			entity (str): results entity
			component (str): results component
			factor (float): weighting factor
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def addOptimisationCriteria(self, types, names, entitys, components, factors) -> IFCableTuningLoadcase:
		r"""
		Add the specified optimisation criteria set. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			factors (array of float): array of weighting factors
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def getOptimisationCriteria(self, types, names, entitys, components, factors) -> IFCableTuningLoadcase:
		r"""
		Get the specified optimisation criteria. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			factors (array of float): array of weighting factors
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def setOptimisation(self, solutionType, method=None) -> IFCableTuningLoadcase:
		r"""
		Set optimisation parameters. 
		Params:
			solutionType (str): solution type; valid values are: "exact", "optimised", "best fit".
			method (str, optional): optimisation method; obligatory parameter if solution type is "optimised" or "best fit"; For optimised, valid values are: For best fit, valid values are: "Minimise Largest", "Minimise Sum", "Minimise Specified", "Maximise Sum", and "Maximise Specified". For best fit, valid values are "least squares" and "chebyshev".
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def validateInput(self) -> bool:
		r"""
		Check data consistency, returning zero if the data is valid, and writing a message to the text output window if it is not. 
		Returns:
			bool: 
		"""
		pass


	def setTreeLocation(self, name, initiallyExpanded=None) -> None:
		r"""
		Specifies a folder to act as the last part of the tree location where this loadset will be shown. If the folder does not already exist, it will be created. For example, by calling this function with the word "Special", this loadset would be shown in the tree in "Loadcases/Special". This enables the user to categorise or group together certain loadsets for whatever purpose. Calling with an empty string puts the loadset back where it would normally live. Optionally, you may pass in a boolean to specify whether the new folder is created 'open' or 'closed' - i.e. whether the contents are expanded or not. 
		Params:
			name (str): 
			initiallyExpanded (bool, optional): default true (= open/expanded)
		Returns:
			None: 
		"""
		pass


	def setTreeParent(self, ID, resFile=None, eigen=None, harm=None) -> IFLoadset:
		r"""
		Choose another loadset to act in the treeview as the logical parent of this loadset. In other words, move this loadset within the given loadset in the treeview. This is particularly useful for nesting combinations or envelopes, where only the 'outer' loadset is useful in its own right, but the ones 'within' are needed for calculation purposes.  
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			IFLoadset: 
		"""
		pass


	def moveAfter(self, ID, updateCombs=None) -> IFCableTuningLoadcase:
		r"""
		Move this loadcase to be below the given loadcase in the LUSAS datafile 
		Params:
			ID (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object.
			updateCombs (bool, optional): update combinations and envelopes to reflect the change?
		Returns:
			IFCableTuningLoadcase: 
		"""
		pass


	def createCopy(self, analysis, loadcase=None, update=None, copyMaterials=None) -> IFLoadcase:
		r"""
		Creates a clone loadcase 
		Params:
			analysis (IFAnalysisBaseClass): The name or ID of a "Analysis", or a pointer to a IFAnalysisBaseClass object. Analysis in which to create copy
			loadcase (IFLoadcase, optional): The name or ID of a "Loadcase", or a pointer to a IFLoadcase object. Loadcase after which the copy will be inserted (if NULL, insert at the beginning).
			update (bool, optional): Set this to true to update combinations and envelopes to reflect the re-ordering change
			copyMaterials (str, optional): "copy","no copy","inherit" material and composite assignments
		Returns:
			IFLoadcase: the new loadcase that has been created
		"""
		pass


	def isFirst(self, type=None) -> bool:
		r"""
		Return true if this loadcase will be tabulated first More accurately, return false if a loadcase of the given type will be tabulated before this one. Note that the first loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you really want to know about any loadcase before this one, regardless of type, pass in -1. If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			bool: 
		"""
		pass


	def isLast(self, type=None) -> bool:
		r"""
		Return true if this loadcase will be tabulated last More accurately, return false if a loadcase of the given type will be tabulated after this one. Note that the last loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you really want to know about any loadcase after this one, regardless of type, pass in -1. If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			bool: 
		"""
		pass


	def getPrevious(self, type=None) -> IFLoadset:
		r"""
		Return the loadcase that will be tabulated before this one (it is an error to call on the first one) Note that the previous loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you really want the previous one, regardless of type, pass in -1. If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			IFLoadset: 
		"""
		pass


	def getNext(self, type=None) -> IFLoadset:
		r"""
		Return the loadcase that will be tabulated after this one (it is an error to call on the last one) Note that the next loadset might be an IFLoadcase or an IFCableTuningLoadcase (or some other type that LUSAS may invent in a future release). If you know the type you are interested in, pass in that type, and this func will disregard any loadsets of other types 
		Params:
			type (int, optional): loadcase type (default = 0 = loadcase)
		Returns:
			IFLoadset: 
		"""
		pass


	def setDoSolve(self, tabulate) -> IFLoadset:
		r"""
		Sets flag indicating if this loadcase will be processed by solver when the parent analysis is solved. Note this flag will be ignored unless IFTabulateDataObj.setSolveAllLoadcases(false) is also called. 
		Params:
			tabulate (bool): 
		Returns:
			IFLoadset: 
		"""
		pass


class IFCableTuningAnalysis(IFAnalysisBaseClass):
	"""
	A cable tuning analysis is essentially identical to a IFLoadsetTargetValues, except that the variable loadcases and loading are automatically calculated for you. You specify only the lines that represent cables. A cable tuning analysis holds a cable tuning results object that does the actual optimisation work, represents the results, can be used in combinations, envelopes, etc. It also holds some automatically created loadcases that represent the individual cables 
	"""

	def getResults(self) -> IFCableTuningResults:
		r"""
		Access the cable tuning results that reside within this analysis This object may be added to combinations, envelopes, etc 
		Returns:
			IFCableTuningResults: 
		"""
		pass


	def removeEntries(self) -> IFCableTuningAnalysis:
		r"""
		Remove all input loadcases. These loadcases are considered in the optimisation, but are not modified by it. 
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addEntry(self, factorType, signeType, constantFactor, variableFactor, ID, resFile=None, eigen=None, harm=None) -> IFCableTuningAnalysis:
		r"""
		Add the specified loadcase. This loadcase will be considered in the optimisation, but are not modified by it.  
		Params:
			factorType (str): factor type ("Variable" or "Constant")
			signeType (str): signe type ("Positive only" or "Allow negative")
			constantFactor (float): multiplier of constant variable (loadset)
			variableFactor (float): multiplier of variable (loadset)
			ID (object): IFLoadset object, loadset ID or loadset name. loadset ID
			resFile (int, optional): default = 0; results file ID
			eigen (int, optional): default = -1; eigen ID
			harm (int, optional): default = -1; harmonic ID
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addEntries(self, factorTypes, signTypes, constantFactors, variableFactors, IDs, resFiles=None, eigens=None, harms=None) -> IFCableTuningAnalysis:
		r"""
		Add the specified loadcases. These loadcases will be considered in the optimisation, but are not modified by it.  
		Params:
			factorTypes (array of strs): array of factor types
			signTypes (array of strs): array of sign types
			constantFactors (array of float): array of multipliers
			variableFactors (array of float): array of multipliers
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names. array of loadsets ID
			resFiles (array of ints, optional): array of results files ID
			eigens (array of ints, optional): array of eigens ID
			harms (array of ints, optional): array of harmonics ID
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def removeTargets(self) -> IFCableTuningAnalysis:
		r"""
		Remove all targets. 
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addTarget(self, type, name, entity, component, condition, value) -> IFCableTuningAnalysis:
		r"""
		Add the specified target. 
		Params:
			type (str): location type; valid values are: "point", "line start", "line end".
			name (str): location name
			entity (str): results entity
			component (str): results component
			condition (str): comparison condition; valid values are: "<<=", "=", ">="
			value (float): target value
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addTargets(self, types, names, entitys, components, conditions, values) -> IFCableTuningAnalysis:
		r"""
		Add the specified targets. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			conditions (array of strs): array of target values
			values (array of float): 
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def getTargets(self, types, names, entitys, components, conditions, values) -> IFCableTuningAnalysis:
		r"""
		Get the specified targets. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			conditions (array of strs): array of target values
			values (array of float): 
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def getLoadcaseIDs(self) -> list[int]:
		r"""
		Return, as an array, the IDs of the automatically created loadcases within this cable tuning analysis 
		Returns:
			array of ints: 
		"""
		pass


	def getResultsFileIDs(self) -> list[int]:
		r"""
		Return, as an array, the result file IDs of the loadcases within this cable tuning analysis 
		Returns:
			array of ints: 
		"""
		pass


	def getEigenvalueIDs(self) -> list[int]:
		r"""
		Return, as an array, the eigenvalue IDs of the loadcases within this cable tuning analysis 
		Returns:
			array of ints: 
		"""
		pass


	def getHarmonicIDs(self) -> list[int]:
		r"""
		Return, as an array, the harmonic IDs of the loadcases within this cable tuning analysis 
		Returns:
			array of ints: 
		"""
		pass


	def getFactorTypes(self) -> list[str]:
		r"""
		Return, as an array, the target factor types applied to the loadcases within this cable tuning analysis 
		Returns:
			array of strs: 
		"""
		pass


	def getSignTypes(self) -> list[str]:
		r"""
		Return, as an array, the target sign types applied to the loadcases within this cable tuning analysis 
		Returns:
			array of strs: 
		"""
		pass


	def getConstantFactors(self) -> list[float]:
		r"""
		Return, as an array, the target constant factors applied to the loadcases within this cable tuning analysis 
		Returns:
			array of float: 
		"""
		pass


	def getVariableFactors(self) -> list[float]:
		r"""
		Return, as an array, the target variable factors applied to the loadcases within this cable tuning analysis 
		Returns:
			array of float: 
		"""
		pass


	def removeOptimisationCriteria(self) -> IFCableTuningAnalysis:
		r"""
		Remove all optimisation criteria 
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addOptimisationCriterion(self, type, name, entity, component, factor) -> IFCableTuningAnalysis:
		r"""
		Add the specified optimisation criterion. 
		Params:
			type (str): location type; valid values are: "point", "line start", "line end".
			name (str): location name
			entity (str): results entity
			component (str): results component
			factor (float): weighting factor
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addOptimisationCriteria(self, types, names, entitys, components, factors) -> IFCableTuningAnalysis:
		r"""
		Add the specified optimisation criteria set. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			factors (array of float): array of weighting factors
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def getOptimisationCriteria(self, types, names, entitys, components, factors) -> IFCableTuningAnalysis:
		r"""
		Get the specified optimisation criteria. 
		Params:
			types (array of strs): array of location types
			names (array of strs): array of location names
			entitys (array of strs): array of results entities
			components (array of strs): array of results components
			factors (array of float): array of weighting factors
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def setOptimisation(self, solutionType, method=None) -> IFCableTuningAnalysis:
		r"""
		Set optimisation parameters. 
		Params:
			solutionType (str): solution type; valid values are: "exact", "optimised", "best fit".
			method (str, optional): optimisation method; obligatory parameter if solution type is "optimised" or "best fit"; For optimised, valid values are: For best fit, valid values are: "Minimise Largest", "Minimise Sum", "Minimise Specified", "Maximise Sum", and "Maximise Specified". For best fit, valid values are "least squares" and "chebyshev".
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def optimise(self, factors=None) -> int:
		r"""
		Perform the optimisation, calculating a factor for each cable 
		Params:
			factors (array of real, optional): If given, and if optimisation succeeds, sized and filled with the calculated factors
		Returns:
			int: zero for success, non-zero indicates failure
		"""
		pass


	def removeCables(self) -> IFCableTuningAnalysis:
		r"""
		Remove all cables 
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addCable(self, name, weightCoef, loadcaseID=None, jackingType=None) -> IFCableTuningAnalysis:
		r"""
		Add the specified cable. 
		Params:
			name (str): cable name
			weightCoef (float): weight coefficient
			loadcaseID (int, optional): ID of an existing loadcase to use for this cable (default = -1 means create a new one)
			jackingType (str, optional): which end of the cable receives the jacking
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def addCables(self, names, weightCoefs) -> IFCableTuningAnalysis:
		r"""
		Add the specified cables. 
		Params:
			names (array of strs): array of cable names
			weightCoefs (array of float): array of weight coefficients
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def getCables(self, names, weightCoefs) -> IFCableTuningAnalysis:
		r"""
		Get the specified cables. 
		Params:
			names (array of strs): array of cable names
			weightCoefs (array of float): array of weight coefficients
		Returns:
			IFCableTuningAnalysis: 
		"""
		pass


	def unwrap(self, analysisName, loadcaseName=None) -> IFLoadsetTargetValues:
		r"""
		Create a new target value loadset that has the same definition as this analysis, creating copies of all the cable loading and loadcases. 
		Params:
			analysisName (str): Analysis name
			loadcaseName (str, optional): Name of the new target value loadcase
		Returns:
			IFLoadsetTargetValues: 
		"""
		pass


	def createCombination(self) -> IFBasicCombination:
		r"""
		Create a new combination from this analysis, referencing all the cable loadcases, and factoring each according to the factors calculated within this analysis. 
		Returns:
			IFBasicCombination: 
		"""
		pass


	def createLoadcase(self, analysisName, loadcaseName=None) -> IFLoadcase:
		r"""
		Create a new loadcase from this analysis, copying all the loading, and factoring each according to the factors calculated within this analysis. The new loadcase must be placed within a different analysis 
		Params:
			analysisName (str): Analysis name where the new loadcase will be created
			loadcaseName (str, optional): Name of the new loadcase
		Returns:
			IFLoadcase: 
		"""
		pass


	def validateInput(self) -> bool:
		r"""
		Check data consistency, returning zero if the data is valid, and writing a message to the text output window if it is not. 
		Returns:
			bool: 
		"""
		pass


class IFCableTuningResults(IFLoadset):
	"""
	The underlying implementation of cable tuning, within an IFCableTuningAnalysis object. 
	"""

	pass


class IFGraphWizard(IFGraphBase):
	"""
	interface to create a graph that supports after creation editing 
	"""

	def reset(self) -> None:
		r"""
		resets its data so for this to be re-created from scratch 
		Returns:
			None: 
		"""
		pass


	def setCurve(self, style, showArray) -> None:
		r"""
		sets curve style and curve's visibility option 
		Params:
			style (str): 
			showArray (array of bools): 
		Returns:
			None: 
		"""
		pass


	def addExistingGraph(self, graphName) -> None:
		r"""
		adds an existing graph to be merged with this 
		Params:
			graphName (str): 
		Returns:
			None: 
		"""
		pass


	def showLabels(self) -> None:
		r"""
		Displays graph labels 
		Returns:
			None: 
		"""
		pass


	def hideLabels(self) -> None:
		r"""
		Hides graph labels 
		Returns:
			None: 
		"""
		pass


	def setFactors(self, factorX, factorY) -> None:
		r"""
		Sets the graph factors 
		Params:
			factorX (float): 
			factorY (float): 
		Returns:
			None: 
		"""
		pass


	def setAutoUpdate(self, autoUpdate) -> None:
		r"""
		sets the option for the graphs to be created dynamically from the graph wizard 
		Params:
			autoUpdate (bool): 
		Returns:
			None: 
		"""
		pass


	def setDisplayNow(self, displayNow) -> None:
		r"""
		sets "display now" option for the wizards interface 
		Params:
			displayNow (bool): 
		Returns:
			None: 
		"""
		pass


	def showSymbols(self, show) -> None:
		r"""
		shows or hides the dot symbol from the grah curves 
		Params:
			show (bool): 
		Returns:
			None: 
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Sets object name 
		Params:
			newName (str): 
		Returns:
			None: 
		"""
		pass


	def createFromSpecified(self, xGraphDataset, yGraphDataset) -> None:
		r"""
		 
		Params:
			xGraphDataset (name, dataset, IFAttribute): dataset to be used for the X direction
			yGraphDataset (name, dataset ,IFAttribute): dataset to be used for the Y direction
		Returns:
			None: 
		"""
		pass


	def createFromSpecifiedHistory(self, graphDataset) -> None:
		r"""
		 
		Params:
			graphDataset (name, dataset, IFAttribute): dataset to be used
		Returns:
			None: 
		"""
		pass


	def setLoadcaseSelectionType(self, loadcaseSelection) -> None:
		r"""
		Sets whether the graph is for the "active" loadcase, for "all" loadcases or for "specified" loadcases. 
		Params:
			loadcaseSelection (str): 
		Returns:
			None: 
		"""
		pass


	def setSelectedLoadcases(self, lcArray, lcArrayResFile, lcArrayEigenvalue=None, lcArrayHarmonic=None) -> None:
		r"""
		Set the selected loadcases in case of "specified" selection type 
		Params:
			lcArray (array of load case ids or names): 
			lcArrayResFile (array of load case result file ids or locations): 
			lcArrayEigenvalue (array of load case eigen value ids, optional): 
			lcArrayHarmonic (array of load case harmonic ids, optional): 
		Returns:
			None: 
		"""
		pass


	def createNewWindowForEachLoadcase(self, multipleWindows) -> None:
		r"""
		If set to True and more than one loadcases have been selected which they affect this graph, each one will be displayed in a different window rather than all merged into one. 
		Params:
			multipleWindows (bool): 
		Returns:
			None: 
		"""
		pass


	def getCurveByID(self, id) -> IFGraphWizardCurve:
		r"""
		Retrieve a curve from this graph by its internally allocated ID. 
		Params:
			id (int): ID to search for
		Returns:
			IFGraphWizardCurve: The returned curve
		"""
		pass


	def setPrimaryResultsData(self, primaryComponents, primaryEntities) -> None:
		r"""
		Set primary components and entities for the corresponding selected loadcases if needed 
		Params:
			primaryComponents (array of strs): primary component names
			primaryEntities (array of strs): primary entity names
		Returns:
			None: 
		"""
		pass


	def createCopy(self, name) -> IFAttribute:
		r"""
		Creates a new attribute in the same database as "this" attribute with the given new name, but which is otherwise a copy of "this" attribute 
		Params:
			name (str): name of attribute to create
		Returns:
			IFAttribute: newly created attribute
		"""
		pass


class IFGraph(IFGraphBase):
	"""
	 
	"""

	def setSourceAttrName(self, name) -> None:
		r"""
		In case this graph has been created from a graph wizard attribute call this function to connect the graph with the wizard 
		Params:
			name (str): graph wizard attribute name
		Returns:
			None: 
		"""
		pass


	def closeHistory(self, filename) -> None:
		r"""
		Close results history file 
		Params:
			filename (str): History filename
		Returns:
			None: 
		"""
		pass


	def closeAllHistory(self) -> None:
		r"""
		Close all results history files 
		Returns:
			None: 
		"""
		pass


	def close(self) -> None:
		r"""
		Closes the graph, discarding any changes 
		Returns:
			None: 
		"""
		pass


	def savePicture(self, filename, type=None) -> None:
		r"""
		Save the image of the graph as a bitmap for inclusion in reports etc. 
		Params:
			filename (str): 
			type (str, optional): 
		Returns:
			None: 
		"""
		pass


	def maximizeCompoundDisplay(self) -> None:
		r"""
		Set CompoundDisplay to full size, this is useful to create image with graph taking full size 
		Returns:
			None: 
		"""
		pass


	def saveAs(self, fileName, fileType, activeOnly) -> None:
		r"""
		Save all grid tabs that display the data to file 
		Params:
			fileName (str): name of the file to create
			fileType (str): file type; two possible values: 'Microsoft Excel' or 'Text'
			activeOnly (bool): true to save the active tab only, false to save all tabs.
		Returns:
			None: 
		"""
		pass


	def addCurve(self, X=None, Y=None, factorX=None, factorY=None) -> IFCurve:
		r"""
		Add a curve to an existing graph. If no input is given, an empty curve is added for later modification. If either x or y is specified, both must be. In each case, data can be specified as the name, ID, or a pointer to an IFDataset object, or a raw array of real numbers. There is no requirement to provide x data in the same format as y data, but the number of data points must be the same. Optionally a multiplication factor may be given, which can be used to exaggerate the y values (it has no effect on the x values) 
		Params:
			X (IFDataset, optional): The name or ID of a graphdataset, or a pointer to a IFDataset object. graph dataset for X
			Y (IFDataset, optional): The name or ID of a graphdataset, or a pointer to a IFDataset object. graph dataset for Y
			factorX (float, optional): multiplier for X
			factorY (float, optional): multiplier for Y
		Returns:
			IFCurve: The curve created
		"""
		pass


	def getCurveByID(self, curveID) -> IFCurve:
		r"""
		Retrieve a curve from this graph by its internally allocated ID. It is an error to call this function with an ID which does not exist 
		Params:
			curveID (int): ID to search for
		Returns:
			IFCurve: The returned curve
		"""
		pass


	def countCurves(self) -> int:
		r"""
		return the number of curves currently present within this graph 
		Returns:
			int: The returned number of curves
		"""
		pass


	def getCurves(self) -> list[IFCurve]:
		r"""
		Return an array containing all the curves currently present within this graph 
		Returns:
			array of IFCurve objects: The returned curves
		"""
		pass


	def getCurveByLegend(self, curveLegend) -> IFCurve:
		r"""
		Retrieve a curve from this graph by the legend previously attached to it with IFGraphWizardCurve.setLegendText. It is an error to call this function with a legend which does not exist 
		Params:
			curveLegend (str): Legend to search for
		Returns:
			IFCurve: The returned curve
		"""
		pass


	def getID(self) -> int:
		r"""
		Returns graph's ID IDs are program-generated and quite separate from names which the user can change 
		Returns:
			int: the ID
		"""
		pass


	def getResultsTransformData(self, sType, rXYAngle, extraInfo1, extraInfo2) -> None:
		r"""
		Get the transformation settings that are stored with this graph 
		Params:
			sType (str): 
			rXYAngle (float): only useful when type is "XY angle"
			extraInfo1 (IFLocalCoord or IFReferencePath or str): Will be set to a local coord if type is "Local coord" or to a path if type is "Path", or to a string if type is "Attribute type", otherwise not used
			extraInfo2 (int): Will be set to the shell plane  if type is "Local coord" or to a boolean skewed/not skewed if type is "Path", otherwise not used
		Returns:
			None: 
		"""
		pass


	def maximise(self) -> None:
		r"""
		Maximize the graph window such that it fills all the available drawing area 
		Synonyms:
			maximize
		Returns:
			None: 
		"""
		pass


	def maximize(self) -> None:
		r"""
		Maximize the graph window such that it fills all the available drawing area 
		Returns:
			None: 
		"""
		pass


	def bringToFront(self) -> None:
		r"""
		Brings the graph window to the front of the Windows Z order. 
		Returns:
			None: 
		"""
		pass


	def setActiveLoadset(self, ID, resFile=None, eigen=None, harm=None) -> None:
		r"""
		Specify which loadcase is used for graphing If not set, the view's active one will be used 
		Params:
			ID (object): IFLoadset object, loadset ID or loadset name.
			resFile (int, optional): default = 0
			eigen (int, optional): default = -1
			harm (int, optional): default = -1
		Returns:
			None: 
		"""
		pass


class IFPrintResultsWizard(IFAttribute):
	"""
	Interface to store and restore settings for printing results 
	"""

	def showResults(self, once=None) -> IFGridWindow:
		r"""
		Displays the results in Modeller's GUI If 'once' is set to TRUE then the attribute will be temporary and will be deleted as soon as the user closes the result tables 
		Params:
			once (bool, optional): 
		Returns:
			IFGridWindow: 
		"""
		pass


	def setResultsType(self, type) -> IFPrintResultsWizard:
		r"""
		Sets the results type 
		Params:
			type (str): "Components" or "EigenValues"
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setResultsOrder(self, order) -> IFPrintResultsWizard:
		r"""
		Sets the results order 
		Params:
			order (str): results type "Loadcase", "Feature" or "Mesh"
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setResultsContent(self, content) -> IFPrintResultsWizard:
		r"""
		Sets the results content 
		Params:
			content (str): results content "Tabular", "Summary" or "Tabular and Summary"
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setAllDefaults(self) -> IFPrintResultsWizard:
		r"""
		Sets all default values 
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setLoadcasesOption(self, loadcasesOption) -> IFPrintResultsWizard:
		r"""
		Sets the interface option for the selected loadcases. If "specified" is chosen then IFPrintResultsWizard.setLoadcases needs to be called as well. 
		Params:
			loadcasesOption (str): "All", "Active", "Selected", "Final increment"
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setComponents(self, components) -> IFPrintResultsWizard:
		r"""
		Set the components. If "nothing" is passed, then all the components will be output 
		Params:
			components (array of strs): component names
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setPrimaryComponents(self, primaryComponents) -> IFPrintResultsWizard:
		r"""
		Set primary components for coincident effects. If "nothing" is passed, no primary components will be used. The default entity will be used for these. 
		Params:
			primaryComponents (array of strs): primary component names
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setPrimaryResultsData(self, primaryComponents, primaryEntities) -> IFPrintResultsWizard:
		r"""
		Set primary components and the entities for these for coincident effects. 
		Params:
			primaryComponents (array of strs): primary component names
			primaryEntities (array of strs): primary entity names
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setAnalysisResultTypes(self, types) -> IFPrintResultsWizard:
		r"""
		In case of "eigenvalues" type, set the output for the analysis result types 
		Params:
			types (array of strs): "Eigenvalues", "Participating factors", "Mass participating factors", "Sum of mass Participating factors"
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setLoadcases(self, lcArrayID, lcArrayResFileID, lcArrayEigenvalueID, lcArrayHarmonicID) -> IFPrintResultsWizard:
		r"""
		Set loadcases 
		Params:
			lcArrayID (array of load case Ids): 
			lcArrayResFileID (array of load case result file ids): 
			lcArrayEigenvalueID (array of load case eigen value ids): 
			lcArrayHarmonicID (array of load case harmonic ids): 
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setSigFig(self, nSigFig, trailingZeros=None) -> IFPrintResultsWizard:
		r"""
		Set significant figures 
		Params:
			nSigFig (int): number of significant figures
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setDecimalPlaces(self, nDeciPlaces) -> IFPrintResultsWizard:
		r"""
		Set decimal places 
		Params:
			nDeciPlaces (int): number of decimal places
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setThreshold(self, value) -> IFPrintResultsWizard:
		r"""
		Set a threshold value in order for all values that are less than this to be printed as zero. If the value is given as 'nothing' no threshold value is taken into account. 
		Params:
			value (float): or Nothing
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def showCoordinates(self, isShow) -> IFPrintResultsWizard:
		r"""
		Set flag indicating whether or not to show coordinates data in print results output 
		Params:
			isShow (bool): Indicates whether or not to show coordinates
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def showExtremeResults(self, isShow) -> IFPrintResultsWizard:
		r"""
		Set flag indicating whether or not to show extreme results for envelops and smart combinations 
		Params:
			isShow (bool): 
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setExtent(self, selectionType, groupName) -> IFPrintResultsWizard:
		r"""
		Specify model part to be considered in print results 
		Params:
			selectionType (str): "Elements showing results" | "Full model" | "Visible model" | "Group"
			groupName (str): Group name
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setResultsEntity(self, entity) -> IFPrintResultsWizard:
		r"""
		Sets the results entity 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setResultsLocation(self, location) -> IFPrintResultsWizard:
		r"""
		Sets the results location 
		Params:
			location (str): results location "nodal", "elementNodal", etc
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setSlice(self, isSlice) -> IFPrintResultsWizard:
		r"""
		TRUE is this will be displayed for slice 
		Params:
			isSlice (bool): 
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setResultsTransformNone(self) -> None:
		r"""
		Switches off all results transformation  in print results output 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformElement(self) -> None:
		r"""
		Uses element local axes as the results transformation  in print results output. (For continuous results, such as displacement, nodal axes (transformed freedoms) are used) 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformXYAngle(self, XYAngle) -> None:
		r"""
		Uses the specified angle (in the XY plane - i.e. about Z) as the results transformation for this sub-chapter. 
		Params:
			XYAngle (float): 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformLocal(self, localCoords, shellPlane) -> None:
		r"""
		Uses the specified local coordinate as the results transformation in print results output. 
		Params:
			localCoords (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
			shellPlane (int): Shell plane for resultants (1, 2 or 3)
		Returns:
			None: 
		"""
		pass


	def setResultsTransformPath(self, path, skew=None) -> None:
		r"""
		Uses the specified path as the results transformation for this sub-chapter. 
		Params:
			path (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
			skew (bool, optional): True if local y = transverse
		Returns:
			None: 
		"""
		pass


	def setResultsTransformFeature(self) -> None:
		r"""
		Uses the parent feature's local directions as the results transformation for this sub-chapter. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformGlobal(self) -> None:
		r"""
		Uses the global axes directions as the results transformation for this sub-chapter. 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformAttributeType(self, type) -> None:
		r"""
		Uses the given attribute type to obtain the results transformation for this sub-chapter. 
		Params:
			type (object): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def setDisplayNow(self, displayNow) -> IFPrintResultsWizard:
		r"""
		Sets "display now" option for the wizard interface. 
		Params:
			displayNow (bool): 
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def setAllowDerived(self, allow) -> IFPrintResultsWizard:
		r"""
		Only meaningful when 'all components' has been chosen, and this attribute is targeting envelopes and smart combinations. In that circumstance, this function determines whether or not 'all' includes derived components such as RSLT, SE, S1, SAbs, etc. Computation of such components for some envelopes and smart combinations may give unexpected answers. See the online help for more details 
		Params:
			allow (bool): allow derived components
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def getLoadcases(self) -> list:
		r"""
		Gets the list of loadcases to be reported upon. Note that any loadcases previously specified, but not currently present (e.g. if results are not loaded) will not be in the returned array, but will still form part of the print results wizard 
		Returns:
			Array: Array of loadcase objects
		"""
		pass


	def getLoadcasesOption(self) -> str:
		r"""
		Get the interface option for the selected loadcases. 
		Returns:
			str: "All", "Active", "Selected", "Final increment"
		"""
		pass


	def setUnits(self, units) -> IFPrintResultsWizard:
		r"""
		Sets the units of any results that will be displayed If "Nothing" the model units will be used 
		Params:
			units (str or IFUnitSet): Unit set to use.
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


	def showActiveNodesOnly(self, showActiveNodesOnly) -> IFPrintResultsWizard:
		r"""
		Sets whether to show results only on active nodes or even on inactive, subject to results being continuous 
		Params:
			showActiveNodesOnly (bool): whether to show results only on active nodes or also on inactive
		Returns:
			IFPrintResultsWizard: 
		"""
		pass


class IFSavedView(IFAttribute):
	"""
	interface to store and restore the view settings 
	"""

	def updateFromView(self, pView) -> None:
		r"""
		Updates this utility from the configuration of the given view. 
		Params:
			pView (IFView): 
		Returns:
			None: 
		"""
		pass


	def updateFromCurrentView(self) -> None:
		r"""
		Updates this utility from the configuration of the current view. 
		Returns:
			None: 
		"""
		pass


	def applyToView(self, pView) -> None:
		r"""
		Updates the given view from the configuration that has been stored in this utility. 
		Params:
			pView (IFView): 
		Returns:
			None: 
		"""
		pass


	def applyToCurrentView(self) -> None:
		r"""
		Updates the current view from the configuration that has been stored in this utility. 
		Returns:
			None: 
		"""
		pass


	def doLayers(self, bCopy) -> None:
		r"""
		Whether or not to copy the drawing layers of this utility to the view being modified. 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def doRotation(self, bCopy) -> None:
		r"""
		Whether or not to copy the rotation of this utility to the view that this will be applied. 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def doPageSize(self, bCopy) -> None:
		r"""
		Whether or not to copy the page size and the borders of this utility to the view being modified. 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def doColour(self, bCopy) -> None:
		r"""
		Whether or not to copy the colour scheme of this utility to the view being modified. 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def doZoom(self, bCopy) -> None:
		r"""
		Whether or not to copy the pan and zoom scheme of this utility to the view being modified. (incompatible with IFSavedView.doScaled) 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def doScaled(self, bCopy) -> None:
		r"""
		Whether or not this utility creates 'scaled to fit' pictures (incompatible with IFSavedView.doZoom) 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def doPenLib(self, bCopy) -> None:
		r"""
		Whether or not to copy the pen library of this utility to the view being modified (this option affects all views in this database). 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def doProjection(self, bCopy) -> None:
		r"""
		Whether or not to copy the projection of this utility to the view being modified (this option affects all views in this database). 
		Params:
			bCopy (bool): 
		Returns:
			None: 
		"""
		pass


	def setWindowSizes(self, width, height) -> None:
		r"""
		Set the sizes of the window that hosts the view. This will not affect the sizes of the window that the saved view will be applied later but it is crucial for the creation of the bitmaps from this view. 
		Params:
			width (int): 
			height (int): 
		Returns:
			None: 
		"""
		pass


class IFNote(IFAttribute):
	"""
	interface to store and restore plain text 
	"""

	def setText(self, text) -> None:
		r"""
		Sets the note text. 
		Params:
			text (str): Note's text
		Returns:
			None: 
		"""
		pass


	def getText(self) -> str:
		r"""
		Gets the note text. 
		Returns:
			str: 
		"""
		pass


class IFArbitrarySection(IFAttribute):
	"""
	Arbitrary section utility interface 
	"""

	def setProperties(self, props) -> IFArbitrarySection:
		r"""
		Set the section properties of the arbitrary section. Use the follow indexes 0:  Area         - Section Area 1:  Iyy          - Moment of inertia about y 2:  Izz          - Moment of inertia about 3:  Iyz          - Product moment of inertia 4:  J            - Torsion constant 5:  Asy          - Shear area in y 6:  Asz          - Shear area in z 7:  Unused 8:  Unused 9:  Unused 10: Unused 11: Cw           - Warping constant 12: yo           - Shear centre y distance from centroid 13: zo           - Shear centre z distance from centroid 14: yp           - Plastic neutral axis y distance from centroid 15: zp           - Plastic neutral axis z distance from centroid 16: Zpy          - Plastic bending moment about y 17: Zpz          - Plastic bending moment about z 18: Zpt          - Plastic torsion modulus 19: Unused 20: betay        - Mono symmetry constant about y 21: betaz        - Mono symmetry constant about z 22: Iyr 23: Izr 24: Irr 25: Iwr 
		Params:
			props (array of float): 
		Returns:
			IFArbitrarySection: 
		"""
		pass


	def addMaterial(self, materialID, youngsModulus, poissonsRatio, density) -> IFArbitrarySection:
		r"""
		Sets the component material properties used for mixed material sections 
		Params:
			materialID (int): material ID number
			youngsModulus (float): Young's Modulus
			poissonsRatio (float): Poisson's Ratio
			density (float): Mass density
		Returns:
			IFArbitrarySection: 
		"""
		pass


	def setRefMaterial(self, materialID) -> IFArbitrarySection:
		r"""
		Sets the material used as the reference material for section properties for mixed material sections 
		Params:
			materialID (int): material ID to use as reference material
		Returns:
			IFArbitrarySection: 
		"""
		pass


	def setOutline(self, outline) -> IFArbitrarySection:
		r"""
		Sets the outline definition from data at the end of the csv file 
		Params:
			outline (array of strs): 
		Returns:
			IFArbitrarySection: 
		"""
		pass


	def removeAllFleshingPolygons(self) -> IFArbitrarySection:
		r"""
		remove all fleshing polygons from this section 
		Returns:
			IFArbitrarySection: 
		"""
		pass


	def addFleshingPolygon(self, polygonCrds, materialID=None) -> IFArbitrarySection:
		r"""
		add a fleshing polygon to this section 
		Params:
			polygonCrds (array of float): polygon coordinates x1,y1,x2,y2,x3,y4...
			materialID (int, optional): polygon material ID for mixed material sections
		Returns:
			IFArbitrarySection: 
		"""
		pass


	def fromDatabase(self, pDatabase, surfacesToExclude=None, haveExpectedValues=None, expectedValues=None) -> IFArbitrarySection:
		r"""
		Assumes that the given database represents a section, creates an arbitrary section utility from that database and calculates the properties 
		Params:
			pDatabase (IFDatabase): 
			surfacesToExclude (array of ints, optional): surface numbers to exclude from the calculation
			haveExpectedValues (array of bools, optional): if true compare the expected value to the calculated section property
			expectedValues (array of floats, optional): expected section property value
		Returns:
			IFArbitrarySection: 
		"""
		pass


	def getSectionProperties(self) -> list[float]:
		r"""
		Returns an array on property values The return value is an array of real values 
		Returns:
			array of float: Returned array of properties
		"""
		pass


	def getSectionPropertyNames(self) -> list[str]:
		r"""
		Returns an array on property value names The return value is an array of strings 
		Returns:
			array of strs: Returned array of properties; eg A,Ixx,Iyy etc
		"""
		pass


class IFParametricSection(IFAttribute):
	"""
	Section utility interface 
	"""

	def setType(self, type) -> IFParametricSection:
		r"""
		Set the section type. The following are valid types "Rectangular Solid", "Rectangular Hollow", "Circular Solid", "Circular Hollow", "I", "L", "T", "Castellated", "C", "C (Lipped)", "I (Unequal Flange)", "Rectangular Hollow (unequal thicknesses)", "Z", "Z (Lipped)", "Z (Inclined Lipped)", "Hat", "Haunch", "Double C (Back to Back)", "Double C (Face to Face)", "Double L (Back to Back)", "Infill/Encased", "Rounded Rectangular Solid", "Complex Box (Camber, Without Void)", "Complex Box (Camber, Single Cell)", "Complex Box (Camber, Two Cells) ", "Complex Box (Camber, Multiple Cells)", "Simple Box (Without Void)", "Simple Box (Single Cell)", "Simple Box (Two Cells)", "Simple Box (Multiple Cells)", "Complex Box (Without Void)", "Complex Box (Single Cell)", "Complex Box (Two Cells) ", "Complex Box (Multiple Cells)", "I (k, Tapered flanges)", "T (k, Tapered flanges)", "C (k, Tapered flanges)", "I (Tapered flanges)", "T (Tapered flanges)", "C (Tapered flanges)", "I (Lipped)", "L (External radius)", "C (External radius)", "C (Unequal Flange)", "Elliptical Hollow", "Hexagonal Solid", "Hexagonal Hollow", "Octagonal Solid", "Trapezoidal Hollow", "Cross I", "Combined T", "Stiffened Box", "Stiffened Pipe", "Elliptical Solid", "Riveted I", "Riveted Box", "Welded Plate Box", "I with Doubler Plates", "I with C", "Riveted Box from C (Back to Back)", "Riveted Box from C (Face to Face)", "Riveted Box from I", "Riveted Trough", "Riveted Cruciform", "Riveted T", "General Parametric", 
		Params:
			type (str): 
		Returns:
			IFParametricSection: 
		"""
		pass


	def getType(self) -> str:
		r"""
		Set the section type e.g. "Circular Solid". See IFParametricSection.setType To return section shape code as <long>, use getValue("type") 
		Returns:
			str: 
		"""
		pass


	def setDimension(self, name, value) -> IFParametricSection:
		r"""
		Set the value of a dimension by its name 
		Params:
			name (str): 
			value (float): 
		Returns:
			IFParametricSection: 
		"""
		pass


	def setDimensions(self, names, values) -> IFParametricSection:
		r"""
		Set all the dimension values by their corresponding names 
		Params:
			names (object): array of dimensions name
			values (object): corresponding array of dimensions
		Returns:
			IFParametricSection: 
		"""
		pass


	def getGroup(self) -> str:
		r"""
		Return the name of the group that the section belongs e.g. "Rectangular Sections" 
		Returns:
			str: 
		"""
		pass


	def getSectionProperties(self) -> list[float]:
		r"""
		Returns an array on property values The return value is an array of real values 
		Returns:
			array of float: Returned array of properties
		"""
		pass


	def getSectionPropertyNames(self) -> list[str]:
		r"""
		Returns an array on property value names The return value is an array of strings 
		Returns:
			array of strs: Returned array of properties; eg A,Ixx,Iyy etc
		"""
		pass


class IFCurve(IFGraphWizardCurve):
	"""
	Each instance of this class represents one curve in a graph window. Each curve is defined by a sequence of x,y pairs - each pair is one point on the graph. 
	"""

	def getID(self) -> int:
		r"""
		Returns curve's ID. IDs are program-generated and quite separate from names which the user can change. In practice, the ID corresponds to creation order. 
		Returns:
			int: the ID
		"""
		pass


	def countDataPairs(self) -> int:
		r"""
		Return the number of pairs previously added by IFCurve.addDataPair or IFCurve.addDataArrayPair 
		Returns:
			int: 
		"""
		pass


	def getDataPair(self, iPoint, X, Y) -> None:
		r"""
		Return an x,y pair previously added by IFCurve.addDataPair or IFCurve.addDataArrayPair 
		Params:
			iPoint (int): An index in the range 0..IFCurve.countDataPairs()-1
			X (float): 
			Y (float): 
		Returns:
			None: 
		"""
		pass


	def addDataPair(self, xValue, yValue) -> None:
		r"""
		Add just one x,y point to the curve. Data pairs must be added in order, they will NOT be sorted automatically (as this would be erroneous in some graphs) 
		Params:
			xValue (float): 
			yValue (float): 
		Returns:
			None: 
		"""
		pass


	def addDataArrayPair(self, X, Y) -> None:
		r"""
		Add an array of x,y points to the curve. Data pairs must be in the desired order, they will NOT be sorted automatically (as this would be erroneous in some graphs). 
		Params:
			X (array of float): 
			Y (array of float): 
		Returns:
			None: 
		"""
		pass


	def endDataAdd(self) -> None:
		r"""
		This function causes Modeller to redraw the graph window. As a performance optimisation for large graphs, Modeller does not redraw the window each time you call IFCurve.addDataPair() Therefore this function must be called when you have finished adding data pairs to the graph. Failure to call this function will result in an out-of-date graph. Calling this function multiple times will slow the program down. 
		Returns:
			None: 
		"""
		pass


	def deleteFromGraph(self) -> None:
		r"""
		Deletes this curve and removes it from its parent graph. 
		Returns:
			None: 
		"""
		pass


	def setCurveColour(self, red, green, blue) -> None:
		r"""
		Sets colour of curve line and symbols using rgb values 
		Params:
			red (int): 0..255
			green (int): 0..255
			blue (int): 0..255
		Returns:
			None: 
		"""
		pass


	def xDataName(self, xDataName) -> None:
		r"""
		Sets the title for the x data 
		Params:
			xDataName (str): 
		Returns:
			None: 
		"""
		pass


	def yDataName(self, yDataName) -> None:
		r"""
		Sets the title for the y data 
		Params:
			yDataName (str): 
		Returns:
			None: 
		"""
		pass


class IFSelectLoadsetsDialog(IFDialog):
	"""
	Interface to modeller's standard 'select loadsets' dialog Such a dialog is created using IFModeller.createSelectLoadsetDialog 
	"""

	def setAvailableLoadsets(self, IDs, resFiles=None, eigens=None, harms=None, sort=None) -> None:
		r"""
		Specifies the loadsets to be shown as the available list. It is an error to call both this function and also functions similar to IFSelectLoadsetsDialog.setStructural (which specify a category of loadset, where this function specifies a specific list)  
		Params:
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
			sort (bool, optional): (Default) true to sort the given list before display, false to preserve the order given
		Returns:
			None: 
		"""
		pass


	def setLoadsets(self, IDs, resFiles=None, eigens=None, harms=None) -> None:
		r"""
		Specifies the loadsets to be shown as the initial selection  
		Params:
			IDs (object): Array of IFLoadset objects, loadset IDs or loadset names.
			resFiles (array of ints, optional): 
			eigens (array of ints, optional): 
			harms (array of ints, optional): 
		Returns:
			None: 
		"""
		pass


	def getLoadsets(self) -> list[IFLoadset]:
		r"""
		Retrieves the loadsets selected by the user (assuming he pressed OK) 
		Returns:
			array of IFLoadset: 
		"""
		pass


	def allowDuplicates(self, allow) -> None:
		r"""
		Allow the user to select the same loadcase more than once 
		Params:
			allow (bool): 
		Returns:
			None: 
		"""
		pass


	def setStructural(self, structural) -> None:
		r"""
		Set to True in order to include loadcases in structural analysis 
		Params:
			structural (bool): 
		Returns:
			None: 
		"""
		pass


	def setThermal(self, thermal) -> None:
		r"""
		Set to True in order to include loadcases in thermal analysis 
		Params:
			thermal (bool): 
		Returns:
			None: 
		"""
		pass


	def setHygro(self, hygro) -> None:
		r"""
		Set to True in order to include loadcases in hygro-thermal analysis 
		Params:
			hygro (bool): 
		Returns:
			None: 
		"""
		pass


	def setResultsOnly(self, resultsOnly) -> None:
		r"""
		Set to True in order to include only loadcases with results 
		Params:
			resultsOnly (bool): 
		Returns:
			None: 
		"""
		pass


	def includeLoadcaseType(self, type) -> None:
		r"""
		Add a loadcase type to be included in the selection list. This method needs to be called for at least one type of loadcase, otherwise there will be no available loadcases for the user to select 
		Params:
			type (str): Loadcase type: "loadcase", "results loadcase", "combination", "envelope", "fatigue loadcase", "IMD loadcase", "smart combination", standard loadcurve", "variation loadcurve", "table loadcurve", "target values", "cable tuning", "influence", "target values"
		Returns:
			None: 
		"""
		pass


	def showStep(self, visible) -> None:
		r"""
		Set to True or False in order for the "Step" button to be visible or not in the control 
		Params:
			visible (bool): 
		Returns:
			None: 
		"""
		pass


class IFFileDialog(IFDialog):
	"""
	Interface to modeller's standard 'file open' or 'file save as' dialogs Such a dialog is created using IFModeller.createOpenDialog or IFModeller.createSaveDialog 
	"""

	def addFilter(self, filterName, filter, type) -> IFFileDialog:
		r"""
		Add the filter data to the filter in the combo box 
		Params:
			filterName (str): 
			filter (str): 
			type (int): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def addAllFilesFilter(self) -> IFFileDialog:
		r"""
		add *.* to the filter list 
		Returns:
			IFFileDialog: 
		"""
		pass


	def setTitle(self, title) -> IFFileDialog:
		r"""
		Sets the caption in the title bar 
		Params:
			title (str): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def setInitialFilename(self, filename) -> IFFileDialog:
		r"""
		 
		Params:
			filename (str): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def setInitialDirectory(self, dir) -> IFFileDialog:
		r"""
		Sets the initial directory (may be overridden if initial filename contains a path) 
		Params:
			dir (str): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def setInitialFilterIndex(self, index) -> IFFileDialog:
		r"""
		Sets the initial filename that appears in the edit control 
		Params:
			index (int): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def allowMultiSelect(self, bFlag) -> IFFileDialog:
		r"""
		Dialog allows multiple selection of files 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def createPrompt(self, bFlag) -> IFFileDialog:
		r"""
		If the user specifies a file that does not exist, this flag causes the dialog box to prompt the user for permission to create the file. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def enableSizing(self, bFlag) -> IFFileDialog:
		r"""
		Enables the dialog box to be resized using either the mouse or the keyboard. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def fileMustExist(self, bFlag) -> IFFileDialog:
		r"""
		Specifies that the user can type only names of existing files in the File Name entry field. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def hideReadOnly(self, bFlag) -> IFFileDialog:
		r"""
		Hides the Read Only check box. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def restoreDirectory(self, bFlag) -> IFFileDialog:
		r"""
		Restores the current directory to its original value if the user changed the directory while searching for files. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def overwritePrompt(self, bFlag) -> IFFileDialog:
		r"""
		Causes the Save As dialog box to generate a message box if the selected file already exists. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def pathMustExist(self, bFlag) -> IFFileDialog:
		r"""
		Specifies that the user can type only valid paths and file names. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def checkReadOnly(self, bFlag) -> IFFileDialog:
		r"""
		Causes the Read Only check box to be selected initially when the dialog box is created. 
		Params:
			bFlag (bool): 
		Returns:
			IFFileDialog: 
		"""
		pass


	def getFilename(self) -> str:
		r"""
		Returns the name of the selected file(s) 
		Returns:
			str: 
		"""
		pass


	def getFileType(self) -> int:
		r"""
		Returns the type of the selected file 
		Returns:
			int: 
		"""
		pass


	def getFileList(self, value) -> int:
		r"""
		Returns an array of name(s) of the selected file(s) 
		Params:
			value (array of strs): 
		Returns:
			int: 
		"""
		pass


	def getReadOnly(self) -> bool:
		r"""
		Indicates the state of the Read Only check box when the dialog box is closed. 
		Returns:
			bool: 
		"""
		pass


class IFScriptedResultsComponentSet(IFResultsComponentSet):
	"""
	placeholder. Just allows some functions to work with either a IFPrimaryScriptedResultsComponentSet or IFScriptedResultsCallbackComponentSet 
	"""

	def initialise(self) -> None:
		r"""
		deletes all stored data, and sets a flag so that each 'get...Results' method will return zero, even if the appropriate set...Results() method has not been called. 
		Returns:
			None: 
		"""
		pass


	def getUniqueID(self) -> str:
		r"""
		Simply returns the string specified in IFPrimaryScriptedResultsComponentSet.setUniqueID 
		Returns:
			str: 
		"""
		pass


class IFPrimaryScriptedResultsComponentSet(IFScriptedResultsComponentSet):
	"""
	a container for scripted results components This object allows you to set up components, prior to supplying actual results values. When the user asks for results (via contours, print results wizard, etc), the callback module will be asked to supply the actual values. 
	"""

	def setUniqueID(self, idStr) -> None:
		r"""
		not used by modeller at all. Allows a module to register multiple results with different IDs. The ID is then available during the callback process, so that the module can check which results have been requested 
		Params:
			idStr (str): 
		Returns:
			None: 
		"""
		pass


	def setCallbackModule(self, moduleName) -> None:
		r"""
		Specifies the one and only module that will be asked for updated results. If this method is not used, all modules are informed via updateScriptedResults() and each module must provide all the results it has. 
		Params:
			moduleName (str): name of module
		Returns:
			None: 
		"""
		pass


	def addScriptedResults(self, component, packedDim=None, unitSet=None, denominatatorUnitSet=None, hasSeparator=None) -> None:
		r"""
		add an extra component to an existing object The components will be shown separately and individually the results UI (e.g. contours, PRW) but will receive only one callback from updateScriptedResults() - the callback is expected to provide results for all components in this object at the same time. 
		Params:
			component (str): Name of results component
			packedDim (int, optional): Dimensionality of the component
			unitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for this result - default is database units
			denominatatorUnitSet (IFUnitSet, optional): The name or ID of a Unitset, or a pointer to a IFUnitSet object. Customised (e.g. codified) unit set for the optional extra 'per length/area' denominator - default is database units
			hasSeparator (bool, optional): has a separator after the component name in the components droplist
		Returns:
			None: 
		"""
		pass


	def markResultsAvailable(self, nodal, eleNodal, internal, Gauss, inspLocn, avgNodal=None) -> None:
		r"""
		Can be used to defer the calculation of results until the user actually asks for them. First, specify the entity and component names using IFDatabase.createScriptedResults(). Then, indicate what types of results will be coming, using this function. These two actions together will force LUSAS Modeller to make the results available in contours, values, and similar dialogs. Once the user uses the UI to choose a component and a results location, you will get a callback via updateScriptedResults(), where you will need to supply those results. Finally LUSAS Modeller will be able to create the requested image / report / etc. In each case,  0 indicates that this type of result will not be available. 1 indicates that the type of result will be available whenever a loadcase that has results is active. 2 indicates that the type of result is always available, even for pre-processing loadcases and when results are not loaded 
		Params:
			nodal (int): continuous results with no discontinuities (i.e. one value per node), supplied via IFNode.setScriptedResults
			eleNodal (int): element nodal results (called unaveraged in the UI), supplied via IFElement.setNodeScriptedResults
			internal (int): internal point results, suitable for beams, supplied via IFElement.setInternalScriptedResults
			Gauss (int): Gauss point results, suitable for surfaces and volumes, supplied via IFElement.setGaussScriptedResults
			inspLocn (int): inspection location results, supplied via IFInspectionPoint.setScriptedResults
			avgNodal (int, optional): averaged results, supplied via IFElement.setAveragedScriptedResults
		Returns:
			None: 
		"""
		pass


	def setComponentVisible(self, component, isVisible) -> None:
		r"""
		Mark the given component as visible or invisible in the user interface. This allows you (for example) to create a component which is only used for calculation purposes, and should not be shown to the end user. The component may be specified by name or by index. By default, all components are visible. 
		Params:
			component (str or int): Name or index of component
			isVisible (bool): true for visible
		Returns:
			None: 
		"""
		pass


	def isComponentVisible(self, component) -> bool:
		r"""
		Return the value previously set using IFPrimaryScriptedResultsComponentSet.setComponentVisible() 
		Params:
			component (str or int): Name or index of component
		Returns:
			bool: 
		"""
		pass


	def setAllowTransformation(self, component, allow) -> None:
		r"""
		Specify whether the "transformation" button is available when these results are shown in a dialog. Generally this will be false for derived results, and also if the results are already transformed. Generally this will be true if you want to be able to base your calculations on transformed raw solver results. Note that Modeller's own transformation is only ever applied to raw solver results. By default, scripted results components do not allow transformations. 
		Params:
			component (str or int): Name or index of component
			allow (bool): 
		Returns:
			None: 
		"""
		pass


	def isAllowTransformation(self, component) -> bool:
		r"""
		Return the value previously set using IFPrimaryScriptedResultsComponentSet.setAllowTransformation 
		Params:
			component (str or int): Name or index of component
		Returns:
			bool: 
		"""
		pass


	def setAllowAveraging(self, component, allow) -> None:
		r"""
		Specify whether or not modeller can automatically calculate averaged results from element nodal results. Generally this will be false for derived results. Generally this will be true for raw results. Note that Modeller's own internal averaging is only ever based on element nodal results. By default, scripted results components are not automatically averaged. 
		Params:
			component (str or int): Name or index of component
			allow (bool): 
		Returns:
			None: 
		"""
		pass


	def isAllowAveraging(self, component) -> bool:
		r"""
		Return the value previously set using IFPrimaryScriptedResultsComponentSet.setAllowAveraging 
		Params:
			component (str or int): Name or index of component
		Returns:
			bool: 
		"""
		pass


	def setAllowInspLocn(self, component, allow) -> None:
		r"""
		Specify whether or not modeller can automatically interpolate results at inspection locations from element nodal results, averaged results or internal (beam) results By default this is allowed, but you may wish to suppress it for some reason 
		Params:
			component (str or int): Name or index of component
			allow (bool): 
		Returns:
			None: 
		"""
		pass


	def isAllowInspLocn(self, component) -> bool:
		r"""
		Return the value previously set using IFPrimaryScriptedResultsComponentSet.setAllowInspLocn 
		Params:
			component (str or int): Name or index of component
		Returns:
			bool: 
		"""
		pass


	def setAllowAsPrimary(self, component, allow) -> None:
		r"""
		Specify whether or not modeller can use these results as a primary component for envelopes / smart combinations. Generally this will be false for derived results. Generally this will be true for raw results. By default, scripted results components may not be used as primary components. 
		Params:
			component (str or int): Name or index of component
			allow (bool): 
		Returns:
			None: 
		"""
		pass


	def isAllowAsPrimary(self, component) -> bool:
		r"""
		Return the value previously set using IFPrimaryScriptedResultsComponentSet.setAllowAsPrimary 
		Params:
			component (str or int): Name or index of component
		Returns:
			bool: 
		"""
		pass


	def setNeedResultsLoaded(self, component, needResults) -> None:
		r"""
		Specify whether or not results must be loaded on the model for these results to be available in the UI. By default, scripted results components need results in the active loadcase. 
		Params:
			component (str or int): Name or index of component
			needResults (bool): 
		Returns:
			None: 
		"""
		pass


	def isNeedResultsLoaded(self, component) -> bool:
		r"""
		Return the value previously set using IFPrimaryScriptedResultsComponentSet.setNeedResultsLoaded 
		Params:
			component (str or int): Name or index of component
		Returns:
			bool: 
		"""
		pass


	def addStressModel(self, component, stressModel) -> None:
		r"""
		Specify a stress model (e.g. "thick beam" or "solid") of elements required to show these results. By default, scripted results components are available for elements of all stress models. 
		Params:
			component (str or int): Name or index of component
			stressModel (str): 
		Returns:
			None: 
		"""
		pass


	def removeAllStressModels(self, component) -> None:
		r"""
		Remove all values previously set using IFPrimaryScriptedResultsComponentSet.addStressModel 
		Params:
			component (str or int): Name or index of component
		Returns:
			None: 
		"""
		pass


	def getStressModels(self, component) -> list[str]:
		r"""
		Return the values previously set using IFPrimaryScriptedResultsComponentSet.addStressModel 
		Params:
			component (str or int): Name or index of component
		Returns:
			array of strs: 
		"""
		pass


	def setComponentSeparator(self, component, hasSeparator) -> None:
		r"""
		Specify whether or not a separator is added in the component droplist after this component. 
		Params:
			component (str or int): Name or index of component
			hasSeparator (bool): 
		Returns:
			None: 
		"""
		pass


	def addSeparator(self) -> None:
		r"""
		Adds a separator in the component droplist after the current component. Use after addScriptedResults 
		Returns:
			None: 
		"""
		pass


class IFScriptedResultsCallbackComponentSet(IFScriptedResultsComponentSet):
	"""
	a container for scripted results components. This object is only used to ask the callback module for the results previously promised via IFPrimaryScriptedResultsComponentSet 
	"""

	pass


class IFView(IFResultsContext):
	"""
	Represents Modeller's main drawing window 
	"""

	def showActiveOnly(self, isActiveOnly) -> IFView:
		r"""
		Set this view to display only that portion of the mesh which is active in the current loadcase in a birth and death analysis. See IFActivate and IFDeactivate for information on how to activate and deactivate the mesh In analyses other than birth and death, this function has no effect. 
		Params:
			isActiveOnly (bool): 
		Returns:
			IFView: 
		"""
		pass


	def selection(self) -> IFSelection:
		r"""
		Selection object 
		Synonyms:
			getSelection
		Returns:
			IFSelection: 
		"""
		pass


	def getSelection(self) -> IFSelection:
		r"""
		Selection object 
		Returns:
			IFSelection: 
		"""
		pass


	def selectionMemory(self) -> IFSelection:
		r"""
		 
		Synonyms:
			getSelectionMemory
		Returns:
			IFSelection: 
		"""
		pass


	def getSelectionMemory(self) -> IFSelection:
		r"""
		 
		Returns:
			IFSelection: 
		"""
		pass


	def visible(self) -> IFObjectSet:
		r"""
		Returns the set of currently visible objects 
		Synonyms:
			getVisibleSet
		Returns:
			IFObjectSet: 
		"""
		pass


	def getVisibleSet(self) -> IFObjectSet:
		r"""
		Returns the set of currently visible objects 
		Returns:
			IFObjectSet: 
		"""
		pass


	def setCurrent(self) -> None:
		r"""
		Set this view to be the "current" view (returned by IFModeller.view and synonyms) Also, implicitly, sets the "current" database (returned by IFModeller.database and synonyms) to be the database that contains the loadcase which is active within this view. 
		Returns:
			None: 
		"""
		pass


	def close(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def maximise(self) -> None:
		r"""
		Maximize this window such that it fills all the available drawing area 
		Synonyms:
			maximize
		Returns:
			None: 
		"""
		pass


	def maximize(self) -> None:
		r"""
		Maximize this window such that it fills all the available drawing area 
		Returns:
			None: 
		"""
		pass


	def restore(self) -> None:
		r"""
		Unmaximize this window such that it returns to its previous size and position 
		Returns:
			None: 
		"""
		pass


	def geometry(self) -> IFGeometryLayer:
		r"""
		Function which retrieves geometry drawing layer 
		Synonyms:
			getGeometryLayer
		Returns:
			IFGeometryLayer: 
		"""
		pass


	def getGeometryLayer(self) -> IFGeometryLayer:
		r"""
		Function which retrieves geometry drawing layer 
		Returns:
			IFGeometryLayer: 
		"""
		pass


	def insertGeometryLayer(self) -> None:
		r"""
		insert geometry drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeGeometryLayer(self) -> None:
		r"""
		remove geometry drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsGeometryLayer(self) -> bool:
		r"""
		returns true if geometry drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def mesh(self) -> IFMeshLayer:
		r"""
		Function which retrieves mesh drawing layer 
		Synonyms:
			getMeshLayer
		Returns:
			IFMeshLayer: 
		"""
		pass


	def getMeshLayer(self) -> IFMeshLayer:
		r"""
		Function which retrieves mesh drawing layer 
		Returns:
			IFMeshLayer: 
		"""
		pass


	def insertMeshLayer(self) -> None:
		r"""
		insert mesh drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeMeshLayer(self) -> None:
		r"""
		remove mesh drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsMeshLayer(self) -> bool:
		r"""
		returns true if mesh drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def annotation(self) -> IFAnnotationLayer:
		r"""
		Function which retrieves annotation drawing layer 
		Synonyms:
			getAnnotationLayer
		Returns:
			IFAnnotationLayer: 
		"""
		pass


	def getAnnotationLayer(self) -> IFAnnotationLayer:
		r"""
		Function which retrieves annotation drawing layer 
		Returns:
			IFAnnotationLayer: 
		"""
		pass


	def insertAnnotationLayer(self) -> None:
		r"""
		Inserts annotation drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeAnnotationLayer(self) -> None:
		r"""
		Removes annotation drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsAnnotationLayer(self) -> bool:
		r"""
		Returns true if annotation drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def labels(self) -> IFLabelLayer:
		r"""
		Function which retrieves label drawing layer 
		Synonyms:
			getLabelLayer
		Returns:
			IFLabelLayer: 
		"""
		pass


	def getLabelLayer(self) -> IFLabelLayer:
		r"""
		Function which retrieves label drawing layer 
		Returns:
			IFLabelLayer: 
		"""
		pass


	def insertLabelLayer(self) -> None:
		r"""
		Inserts labels drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeLabelLayer(self) -> None:
		r"""
		Removes label drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsLabelLayer(self) -> bool:
		r"""
		Returns true if label drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def attributes(self) -> IFAttributesLayer:
		r"""
		Function which retrieves attribute visualisation drawing layer 
		Synonyms:
			getAttributesLayer
		Returns:
			IFAttributesLayer: 
		"""
		pass


	def getAttributesLayer(self) -> IFAttributesLayer:
		r"""
		Function which retrieves attribute visualisation drawing layer 
		Returns:
			IFAttributesLayer: 
		"""
		pass


	def utilities(self) -> IFUtilitiesLayer:
		r"""
		Function which retrieves utilities visualisation drawing layer 
		Synonyms:
			getUtilitiesLayer
		Returns:
			IFUtilitiesLayer: 
		"""
		pass


	def getUtilitiesLayer(self) -> IFUtilitiesLayer:
		r"""
		Function which retrieves utilities visualisation drawing layer 
		Returns:
			IFUtilitiesLayer: 
		"""
		pass


	def insertAttributesLayer(self) -> None:
		r"""
		Inserts attribute visualisation drawing layer 
		Returns:
			None: 
		"""
		pass


	def insertUtilitiesLayer(self) -> None:
		r"""
		Inserts utility visualisation drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeAttributesLayer(self) -> None:
		r"""
		Removes attribute visualisation drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeUtilitiesLayer(self) -> None:
		r"""
		Removes utility visualisation drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsAttributesLayer(self) -> bool:
		r"""
		Returns true if attribute visualisation drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def existsUtilitiesLayer(self) -> bool:
		r"""
		Returns true if utility visualisation drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def deform(self) -> IFDeformLayer:
		r"""
		Function which retrieves deformed mesh drawing layer 
		Synonyms:
			getDeformLayer
		Returns:
			IFDeformLayer: 
		"""
		pass


	def getDeformLayer(self) -> IFDeformLayer:
		r"""
		Function which retrieves deformed mesh drawing layer 
		Returns:
			IFDeformLayer: 
		"""
		pass


	def insertDeformLayer(self) -> None:
		r"""
		Inserts deformed mesh drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeDeformLayer(self) -> None:
		r"""
		Removes deformed mesh drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsDeformLayer(self) -> bool:
		r"""
		Returns true if deformed mesh drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def vectors(self) -> IFVectorsLayer:
		r"""
		Function which retrieves vectors drawing layer 
		Synonyms:
			getVectorsLayer
		Returns:
			IFVectorsLayer: 
		"""
		pass


	def getVectorsLayer(self) -> IFVectorsLayer:
		r"""
		Function which retrieves vectors drawing layer 
		Returns:
			IFVectorsLayer: 
		"""
		pass


	def insertVectorsLayer(self) -> None:
		r"""
		Inserts vectors drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeVectorsLayer(self) -> None:
		r"""
		Removes vectors drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsVectorsLayer(self) -> bool:
		r"""
		Returns true if vectors drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def contours(self) -> IFContoursLayer:
		r"""
		Function which retrieves contours drawing layer 
		Synonyms:
			getContoursLayer
		Returns:
			IFContoursLayer: 
		"""
		pass


	def getContoursLayer(self) -> IFContoursLayer:
		r"""
		Function which retrieves contours drawing layer 
		Returns:
			IFContoursLayer: 
		"""
		pass


	def insertContoursLayer(self) -> None:
		r"""
		Inserts contours drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeContoursLayer(self) -> None:
		r"""
		Removes contours drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsContoursLayer(self) -> bool:
		r"""
		Returns true if contours drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def diagrams(self) -> IFDiagramsLayer:
		r"""
		Function which retrieves diagrams drawing layer 
		Synonyms:
			getDiagramsLayer
		Returns:
			IFDiagramsLayer: 
		"""
		pass


	def getDiagramsLayer(self) -> IFDiagramsLayer:
		r"""
		Function which retrieves diagrams drawing layer 
		Returns:
			IFDiagramsLayer: 
		"""
		pass


	def insertDiagramsLayer(self) -> None:
		r"""
		Inserts diagrams drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeDiagramsLayer(self) -> None:
		r"""
		Removes diagrams drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsDiagramsLayer(self) -> bool:
		r"""
		Returns true if diagrams drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def values(self) -> IFValuesLayer:
		r"""
		Function which retrieves values drawing layer 
		Synonyms:
			getValuesLayer
		Returns:
			IFValuesLayer: 
		"""
		pass


	def getValuesLayer(self) -> IFValuesLayer:
		r"""
		Function which retrieves values drawing layer 
		Returns:
			IFValuesLayer: 
		"""
		pass


	def insertValuesLayer(self) -> None:
		r"""
		Inserts values drawing layer 
		Returns:
			None: 
		"""
		pass


	def removeValuesLayer(self) -> None:
		r"""
		Removes values drawing layer 
		Returns:
			None: 
		"""
		pass


	def existsValuesLayer(self) -> bool:
		r"""
		Returns true if values drawing layer present in view, false otherwise 
		Returns:
			bool: 
		"""
		pass


	def copyLayer(self, layer, index) -> None:
		r"""
		 
		Params:
			layer (IFLayer): 
			index (int): 
		Returns:
			None: 
		"""
		pass


	def loadView(self, savedName, doLayers, doRotation, doPageSz, doColour, doPenLib) -> None:
		r"""
		Modify this view to have some or all of the characteristics of the named view given. The named view must have been previously saved using IFView.saveView. Each characteristic is independently controlled, so it is, for example, possible to modify the rotation to match, without affecting anything else. Note that this is the older implementation of saving views, from before V16, and is not compatible with the newer and superior IFDatabase.saveView 
		Params:
			savedName (str): name to find and load
			doLayers (bool): whether or not to make the drawing layers of this view match those previously saved
			doRotation (bool): whether or not to make the rotation of this view match those previously saved
			doPageSz (bool): whether or not to make the page size of this view match those previously saved
			doColour (bool): whether or not to make the colour scheme of this view match those previously saved
			doPenLib (bool): whether or not to make the pen library of this view match those previously saved (this option affects all views in this database)
		Returns:
			None: 
		"""
		pass


	def copyView(self, view) -> None:
		r"""
		 
		Params:
			view (IFView): 
		Returns:
			None: 
		"""
		pass


	def saveView(self, viewString) -> None:
		r"""
		Save all the settings and options of this view into the registry for later retrieval with IFView.loadView. Note that this is the older implementation of saving views, from before V16, and is not compatible with the newer and superior IFDatabase.saveView, which saves the details as a reusable utility, instead of to the registry. 
		Params:
			viewString (str): 
		Returns:
			None: 
		"""
		pass


	def setTitle(self, viewName) -> None:
		r"""
		Set the title (name) of this view for this session. Note that view names are reconstructed from the Windows filename each time the model file is read, therefore a user-specified view title is for the current session only, and not saved in the model file 
		Params:
			viewName (str): 
		Returns:
			None: 
		"""
		pass


	def getTitle(self) -> str:
		r"""
		Retrieve the title (name) of this view for this session as previously set with IFView.setTitle. Note that view names are reconstructed from the Windows filename each time the model file is read, therefore a user-specified view title is for the current session only, and not saved in the model file  
		Returns:
			str: 
		"""
		pass


	def showRulers(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setSelectPen(self, pen) -> None:
		r"""
		Specify that this view should use the given pen for selected items 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setSelectMemoryPen(self, pen) -> None:
		r"""
		Specify that this view should use the given pen for items in selection memory 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setSelectionColoursToSystem(self) -> None:
		r"""
		Specify that this view should use the Windows system colour scheme for selection (typically black) 
		Returns:
			None: 
		"""
		pass


	def setBackgroundColour(self, r, g, b) -> None:
		r"""
		Specify that this view should use a solid plain background of the given colour 
		Params:
			r (int): 
			g (int): 
			b (int): 
		Returns:
			None: 
		"""
		pass


	def showCoordSystem(self, isShowCoordSystem) -> None:
		r"""
		Switch on / off the 3d axes set that shows the orientation of the currently active local coordinate set and any rotation that may have been applied 
		Params:
			isShowCoordSystem (bool): 
		Returns:
			None: 
		"""
		pass


	def setCoordSystemPosModel(self, xcoord, ycoord, zcoord) -> None:
		r"""
		Set the position, in 3d "fixed to model" coords, at which the coord system axes are drawn (the default is 0,0,0) 
		Params:
			xcoord (float): 
			ycoord (float): 
			zcoord (float): 
		Returns:
			None: 
		"""
		pass


	def setCoordSystemPosFrame(self, xcoord, ycoord) -> None:
		r"""
		Set the position, in 2d "fixed to frame" coords, at which the coord system axes are drawn 
		Params:
			xcoord (float): 
			ycoord (float): 
		Returns:
			None: 
		"""
		pass


	def setCoordSystemAxesLength(self, axesLength) -> None:
		r"""
		Set the length, in mm on the screen, of the arrows used to visualise the coord system 
		Params:
			axesLength (float): 
		Returns:
			None: 
		"""
		pass


	def setCoordSystemArrowSize(self, arrowSize) -> None:
		r"""
		Set the size, in mm on the screen, of the arrow heads used to visualise the coord system 
		Params:
			arrowSize (float): 
		Returns:
			None: 
		"""
		pass


	def setCoordSystemLabels(self, isShow, fontDesc=None) -> None:
		r"""
		Set whether or not the "X", "Y" and "Z" labels are drawn as part of the coord system and optionally set the font used to draw them 
		Params:
			isShow (bool): 
			fontDesc (object, optional): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
		Returns:
			None: 
		"""
		pass


	def showAxisCube(self, isShowCoordSystem) -> None:
		r"""
		Switch on / off the axis cube that allows for convenient orientation and rotation of the model 
		Params:
			isShowCoordSystem (bool): 
		Returns:
			None: 
		"""
		pass


	def showAxisCubeControls(self, isShowAxisCubeControls) -> None:
		r"""
		Switch on / off the axis cube icons which allow for convenient navigation by icons 
		Params:
			isShowAxisCubeControls (bool): 
		Returns:
			None: 
		"""
		pass


	def setAxisCubePos(self, xcoord, ycoord, zcoord) -> None:
		r"""
		Set the position, in 2d "fixed to frame" coords, at which the axis cube is drawn (the default is -20,-20) 
		Params:
			xcoord (float): 
			ycoord (float): 
			zcoord (float): 
		Returns:
			None: 
		"""
		pass


	def setAxisCubeSize(self, size) -> None:
		r"""
		Set the size, in mm on the screen, of the axis cube 
		Params:
			size (float): 
		Returns:
			None: 
		"""
		pass


	def setAxisCubeLabels(self, minX, maxX, minY, maxY, minZ, maxZ, fontDesc=None) -> None:
		r"""
		set the captions used to distinguish each face of the axis cube, and optionally set the font used to draw them 
		Params:
			minX (str): Default "left"
			maxX (str): Default "right"
			minY (str): default "front"
			maxY (str): default "back"
			minZ (str): default "top"
			maxZ (str): default "bottom"
			fontDesc (object, optional): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
		Returns:
			None: 
		"""
		pass


	def selectAt(self, x, y, selType=None, objectType=None, cycleNo=None, axisType=None) -> None:
		r"""
		Select one object at the given location. Coordinates are given in rotated model units. If more than one object could possibly be selected at that location, an array of cyclable items is created, ordered and stored internally. Subsequent selections at the same location cycle through this array. Alternatively, the functions IFView.cycleSelnNext and similar may be used to achieve the same result. A selection may set, add to, or toggle the previously selected items. 
		Params:
			x (float): 
			y (float): 
			selType (str, optional): "Set", "Add", "Toggle"
			objectType (str, optional): "All", "Geometry", "Mesh", "Annotation" or "Point", "Line" etc
			cycleNo (int, optional): number of cycles before desired object
			axisType (str, optional): "All", "Vertical", "Horizontal", "X", "Y", "Z", "XY", "YZ" or "XZ"
		Returns:
			None: 
		"""
		pass


	def selectRect(self, left, top, right, bottom, selType=None, objectType=None, axisType=None) -> None:
		r"""
		Select everything inside the given rectangle. The selection mechanism can be modified to include only certain object types, and/or to add, toggle or set the selection, and/or to perform an enclosed or intersecting selection. Coordinates are given in rotated model units. 
		Params:
			left (float): 
			top (float): 
			right (float): 
			bottom (float): 
			selType (str, optional): "Set", "Add", "Toggle","Set_Intersecting", "Add_Intersecting", or "Toggle_Intersecting"
			objectType (str, optional): "All", "Geometry", "Mesh", "Annotation" or "Point", "Line" etc
			axisType (str, optional): "All", "Vertical", "Horizontal", "X", "Y", "Z", "XY", "YZ" or "XZ"
		Returns:
			None: 
		"""
		pass


	def selectCircle(self, x, y, radius, selType=None, objectType=None, axisType=None) -> None:
		r"""
		Select everything inside the given circle. The selection mechanism can be modified to include only certain object types, and/or to add, toggle or set the selection, and/or to perform an enclosed or intersecting selection. Coordinates are given in rotated model units. 
		Params:
			x (float): 
			y (float): 
			radius (float): 
			selType (str, optional): "Set", "Add", "Toggle","Set_Intersecting", "Add_Intersecting", or "Toggle_Intersecting"
			objectType (str, optional): "All", "Geometry", "Mesh", "Annotation" or "Point", "Line" etc
			axisType (str, optional): "All", "Vertical", "Horizontal", "X", "Y", "Z", "XY", "YZ" or "XZ"
		Returns:
			None: 
		"""
		pass


	def selectPolygon(self, nPoints, xArray, yArray, selType=None, objectType=None, axisType=None) -> None:
		r"""
		Select everything inside the given polygon. The selection mechanism can be modified to include only certain object types, and/or to add, toggle or set the selection, and/or to perform an enclosed or intersecting selection. Coordinates are given in rotated model units. 
		Params:
			nPoints (int): 
			xArray (array of float): 
			yArray (array of float): 
			selType (str, optional): "Set", "Add", "Toggle","Set_Intersecting", "Add_Intersecting", or "Toggle_Intersecting"
			objectType (str, optional): "All", "Geometry", "Mesh", "Annotation" or "Point", "Line" etc
			axisType (str, optional): "All", "Vertical", "Horizontal", "X", "Y", "Z", "XY", "YZ" or "XZ"
		Returns:
			None: 
		"""
		pass


	def setScale(self, scale) -> None:
		r"""
		To draw the model at a known scale. For example, if the scale is specified as 1:1 and the model length units are metres, a line of length 0.1 will be drawn 10cm long. Note that in working mode, this 10cm relates to the size on the screen, whilst in page layout mode it relates to the size on the final printed page. Setting the scale factor automatically switches off scaled to fit mode. By default the image will be centred on the page or window but this is under user control. Note that in Working Mode the effects of zoom and scale are very similar. However in Page Layout Mode, zooming affects both model and page together relative to the window, whilst scaling affects the model size relative to the page size. Scaling automatically turns off scaled to fit mode. 
		Params:
			scale (float): 
		Returns:
			None: 
		"""
		pass


	def setZoom(self, zoom, panType=None) -> None:
		r"""
		To magnify (or reduce) the size of the model relative to the window. In page layout mode, the printed page is also magnified or reduced by the same amount. Zooming automatically turns off scaled to fit mode. 
		Params:
			zoom (float): 
			panType (str, optional): "Camera" or "Viewport"
		Returns:
			None: 
		"""
		pass


	def panToPosition(self, modelX, modelY, modelZ, screenX, screenY=None, panType=None) -> None:
		r"""
		Move the model around in the window such that the given model coordinates appear at the given screen position. Note that panning does not move the model relative to the printed page, see IFView.moveModelOnPage Panning automatically turns off scaled to fit mode. 
		Params:
			modelX (float): position in model space
			modelY (float): position in model space
			modelZ (float): position in model space
			screenX (float): 0.2 = 20% across from left of screen
			screenY (float, optional): 0.2 = 20% up from *bottom* of screen
			panType (str, optional): "Camera" or "Viewport"
		Returns:
			None: 
		"""
		pass


	def panRelative(self, modelX, modelY, panType=None) -> None:
		r"""
		Move the model around in the window by the given distance. Note that panning does not move the model relative to the printed page, see IFView.moveModelOnPage Panning automatically turns off scaled to fit mode. 
		Params:
			modelX (float): distance given in model units but in screen direction
			modelY (float): distance given in model units but in screen direction
			panType (str, optional): "Camera" or "Viewport"
		Returns:
			None: 
		"""
		pass


	def zoomInAtPoint(self, x, y) -> None:
		r"""
		 
		Params:
			x (float): 
			y (float): 
		Returns:
			None: 
		"""
		pass


	def zoomOutAtPoint(self, x, y) -> None:
		r"""
		 
		Params:
			x (float): 
			y (float): 
		Returns:
			None: 
		"""
		pass


	def zoomToRect(self, x1, y1, x2, y2) -> None:
		r"""
		 
		Params:
			x1 (float): 
			y1 (float): 
			x2 (float): 
			y2 (float): 
		Returns:
			None: 
		"""
		pass


	def setRotationVector(self, xcoord, ycoord, zcoord) -> None:
		r"""
		 
		Params:
			xcoord (float): 
			ycoord (float): 
			zcoord (float): 
		Returns:
			None: 
		"""
		pass


	def setRotationMatrix(self, r11, r21, r31, r41, r12, r22, r32, r42, r13, r23, r33, r43, r14, r24, r34, r44) -> None:
		r"""
		 
		Params:
			r11 (float): 
			r21 (float): 
			r31 (float): 
			r41 (float): 
			r12 (float): 
			r22 (float): 
			r32 (float): 
			r42 (float): 
			r13 (float): 
			r23 (float): 
			r33 (float): 
			r43 (float): 
			r14 (float): 
			r24 (float): 
			r34 (float): 
			r44 (float): 
		Returns:
			None: 
		"""
		pass


	def getRotationVector(self) -> list[float]:
		r"""
		Creates and returns an array with the values of the current rotation vector: (xCoord, yCoord, zCoord) 
		Returns:
			array of float: The returned array
		"""
		pass


	def getRotationMatrix(self) -> list[float]:
		r"""
		Creates and returns an array with the values of the current rotation matrix: (r11, r21, r31, r41, r12, r22, r32, r42, r13, r23, r33, r43, r14, r24, r34, r44) 
		Returns:
			array of float: The returned array
		"""
		pass


	def scaleToFit(self) -> None:
		r"""
		Equivalent to entering and then immediately exiting scaled to fit mode. Resizes the model to fit the page/window, but does not leave the view in this state. Subsequent model creation/modification therefore will not affect the scale of the view 
		Returns:
			None: 
		"""
		pass


	def setScaledToFit(self, isScaledToFit) -> None:
		r"""
		Fixes the scale and zoom factors such that the model is as large as possible. The maximum extent of the model is determined by the window size in working mode, and the page size in page layout mode. In both cases, this size is reduced by any borders currently in force. Note that scaled to fit is a 'mode' or 'state'. Therefore, whilst in effect, subsequent model creation/modification will cause further scale calculations. 
		Params:
			isScaledToFit (bool): 
		Returns:
			None: 
		"""
		pass


	def setPageLayoutMode(self, isPageLayoutMode) -> None:
		r"""
		Use this function to switch between Page Layout Mode and Working Mode. In Page Layout Mode, zooming and panning manipulates the printed page, including any page based annotation. In Working Mode, zooming and panning affects only the model. 
		Params:
			isPageLayoutMode (bool): 
		Returns:
			None: 
		"""
		pass


	def setFromAxis(self, axisCode) -> None:
		r"""
		Rotate to the given orthogonal axis position. Valid input is of the format "+X-Y", meaning show the model X axis increasing left to right, and model Y decreasing bottom to top. Similarly "-Z+X" would show the model Z axis decreasing left to right, and model X increasing bottom to top. All permutations are valid. 
		Params:
			axisCode (str): 
		Returns:
			None: 
		"""
		pass


	def setIsometric(self) -> None:
		r"""
		Rotate to the isometric view 
		Returns:
			None: 
		"""
		pass


	def setDimetric(self) -> None:
		r"""
		Rotate to the dimetric view 
		Returns:
			None: 
		"""
		pass


	def setTrimetric(self) -> None:
		r"""
		Rotate to the trimetric view 
		Returns:
			None: 
		"""
		pass


	def addRotation(self, x, y, z) -> None:
		r"""
		 
		Params:
			x (float): 
			y (float): 
			z (float): 
		Returns:
			None: 
		"""
		pass


	def cycleSelnNext(self) -> None:
		r"""
		As described in IFView.selectAt, there are often many objects that could possibly be selected at the given location. Calling this function modifies the effect of the preceding IFView.selectAt call such that the next item in the cyclable list is indicated instead. This function may be called repeatedly until the desired effect is obtained. 
		Returns:
			None: 
		"""
		pass


	def cycleSelnPrev(self) -> None:
		r"""
		As described in IFView.selectAt, there are often many objects that could possibly be selected at the given location. Calling this function modifies the effect of the preceding IFView.selectAt call such that the previous item in the cyclable list is indicated instead. This function may be called repeatedly until the desired effect is obtained. 
		Returns:
			None: 
		"""
		pass


	def cycleSelnLowZ(self) -> None:
		r"""
		As described in IFView.selectAt, there are often many objects that could possibly be selected at the given location. Calling this function modifies the effect of the preceding IFView.selectAt call such that the item in the cyclable list which is furthest from the eye position is indicated instead. 
		Returns:
			None: 
		"""
		pass


	def cycleSelnHighZ(self) -> None:
		r"""
		As described in IFView.selectAt, there are often many objects that could possibly be selected at the given location. Calling this function modifies the effect of the preceding IFView.selectAt call such that the item in the cyclable list which is closest to the eye position is indicated instead. 
		Returns:
			None: 
		"""
		pass


	def setPerspective(self, isPerspective) -> None:
		r"""
		If the argument is true, sets the projection to the currently stored perspective type. If false, sets the projection to orthographic. 
		Params:
			isPerspective (bool): 
		Returns:
			None: 
		"""
		pass


	def setPerspectiveViewAngle(self, viewAngle) -> None:
		r"""
		Sets the view angle in degrees. The view angle determines the severity of the perspective projection. Valid values range from 0 to 180, exclusive. A value approaching 0 will result in a near-orthographic projection. A value approaching 180 will result in a view similar to that through a fish-eye-lens. 
		Params:
			viewAngle (float): 
		Returns:
			None: 
		"""
		pass


	def setPerspectiveCloseDepth(self, closeDepth) -> None:
		r"""
		Sets the close depth as a fraction of the view depth at 100% zoom. In perspective view, objects closer to the camera than the close depth are not drawn. 
		Params:
			closeDepth (float): 
		Returns:
			None: 
		"""
		pass


	def setDeformationMagnitude(self, mmMagnitude, exaggerateInitPos=None, exaggerateCableSag=None) -> None:
		r"""
		Set the magnitude, in mm, of the largest deformation shown. In page layout mode, this size is mm on the paper. In working mode, this size is mm on the screen. This allows the deformation to be exaggerated to a known size for visualisation. 
		Params:
			mmMagnitude (float): 
			exaggerateInitPos (bool, optional): true to also exaggerate initial deformations. False to view them unexaggerated
			exaggerateCableSag (bool, optional): true to also exaggerate cable sag. False to view them unexaggerated
		Returns:
			None: 
		"""
		pass


	def setDeformationFactor(self, factor, exaggerateInitPos=None, exaggerateCableSag=None) -> None:
		r"""
		Set the factor by which all deformations will be multiplied before being drawn on the screen. This allows a known uniform exaggeration to be applied. 
		Params:
			factor (float): 
			exaggerateInitPos (bool, optional): true to also exaggerate initial deformations. False to view them unexaggerated
			exaggerateCableSag (bool, optional): true to also exaggerate cable sag. False to view them unexaggerated
		Returns:
			None: 
		"""
		pass


	def setActivePath(self, path) -> None:
		r"""
		Set active the given path For each visible point, a label is added to show its distance along this path. 
		Params:
			path (IFComposite): The name or ID of a composite, or a pointer to a IFComposite object. Specifies a composite attribute
		Returns:
			None: 
		"""
		pass


	def showViewBorder(self, isShow) -> None:
		r"""
		Creates and destroys border annotation 
		Params:
			isShow (bool): true to show the annotation
		Returns:
			None: 
		"""
		pass


	def getModelNameAnnotation(self) -> IFKeyAnnotation:
		r"""
		Returns model name annotation object 
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def modelNameAnnotation(self) -> IFKeyAnnotation:
		r"""
		Returns model name annotation object 
		Synonyms:
			getModelNameAnnotation
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def getSummary(self) -> IFKeyAnnotation:
		r"""
		Returns summary annotation object 
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def summary(self) -> IFKeyAnnotation:
		r"""
		Returns summary annotation object 
		Synonyms:
			getSummary
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def getBorder(self) -> IFBorderAnnotation:
		r"""
		Function which returns border annotation 
		Returns:
			IFBorderAnnotation: 
		"""
		pass


	def border(self) -> IFBorderAnnotation:
		r"""
		Function which returns border annotation 
		Synonyms:
			getBorder
		Returns:
			IFBorderAnnotation: 
		"""
		pass


	def showViewSummary(self, isShow) -> None:
		r"""
		Show / hide the window summary annotation 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showModelName(self, isShow) -> None:
		r"""
		Show / hide the model name annotation 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def savePicture(self, filename, type=None, width=None, height=None) -> None:
		r"""
		Save current view in file. 
		Params:
			filename (str): 
			type (str, optional): "Bitmap", "Aldus Metafile", "JPEG", "FEA Picture File"
			width (int, optional): 
			height (int, optional): 
		Returns:
			None: 
		"""
		pass


	def getPageSize(self, width, height, paperCode, isPageLandscape, left, bottom, right, top) -> None:
		r"""
		Returns the size of paper, and margins, that will be used to print 
		Params:
			width (int): width of paper (in mm)
			height (int): height of paper (in mm)
			paperCode (int): Microsoft standard code to indicate the name of the paper (9 for A4, 8 for A3, etc)
			isPageLandscape (bool): true if the orientation is landscape
			left (float): left margin (in mm)
			bottom (float): bottom margin (in mm)
			right (float): right margin (in mm)
			top (float): top margin (in mm)
		Returns:
			None: 
		"""
		pass


	def setPageSize(self, width, height, paperCode, isLandscape, left, bottom, right, top) -> None:
		r"""
		Sets the size of paper, and margins, that will be used to print 
		Params:
			width (float): width in mm
			height (float): height in mm
			paperCode (int): paper size code e.g. 8-A3, 9-A4
			isLandscape (bool): Paper orientation Landscape=True, Portrait=False
			left (float): left margin in mm
			bottom (float): bottom margin in mm
			right (float): right margin in mm
			top (float): top margin in mm
		Returns:
			None: 
		"""
		pass


	def refreshResults(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def print(self) -> None:
		r"""
		Print this view with all current printer default settings Equivalent to pressing the 'print' button 
		Returns:
			None: 
		"""
		pass


	def update(self, forceFullRedraw=None) -> None:
		r"""
		Perform a paint of this view. By default this function only actually redraws areas of the screen that are out of date. Optionally however, you may force a complete redraw 
		Params:
			forceFullRedraw (bool, optional): 
		Returns:
			None: 
		"""
		pass


	def listGraphicsInfo(self) -> None:
		r"""
		Lists information about the view's graphics renderer to the text output window of LUSAS Modeller: GDI vs. OpenGL, buffer information, driver versions etc. 
		Returns:
			None: 
		"""
		pass


	def setTriangleSortType(self, triSortType) -> None:
		r"""
		Only appropriate to GDI (not opengl) drawing 
		Params:
			triSortType (int): 
		Returns:
			None: 
		"""
		pass


	def getTriangleSortType(self) -> int:
		r"""
		Only appropriate to GDI (not opengl) drawing 
		Returns:
			int: 
		"""
		pass


	def moveModelOnPage(self, modelX, modelY, modelZ, pageX, pageY) -> None:
		r"""
		Only appropriate to page layout mode. Similar to panning, but instead of moving the model relative to the screen, moves the model relative to the paper. Fixes the specified point in model coords to the specified point on the page. This function automatically turns off scaled to fit mode. 
		Params:
			modelX (float): in model units
			modelY (float): in model units
			modelZ (float): in model unit
			pageX (float): in mm from left of page
			pageY (float): in mm from bottom of page
		Returns:
			None: 
		"""
		pass


	def reinstateSavedActiveLoadset(self) -> None:
		r"""
		To be called after loading model and all results files - reinstates the active loadcase that this view had when the model was saved. Errors will occur when results are not loaded, no required elements are visible, or similar. 
		Returns:
			None: 
		"""
		pass


	def isPageLayoutMode(self) -> bool:
		r"""
		Retrieves the value previously set with IFView.setPageLayoutMode. In Page Layout Mode, zooming and panning manipulates the printed page, including any page based annotation. In Working Mode, zooming and panning affects only the model. 
		Returns:
			bool: 
		"""
		pass


	def setWindowSize(self, width, height) -> None:
		r"""
		Sets the width and the height of the window that contains the view 
		Params:
			width (int): width of the window, in pixels.
			height (int): height of the window, in pixels.
		Returns:
			None: 
		"""
		pass


	def setWindowPosition(self, x, y) -> None:
		r"""
		Sets the position of the window that contains the view 
		Params:
			x (int): position of the left side of the window, in client coordinates.
			y (int): position of the top of the window, in client coordinates.
		Returns:
			None: 
		"""
		pass


	def setViewUnits(self, convertToSet) -> None:
		r"""
		Sets the units of any results displayed in the view 
		Params:
			convertToSet (str or IFUnitSet): Unit set to use.
		Returns:
			None: 
		"""
		pass


	def setScreen(self, name, diagonalIN) -> None:
		r"""
		Sets the units of any results displayed in the view 
		Params:
			name (str): The ID of the detected screen. Can be empty
			diagonalIN (float): The screen diagonal length in inches.
		Returns:
			None: 
		"""
		pass


	def allowTransparency(self, allow) -> None:
		r"""
		Switches on transparency for this view. Control over exactly what is, and what is not, transparent is controlled by the individual drawing layers 
		Params:
			allow (bool): else disallow
		Returns:
			None: 
		"""
		pass


	def isAllowTransparency(self) -> bool:
		r"""
		Returns the setting previously set with IFView.allowTransparency 
		Returns:
			bool: 
		"""
		pass


	def reset(self, layerOrder, colours, layerTransparency, attrTransparency, attrVisualisation, penLibrary) -> None:
		r"""
		Resets various settings back to their default state 
		Params:
			layerOrder (bool): reinstate default layer order
			colours (bool): reinstate default colours for selection and background
			layerTransparency (bool): reinstate default settings for layer transparency
			attrTransparency (bool): reinstate default settings for geometric attribute transparency
			attrVisualisation (bool): reinstate default settings for geometric attribute visualisation (i.e. turn them on/off)
			penLibrary (bool): reset pen library (shared by all views) to default settings
		Returns:
			None: 
		"""
		pass


	def setGlobalLightSource(self, castShadow, ambientOcclusion, fixToFrame, customDir, globalIntensity, ambientIntensity, x, y, z, r, g, b) -> None:
		r"""
		Specifies the details of the global light source. The global light source mimics the effect of the sun - it is considered to be an infinite distance away, therefore light rays are parallel (not dispursive), lighting every surface from the same apparent angle. Global light is not diminished with distance from the source. 
		Params:
			castShadow (bool): Specify whether light source casts a shadow
			ambientOcclusion (bool): Specify whether ambient occlusion is computed wrt this light source
			fixToFrame (bool): Specify whether light source is fixed in model coords (false) or frame coords (true)
			customDir (bool): Specify whether light source direction is default (false) or custom (true)
			globalIntensity (float): Intensity of global light
			ambientIntensity (float): Intensity of ambient light
			x (float): X Position of the light source (light comes from "everywhere" parallel to a vector from this position to the origin)
			y (float): Y Position of the light source (light comes from "everywhere" parallel to a vector from this position to the origin)
			z (float): Z Position of the light source (light comes from "everywhere" parallel to a vector from this position to the origin)
			r (int): Red (0-255)
			g (int): Green (0-255)
			b (int): Blue (0-255)
		Returns:
			None: 
		"""
		pass


	def clearLocalLightSources(self) -> None:
		r"""
		Removes all lights previously defined using IFView.addLocalLightSource 
		Returns:
			None: 
		"""
		pass


	def addLocalLightSource(self, active, castShadow, drawBulb, intensity, x, y, z, r, g, b) -> None:
		r"""
		Adds a local light source A view can have any number of local light sources, although some graphics cards may not display them all. The light rays from a local dispurse outwards from the source position, and their intensity reduces with distance from it. 
		Params:
			active (bool): Specify whether light source is active (true) or off (false)
			castShadow (bool): Specify whether light source casts a shadow
			drawBulb (bool): Specify whether a bulb is drawn at the light source location
			intensity (float): Intensity of the light source
			x (float): Position of the light source
			y (float): Position of the light source
			z (float): Position of the light source
			r (int): Red (0-255)
			g (int): Green (0-255)
			b (int): Blue (0-255)
		Returns:
			None: 
		"""
		pass


	def setBackgroundColourToSystem(self) -> None:
		r"""
		Specify that the background for this window should follow the current Windows setting (typically white) 
		Returns:
			None: 
		"""
		pass


	def setBackgroundImage(self, filename) -> None:
		r"""
		Specify that the background for this window should use the given bitmap image 
		Params:
			filename (str): filename of the image
		Returns:
			None: 
		"""
		pass


	def setBackgroundSkybox(self, name) -> None:
		r"""
		Specify that the background for this window should be the specified skybox. Available skyboxes are "Cloudy", "Less Cloudy", "Low Orbit", "Dusk", and "Nighttime". 
		Params:
			name (str): name of the skybox
		Returns:
			None: 
		"""
		pass


	def setGroundPlaneNone(self) -> None:
		r"""
		Specify that no ground plane should be used for this window 
		Returns:
			None: 
		"""
		pass


	def setGroundPlaneTexture(self, name) -> None:
		r"""
		Specify that no ground plane should be used for this window 
		Params:
			name (str): Name of the texture. Options are: "Chessboard", "Rocks", "Grass", "Sand", "Concrete", "Snow", "Water"
		Returns:
			None: 
		"""
		pass


	def setGroundPlaneInfinite(self) -> None:
		r"""
		Specify that the ground plane should be appear to be of infinite size 
		Returns:
			None: 
		"""
		pass


	def setGroundPlaneSettings(self, r1, g1, b1, r2, g2, b2, size, scale, originX, originY, originZ, reflections, transparent) -> None:
		r"""
		Specify that the ground plane should be a fixed size in each direction 
		Params:
			r1 (int): Foreground colour Red (0-255)
			g1 (int): Foreground colour Green (0-255)
			b1 (int): Foreground colour Blue (0-255)
			r2 (int): Background colour Red (0-255)
			g2 (int): Background colour Green (0-255)
			b2 (int): Background colour Blue (0-255)
			size (float): Overall extent of the ground plane in model units (ignored if ground plane is infinite)
			scale (float): Size of individual parts of the ground plane (e.g. chessboard squares) in model units
			originX (float): Location of the centre of the ground plane
			originY (float): Location of the centre of the ground plane
			originZ (float): Location of the centre of the ground plane
			reflections (bool): Specify reflections can be seen on the ground plane
			transparent (bool): Specify the ground plane is transparent
		Returns:
			None: 
		"""
		pass


	def setAntiAliasingMode(self, mode) -> None:
		r"""
		Specify the anti-aliasing mode. Currently only "off" and "FXAA" are supported 
		Params:
			mode (str): 
		Returns:
			None: 
		"""
		pass


	def getAntiAliasingMode(self) -> str:
		r"""
		Retrieve the anti-aliasing mode. Currently only "off" and "FXAA" are supported 
		Returns:
			str: 
		"""
		pass


class IFWireframeLayer(IFLayer):
	"""
	Base class for mesh and features 
	"""

	def showOrientIfSelected(self, isShow) -> None:
		r"""
		Indicates whether or not to show orientation arrows (axes and normals) only for objects that are selected (default false) 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showOutlineOnly(self, isOutline) -> None:
		r"""
		Indicates whether the plot should be limited to only those edges which occur where two facets meet at an angle (i.e. not coplanar). This tends to reduce the complexity of the plot to a simple outline. Note that some shapes (e.g. smooth spheres) may confuse the outline calculation as all facets meet at the same angle. (default false) 
		Params:
			isOutline (bool): 
		Returns:
			None: 
		"""
		pass


	def showSolid(self, isSolid) -> None:
		r"""
		Indicates whether the solid (facetted) parts of each object should be drawn or not 
		Params:
			isSolid (bool): 
		Returns:
			None: 
		"""
		pass


	def showWireframe(self, isWireframe) -> None:
		r"""
		Indicates whether the perimeter of each object should be drawn or not 
		Params:
			isWireframe (bool): 
		Returns:
			None: 
		"""
		pass


	def showHiddenLines(self, isShow) -> None:
		r"""
		Indicates whether hidden lines (those logically occluded by a solid) shown be drawn or not. This option is only useful when the view is allowing transparency - otherwise it has no effect 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showInternalLines(self, isShow) -> None:
		r"""
		Indicates whether internal lines (those logically within a solid) shown be drawn or not. This option is only useful when the view is allowing transparency - otherwise it has no effect 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def autoColourByAttributes(self, attrType, generateKey) -> None:
		r"""
		Allocates a colour to each attribute, and colours the plot according to those colours. If an object has more than one attribute of the given type assigned, that object is drawn in black. 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			generateKey (bool): display a colour key?
		Returns:
			None: 
		"""
		pass


	def singleColourByAttributes(self, pen, attrType) -> None:
		r"""
		Draw all objects which have at least one assignment of the given attribute type in the colour specified. Others with no assignment will be drawn in a neutral grey 
		Params:
			pen (int): pen number
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def colourByOwnColour(self) -> None:
		r"""
		The default colour scheme. Each object is drawn using its own assigned pen. 
		Returns:
			None: 
		"""
		pass


	def colourByNormalDirection(self) -> None:
		r"""
		Similar to the default colour scheme. Each object whose normal is facing towards the screen is drawn using its own assigned pen. But objects whose normal is facing away are drawn in the logically opposite colour. This is useful to highlight the difference between the inside and outside of a model. It is also useful as a check that all shell elements have consistent normals. 
		Returns:
			None: 
		"""
		pass


	def colourByParentGroup(self, generateKey) -> None:
		r"""
		Allocates a colour to each group, and colours the plot according to those colours. If an object is in more than one group, that object is drawn in black. 
		Params:
			generateKey (bool): display a colour key?
		Returns:
			None: 
		"""
		pass


	def colourByType(self) -> None:
		r"""
		Colour each item by the default colour for that item This gives a convenient way of temporarily ignoring any special colours that may have been attached to individual objects Thus (for example) all points will be red, all lines will be purple, all surfaces green and all volumes blue. 
		Returns:
			None: 
		"""
		pass


	def colourByElementType(self, generateKey) -> None:
		r"""
		Colour each element by its LUSAS element type and optionally show a key to indicate which is which. For example, may colour all BMS3 elements red, and all BEAM elements blue 
		Params:
			generateKey (bool): display a colour key?
		Returns:
			None: 
		"""
		pass


	def autoColourByLineConnectivity(self, generateKey) -> None:
		r"""
		Colour the plot by the number of parents of each line. Thus a surface will be (for example) red if it is not attached to any volume, green if attached to only one, blue if attached to two and yellow if attached to three and so on. Point connectivity is shown the same way. Note that this plot does not show how surfaces connect to volumes - use IFWireframeLayer.colourBySurfaceConnectivity for this Colours are automatically allocated by the program. To control the colours used, use IFWireframeLayer.colourByLineConnectivity instead 
		Params:
			generateKey (bool): display a colour key?
		Returns:
			None: 
		"""
		pass


	def colourByLineConnectivity(self, generateKey, pen0=None, pen1=None, pen2=None, pen3=None, draw0=None, draw1=None, draw2=None, draw3=None) -> None:
		r"""
		Colour the plot by the number of parents of each line. Thus a line will be (for example) red if it is not attached to any surface, green if attached to only one, blue if attached to two and yellow if attached to three or more. Point connectivity is shown the same way. Note that this plot does not show how surfaces connect to volumes - use IFWireframeLayer.colourBySurfaceConnectivity for this 
		Params:
			generateKey (bool): display a colour key?
			pen0 (object, optional): pen number to draw objects with 0 parents
			pen1 (object, optional): pen number to draw objects with 1 parent
			pen2 (object, optional): pen number to draw objects with 2 parents
			pen3 (object, optional): pen number to draw objects with 3 or more parents
			draw0 (bool, optional): Draw objects with 0 parents? (default true)
			draw1 (bool, optional): Draw objects with 1 parent? (default true)
			draw2 (bool, optional): Draw objects with 2 parents? (default true)
			draw3 (bool, optional): Draw objects with 3 or more parents? (default true)
		Returns:
			None: 
		"""
		pass


	def autoColourBySurfaceConnectivity(self, generateKey) -> None:
		r"""
		Colour the plot by the number of parents of each surface. Thus a surface will be (for example) red if it is not attached to any volume, green if attached to only one, blue if attached to two and yellow if attached to three and so on. Point connectivity is shown the same way. Note that this plot does not show how lines connect to surfaces - use IFWireframeLayer.colourByLineConnectivity for this Colours are automatically allocated by the program. To control the colours used, use IFWireframeLayer.colourBySurfaceConnectivity instead 
		Params:
			generateKey (bool): display a colour key?
		Returns:
			None: 
		"""
		pass


	def colourBySurfaceConnectivity(self, generateKey, pen0=None, pen1=None, pen2=None, pen3=None, draw0=None, draw1=None, draw2=None, draw3=None) -> None:
		r"""
		Colour the plot by the number of parents of each surface. Thus a surface will be (for example) red if it is not attached to any volume, green if attached to only one, blue if attached to two and yellow if attached to three or more. Point connectivity is shown the same way. Note that this plot does not show how lines connect to surfaces - use IFWireframeLayer.colourByLineConnectivity for this 
		Params:
			generateKey (bool): display a colour key?
			pen0 (object, optional): pen number to draw objects with 0 parents
			pen1 (object, optional): pen number to draw objects with 1 parent
			pen2 (object, optional): pen number to draw objects with 2 parents
			pen3 (object, optional): pen number to draw objects with 3 or more parents
			draw0 (bool, optional): Draw objects with 0 parents? (default true)
			draw1 (bool, optional): Draw objects with 1 parent? (default true)
			draw2 (bool, optional): Draw objects with 2 parents? (default true)
			draw3 (bool, optional): Draw objects with 3 or more parents? (default true)
		Returns:
			None: 
		"""
		pass


	def key(self) -> IFKeyAnnotation:
		r"""
		Returns the key annotation object used to display the key for colour coded plots. It is an error to call this function if the current plot is not colour coded 
		Synonyms:
			getKey
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def getKey(self) -> IFKeyAnnotation:
		r"""
		Returns the key annotation object used to display the key for colour coded plots. It is an error to call this function if the current plot is not colour coded 
		Returns:
			IFKeyAnnotation: 
		"""
		pass


class IFGeometryLayer(IFWireframeLayer):
	"""
	Set geometry layer properties 
	"""

	def showPoints(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showLines(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showSurfaces(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showVolumes(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showCombinedLines(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showLineDir(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showLineAxes(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showCombinedLineDir(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showSurfaceAxes(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showSurfaceNormals(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showVolumeAxes(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showFacets(self, isShow, isShowIfSelected=None) -> None:
		r"""
		 
		Params:
			isShow (bool): 
			isShowIfSelected (bool, optional): 
		Returns:
			None: 
		"""
		pass


class IFMeshLayer(IFWireframeLayer):
	"""
	Sets mesh layer properties 
	"""

	def setVisiblePen(self, penIndex) -> None:
		r"""
		Sets the pen used for wireframe 
		Params:
			penIndex (int): pen number
		Returns:
			None: 
		"""
		pass


	def setSolidColour(self, r, g, b) -> None:
		r"""
		Sets the colour with which a solid plot will be drawn (note - lighting effects may cause some parts to be drawn in a darker shade) 
		Params:
			r (int): amount of red   0...255
			g (int): amount of green 0...255
			b (int): amount of blue  0...255
		Returns:
			None: 
		"""
		pass


	def showNodes(self, isShow) -> None:
		r"""
		Shows element nodes 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setExplodedPercentage(self, explodedPercentage) -> None:
		r"""
		Sets mesh display to view as explode elements by reducing each elements size specified amonut 
		Params:
			explodedPercentage (float): %element remaining
		Returns:
			None: 
		"""
		pass


	def showElementOrient(self, isShow) -> None:
		r"""
		 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showElementNormals(self, isShow) -> None:
		r"""
		Displays vectors showing element normals 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showActiveOnly(self, isActiveOnly) -> None:
		r"""
		Sets display to view active elements only 
		Params:
			isActiveOnly (bool): 
		Returns:
			None: 
		"""
		pass


	def showElementJoints(self, isShow) -> None:
		r"""
		Shows joint elements 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setJointSymbolOptions(self, symbol, symbolSize, symbolAngle) -> None:
		r"""
		Set symbols to display joint elements 
		Params:
			symbol (str): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
			symbolSize (float): symbol size in mm
			symbolAngle (float): symbol angle in degrees
		Returns:
			None: 
		"""
		pass


	def showJointsExploded(self, doExplode, offset=None) -> None:
		r"""
		Shows joint elements slightly removed from their true location to enable checking of the mesh 
		Params:
			doExplode (bool): 
			offset (float, optional): offset in mm on screen/plot, value <= 0.0 means keep the current value
		Returns:
			None: 
		"""
		pass


	def showActiveSymbols(self, isShow) -> None:
		r"""
		Shows symbol to indicate active elements 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setActiveSymbolOptions(self, symbol, symbolSize, symbolAngle) -> None:
		r"""
		Set active element symbol 
		Params:
			symbol (str): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
			symbolSize (float): symbol size in mm
			symbolAngle (float): symbol angle in degrees
		Returns:
			None: 
		"""
		pass


	def showBeamEndReleases(self, isShow) -> None:
		r"""
		Shows beam end releases 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showPointMass(self, isShow, size=None) -> None:
		r"""
		Shows point mass elements 
		Params:
			isShow (bool): whether or not to show
			size (float, optional): diameter in mm on screen/plot
		Returns:
			None: 
		"""
		pass


	def setColourByFeatureGroup(self, isByFeature) -> None:
		r"""
		Only to be used when in 'colour by group' mode Set to false to colour by the parent group of each element Set to true (the default) to also check the parent group of the element's parent feature 
		Params:
			isByFeature (bool): true to use parent feature
		Returns:
			None: 
		"""
		pass


	def showRigidZones(self, isShow) -> None:
		r"""
		Shows rigid zones 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showCables(self, isShow) -> None:
		r"""
		Shows cables 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showElementPhreatic(self, isShow) -> None:
		r"""
		Shows phreatic elements 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setPhreaticSymbolOptions(self, symbol, symbolSize, symbolAngle) -> None:
		r"""
		Set symbols to display phreatic elements 
		Params:
			symbol (str): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
			symbolSize (float): symbol size in mm
			symbolAngle (float): symbol angle in degrees
		Returns:
			None: 
		"""
		pass


class IFLabelLayer(IFLayer):
	"""
	Set properties of labels layer 
	"""

	def showOnlyIfSelected(self, isShow) -> None:
		r"""
		Sets labels to be displayed only on selected objects 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showLabel(self, objectType, labelType, isShow) -> None:
		r"""
		Sets labels to be drawn 
		Params:
			objectType (str): object on which to display labels
			labelType (str): label type "Name", "Position"
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setFont(self, fontDesc) -> None:
		r"""
		Sets label font 
		Params:
			fontDesc (str): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
		Returns:
			None: 
		"""
		pass


	def setLinesLabelAngle(self, angle) -> None:
		r"""
		Sets the angle of fixed-to-screen line labels 
		Params:
			angle (float): 
		Returns:
			None: 
		"""
		pass


	def setSurfacesLabelAngle(self, angle) -> None:
		r"""
		Sets the angle of fixed-to-screen surface labels 
		Params:
			angle (float): 
		Returns:
			None: 
		"""
		pass


	def setLinesLabelAxis(self, axisCode) -> None:
		r"""
		Sets the local axis to which the line labels are oriented 
		Params:
			axisCode (str): name of axis - one of "x", "xy", "xz" or "Fixed"
		Returns:
			None: 
		"""
		pass


	def setSurfacesLabelAxis(self, axisCode) -> None:
		r"""
		Sets the local axis to which the surface labels are oriented 
		Params:
			axisCode (str): name of axis - either "xy" or "Fixed"
		Returns:
			None: 
		"""
		pass


	def labelUsingAttributeIDs(self, attrIDs) -> None:
		r"""
		Sets labelling using attribute IDs 
		Params:
			attrIDs (bool): 
		Returns:
			None: 
		"""
		pass


class IFVisualiseLayer(IFLayer):
	"""
	Base class for attribute and utility visualisation. Wherever this documentation refers to 'attribute' it can be read as 'attribute/utility' as within the LPI utilities are simply attributes that cannot be assigned 
	"""

	def visualiseNone(self, attrType) -> None:
		r"""
		Set this layer to draw no visualisation for the specified attribute type Transparency settings of attributes will not be changed  (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def visualiseAll(self, attrType) -> None:
		r"""
		Set this layer to draw visualisation for all attributes of specified attribute type. Transparency settings of attributes will not be changed  (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def visualiseAllOpaque(self, attrType) -> None:
		r"""
		Set this layer to draw visualisation for all attributes of specified attribute type. All attributes will be drawn opaque (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def visualiseAllTransparent(self, attrType) -> None:
		r"""
		Set this layer to draw visualisation for all attributes of specified attribute type. All attributes will be drawn transparent (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def visualiseNew(self, attrType, visibilityType) -> None:
		r"""
		Equivalent to the 'attributes not yet defined' checkbox for a particular attribute type. 0 means that attributes will not be visualised until explicitly requested. 1 means that attributes are automatically visualised as they are defined, and drawn opaque 2 means that attributes are automatically visualised as they are defined, and drawn transparent (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			visibilityType (int): 0 = not visualised, 1 = visualised opaque, 2 = visualised transparent
		Returns:
			None: 
		"""
		pass


	def add(self, attr1, attr2=None, attr3=None) -> None:
		r"""
		Adds the given attribute(s) to the list being visualised Attributes may be given as objects or as a type and name(s) Transparency settings of attributes will not be changed (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attr1 (object): Can be an object type 'Point', 'Line', 'Element', etc or an Attribute type such as 'Loading', 'Support', 'Material', etc, Subsequent arguments can provide specifc names or ids of the first argument type.
			attr2 (object, optional): 
			attr3 (object, optional): 
		Returns:
			None: 
		"""
		pass


	def addOpaque(self, attr1, attr2=None) -> None:
		r"""
		Adds the given attribute(s) to the list being visualised Attributes may be given as objects or as a type and name(s) The attributes will be drawn opaque (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attr1 (object): Can be an object type 'Point', 'Line', 'Element', etc or an Attribute type such as 'Loading', 'Support', 'Material', etc. Subsequent arguments can provide specifc names or ids of the first argument type.
			attr2 (object, optional): 
		Returns:
			None: 
		"""
		pass


	def addTransparent(self, attr1, attr2=None) -> None:
		r"""
		Adds the given attribute(s) to the list being visualised Attributes may be given as objects or as a type and name(s) The attributes will be drawn transparent (at present opacity/transparency is only meaningful for geometric attributes) 
		Params:
			attr1 (object): Can be an object type 'Point', 'Line', 'Element', etc or an Attribute type such as 'Loading', 'Support', 'Material', etc. Subsequent arguments can provide specifc names or ids of the first argument type.
			attr2 (object, optional): 
		Returns:
			None: 
		"""
		pass


	def remove(self, attr1, attr2=None, attr3=None) -> None:
		r"""
		Removes the given attribute(s) from the list being visualised Attributes may be given as objects or as a type and name(s) 
		Params:
			attr1 (object): Can be an object type 'Point', 'Line', 'Element', etc or an Attribute type such as 'Loading', 'Support', 'Material', etc, Subsequent arguments can provide specifc names or ids of the first argument type.
			attr2 (object, optional): 
			attr3 (object, optional): 
		Returns:
			None: 
		"""
		pass


	def setDrawStyle(self, attrType, styleName) -> None:
		r"""
		Sets the drawing style for drawing specified attribute 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			styleName (str): "Colour", "Arrows", "Symbols", "Codes"
		Returns:
			None: 
		"""
		pass


	def setArrowHeadSize(self, attrType, size) -> None:
		r"""
		Sets the arrow head size used when draw attributes as arrows 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			size (float): arrow size in mm
		Returns:
			None: 
		"""
		pass


	def setMaxArrowSize(self, attrType, size) -> None:
		r"""
		Sets the maximum arrow head size used to display attributes 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			size (float): maximum arrow size in mm
		Returns:
			None: 
		"""
		pass


	def setMinArrowSize(self, attrType, size) -> None:
		r"""
		Sets the maximum arrow head size used to display attributes 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			size (float): minimum arrow size in mm
		Returns:
			None: 
		"""
		pass


	def setSymbol(self, attrType, symbolName, symbolSize=None, symbolAngle=None) -> None:
		r"""
		Sets the symbol used to display the specified attribute type 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			symbolName (str): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
			symbolSize (float, optional): 
			symbolAngle (float, optional): 
		Returns:
			None: 
		"""
		pass


	def setPen(self, attrType, pen) -> None:
		r"""
		Sets the pen used to display specified attribute type 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setFont(self, attrType, font=None) -> None:
		r"""
		Sets the font used by this drawing layer for text (e.g. support letter codes) 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			font (font, optional): 
		Returns:
			None: 
		"""
		pass


	def setSigFig(self, attrType, sigfig, trailingZeros=None) -> None:
		r"""
		Sets the number of significant figures used to display numerical values 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			sigfig (int): 
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			None: 
		"""
		pass


	def setDecimalPlaces(self, attrType, nDP) -> None:
		r"""
		Sets the number of decimal places used to display numerical values 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			nDP (int): 
		Returns:
			None: 
		"""
		pass


class IFAttributesLayer(IFVisualiseLayer):
	"""
	Represents the attribute visualisation drawing layer 
	"""

	def visualiseResults(self, attrType) -> None:
		r"""
		Only appropriate for loading and support. Sets the visualisation to show loading or support from the solution, rather than from attribute definitions. 
		Params:
			attrType (str): 
		Returns:
			None: 
		"""
		pass


	def drawPatchByDefinition(self, patchDefn) -> None:
		r"""
		Sets the behaviour of the visualisation of point and patch loading 
		Params:
			patchDefn (bool): If true, a visualisation is show which ignores search areas, moving load options etc. If false, the visualisation includes such effects.
		Returns:
			None: 
		"""
		pass


	def drawSymmetry(self, symmetry) -> None:
		r"""
		Option to draw symbols of symmetry instead of symbols of assignment (for radiation surfaces only) 
		Params:
			symmetry (bool): 
		Returns:
			None: 
		"""
		pass


	def drawViewFactors(self, viewFactor) -> None:
		r"""
		Option to draw arrows of view factors instead of arrows of direction (for radiation surfaces only)  
		Params:
			viewFactor (bool): 
		Returns:
			None: 
		"""
		pass


	def drawLayerTop(self) -> None:
		r"""
		Draw composite assignment data at top of active layer 
		Returns:
			None: 
		"""
		pass


	def drawLayerMiddle(self) -> None:
		r"""
		Draw composite assignment data at middle of active layer 
		Returns:
			None: 
		"""
		pass


	def drawLayerBottom(self) -> None:
		r"""
		Draw composite assignment data at bottom of active layer 
		Returns:
			None: 
		"""
		pass


	def drawAxisX(self, attrType) -> None:
		r"""
		Visualises the local x direction of the given attribute type 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def drawAxisY(self, attrType) -> None:
		r"""
		Visualises the local y direction of the given attribute type 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def drawAxisZ(self, attrType) -> None:
		r"""
		Visualises the local z direction of the given attribute type 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def drawAxisXY(self, attrType) -> None:
		r"""
		Visualises both the local x and local y directions of the given attribute type 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def drawSearchTopolgy(self, searchTopology) -> None:
		r"""
		Visualises the underlying search area mesh when visualising search area attributes 
		Params:
			searchTopology (bool): 
		Returns:
			None: 
		"""
		pass


	def ignoreAttributeHistory(self, attrType, ignoreHistory) -> None:
		r"""
		if ignoreHistory is true display attribute data for the active loadcase only if ignoreHistory is false display attribute data up to and including the active loadcase 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			ignoreHistory (bool): 
		Returns:
			None: 
		"""
		pass


	def colourSupportByFeature(self, colourByFeature) -> None:
		r"""
		Sets the support visualisation to be coloured by assigned feature type 
		Params:
			colourByFeature (bool): 
		Returns:
			None: 
		"""
		pass


	def setCrossSectionExag(self, exageration) -> None:
		r"""
		Specifies the exaggeration applied to cross-sections. This is useful where the cross section is small compared to the model size. E.g. an exaggeration of 200% doubles the size of the cross-section visualisation relative to the model 
		Params:
			exageration (float): 
		Returns:
			None: 
		"""
		pass


	def setCrossSectionShrink(self, type, distance=None) -> None:
		r"""
		Specifies how, and by how much, the visualisation of cross-section is shrunk back from the ends of lines. This enables the detail of the intersection to be seen 
		Params:
			type (str): "None", "Auto" or "Specified"
			distance (float, optional): Amount, in model units, to shrink back (only for use with "Specified")
		Returns:
			None: 
		"""
		pass


	def showSmoothEccentricity(self, smooth) -> None:
		r"""
		Option to show eccentricity smoothly varying across elements. Each LUSAS element supports only one value of eccentricity, and when a variation is applied, this can lead to an unattractive jagged plot. Switching this option off allows you to see this jaggedness, which is a more accurate representation of what is actually happening. Leaving this option on (the default) shows the more attractive image 
		Params:
			smooth (bool): 
		Returns:
			None: 
		"""
		pass


	def showVolumesSolid(self, smooth) -> None:
		r"""
		Option to draw volumes using a solid fill. In a model where all beams and surfaces are drawn with fleshing, and volumes also exist, this leads to a more attractive and realistic plot. However if you wish to examine the fleshing of individual beams, you may wish to turn this facility off. 
		Params:
			smooth (bool): 
		Returns:
			None: 
		"""
		pass


	def setShowDeformed(self, attrType, isDeformed) -> None:
		r"""
		Sets the specified attribute type to be drawn on the deform mesh 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			isDeformed (bool): 
		Returns:
			None: 
		"""
		pass


	def drawAllAxes(self, attrType) -> None:
		r"""
		 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def drawDrapeGrid(self, drawGrid, solid=None) -> None:
		r"""
		Visualises the underlying draping grid when visualising composite attributes 
		Params:
			drawGrid (bool): 
			solid (bool, optional): true = fill, false = outline
		Returns:
			None: 
		"""
		pass


	def drawGroundedJointSupports(self, doGroundedJointSupports) -> None:
		r"""
		Switches on/off the support visualisation at grounding joints 
		Params:
			doGroundedJointSupports (bool): 
		Returns:
			None: 
		"""
		pass


	def setProjectionLinesPen(self, pen) -> None:
		r"""
		Sets the pen used to display leading lines for projection lines (use IFVisualiseLayer.setPen for the dimension lines themselves) 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setDimensionLinesUnits(self, units) -> None:
		r"""
		Sets the units used to display labels for dimension lines 
		Params:
			units (str): "m", "in" etc
		Returns:
			None: 
		"""
		pass


	def setDimensionLinesAligned(self) -> None:
		r"""
		Sets the labels of dimension lines to follow the lines (aligned system) 
		Returns:
			None: 
		"""
		pass


	def setDimensionLinesUnidirectional(self) -> None:
		r"""
		Sets the labels of dimension lines to follow screen axes (unidirectional system) 
		Returns:
			None: 
		"""
		pass


class IFUtilitiesLayer(IFVisualiseLayer):
	"""
	Represents the attribute visualisation drawing layer 
	"""

	def showDefinitionCoords(self, attrType, show) -> None:
		r"""
		Sets whether or not to show definition coordinates along tendon profiles and reference paths 
		Params:
			attrType (str): "Loading", "Support", "Material", etc
			show (bool): 
		Returns:
			None: 
		"""
		pass


	def setBeamShellSliceOptions(self, isAxes, isSlice, isLabel, inPlane=None) -> None:
		r"""
		Sets whether or not to show different kinds of visualisation for beam/shell slicing 
		Params:
			isAxes (bool): true to display an arrow set at each slice location, showing local x/y/z of the slice plane
			isSlice (bool): true to display a rectangle at each slice location, showing the local yz plane
			isLabel (bool): true to display a label at each slice location, showing the name of the location
			inPlane (bool, optional): true to draw labels in the plane of the slice (false draws the label in the plane of the screen)
		Returns:
			None: 
		"""
		pass


	def setCompositeDesignOptions(self, isAxes, isSlice, isLabel) -> None:
		r"""
		Sets whether or not to show different kinds of visualisation for composite design 
		Params:
			isAxes (bool): true to display an arrow set at each slice location, showing local x/y/z of the slice plane
			isSlice (bool): true to display a rectangle at each slice location, showing the local yz plane
			isLabel (bool): true to display a label at each slice location, showing the name of the location
		Returns:
			None: 
		"""
		pass


class IFAnnotationLayer(IFLayer):
	"""
	Annotation layer 
	"""

	pass


class IFDeformLayer(IFMeshLayer):
	"""
	Deformed mesh layer 
	"""

	pass


class IFResultsLayer(IFLayer):
	"""
	Base class for all results layers (Vectors, Contours, Diagrams, Values) 
	"""

	def setResults(self, entity, component) -> None:
		r"""
		Set Results entity and component 
		Params:
			entity (str): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (str): Sx, Sy, Sxy, etc.. See element reference manual for details
		Returns:
			None: 
		"""
		pass


	def setShowDeformed(self, isDeformed) -> None:
		r"""
		Sets results to be drawn on deformed mesh 
		Params:
			isDeformed (bool): 
		Returns:
			None: 
		"""
		pass


	def getResults(self, entity, component) -> None:
		r"""
		Retrieves results entity and component previously set with IFResultsLayer.setResults 
		Params:
			entity (object): Results entity i.e. "Force/Moment - Thick Shell" etc..
			component (object): Sx, Sy, Sxy, etc.. See element reference manual for details
		Returns:
			None: 
		"""
		pass


	def isShowDeformed(self) -> bool:
		r"""
		Returns whether or not results are drawn on deformed mesh as previously set by IFResultsLayer.setShowDeformed 
		Returns:
			bool: 
		"""
		pass


	def setResultsTransformNone(self) -> None:
		r"""
		Switches off all results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformElement(self) -> None:
		r"""
		Uses element local axes as the results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view. (For continuous results, such as displacement, nodal axes (transformed freedoms) are used) 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformXYAngle(self, XYAngle) -> None:
		r"""
		Uses the specified angle (in the XY plane - i.e. about Z) as the results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Params:
			XYAngle (float): 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformLocal(self, localCoords, shellPlane) -> None:
		r"""
		Uses the specified local coordinate as the results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Params:
			localCoords (IFLocalCoord): The name or ID of a localcoord, or a pointer to a IFLocalCoord object.
			shellPlane (int): Shell plane for resultants (1, 2 or 3)
		Returns:
			None: 
		"""
		pass


	def setResultsTransformPath(self, path, skew=None) -> None:
		r"""
		Uses the specified path as the results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Params:
			path (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object.
			skew (bool, optional): True if local y = transverse
		Returns:
			None: 
		"""
		pass


	def setResultsTransformFeature(self) -> None:
		r"""
		Uses the parent feature's local directions as the results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformGlobal(self) -> None:
		r"""
		Uses the global axes directions as the results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Returns:
			None: 
		"""
		pass


	def setResultsTransformAttributeType(self, type) -> None:
		r"""
		Uses the given attribute type to obtain the results transformation for this drawing layer. When a combination or envelope is active in the view, it is an error if the individual transformation settings of the individual layers are not same as the settings of the parent view 
		Params:
			type (object): "Loading", "Support", "Material", etc
		Returns:
			None: 
		"""
		pass


	def getResultsTransformData(self, sType, rXYAngle, extraInfo1, extraInfo2) -> None:
		r"""
		Get the transformation settings that are stored with this object 
		Params:
			sType (str): 
			rXYAngle (float): only useful when type is "XY angle"
			extraInfo1 (IFLocalCoord or IFReferencePath or str): Will be set to a local coord if type is "Local coord" or to a path if type is "Path", or to a string if type is "Attribute type", otherwise not used
			extraInfo2 (int): Will be set to the shell plane  if type is "Local coord" or to a boolean skewed/not skewed if type is "Path", otherwise not used
		Returns:
			None: 
		"""
		pass


class IFVectorsLayer(IFResultsLayer):
	"""
	Layer for displaying results as vectors 
	"""

	def setShowAtGauss(self, isGauss) -> None:
		r"""
		Sets vectors to be displayed at Gauss points/nodes (solid / surface elements only) 
		Params:
			isGauss (bool): 
		Returns:
			None: 
		"""
		pass


	def setShowAtInternal(self, isGauss) -> None:
		r"""
		Sets vectors to be displayed at internal points/nodes (beam elements only) 
		Params:
			isGauss (bool): 
		Returns:
			None: 
		"""
		pass


	def setPen(self, penTension, penCompression=None) -> None:
		r"""
		Set pens to display vectors in tension and compression 
		Params:
			penTension (int): pen number to display tensile vectors
			penCompression (object, optional): pen number to display compressive vectors
		Returns:
			None: 
		"""
		pass


	def setHeadStyle(self, drawHead, headLength=None, headAngle=None) -> None:
		r"""
		Sets arrow head display on/off 
		Params:
			drawHead (bool): 
			headLength (float, optional): 
			headAngle (float, optional): 
		Returns:
			None: 
		"""
		pass


	def setGlobalScale(self) -> None:
		r"""
		Set the global vector scale 
		Returns:
			None: 
		"""
		pass


	def useGlobalScale(self, isFollow) -> None:
		r"""
		Uses the global scale for vector results 
		Params:
			isFollow (bool): 
		Returns:
			None: 
		"""
		pass


	def setScaleMagnitude(self, mmMagnitude) -> None:
		r"""
		Sets vector scale using maximum specified vector length 
		Params:
			mmMagnitude (float): Maximum vector length in mm
		Returns:
			None: 
		"""
		pass


	def setScaleFactor(self, factor) -> None:
		r"""
		Sets vector scale factor 
		Params:
			factor (float): Scale factor
		Returns:
			None: 
		"""
		pass


	def setMinArrowSize(self, size) -> None:
		r"""
		Sets minimum vector length 
		Params:
			size (float): Minimum vector length in mm
		Returns:
			None: 
		"""
		pass


class IFContoursLayer(IFResultsLayer):
	"""
	Layer for displaying results as contours. The user interface for contours shows five sets of settings. Each set can be given a meaningful name, and can be independently modified to set up desired appearances for (for example) signed quantities, unsigned quantities or specific quantities like utilisation factors. Internally, these five sets are actually stored with the parent IFView, so they are preserved when a contour layer is deleted and reinstated. To restore factory settings, call IFLayer.reset 
	"""

	def key(self) -> IFKeyAnnotation:
		r"""
		Contour key object 
		Synonyms:
			getKey
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def getKey(self) -> IFKeyAnnotation:
		r"""
		Contour key object 
		Returns:
			IFKeyAnnotation: 
		"""
		pass


	def showKey(self, isShow) -> None:
		r"""
		Displays contour key 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setKeyDecimalPlaces(self, nDecimalPlaces) -> None:
		r"""
		Sets the contour key to use the specified number of decimal places to display real numbers 
		Params:
			nDecimalPlaces (int): 
		Returns:
			None: 
		"""
		pass


	def setKeySigFig(self, nSigFig, trailingZeros=None) -> None:
		r"""
		Sets the contour key to use the specified number of significant figures to display real numbers 
		Params:
			nSigFig (int): 
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			None: 
		"""
		pass


	def setKeyTitle(self, keyTitle) -> None:
		r"""
		Sets the title of the contour key 
		Params:
			keyTitle (str): title to use
		Returns:
			None: 
		"""
		pass


	def setAnnotationOptions(self, showMax, showMin, showLoadcase, outline=None, reverse=None) -> None:
		r"""
		 
		Params:
			showMax (bool): Shows maximum value in contour key
			showMin (bool): Shows minimum value in contour key
			showLoadcase (bool): Show loadcase in contour key
			outline (bool, optional): Draws outline around contour levels in key
			reverse (bool, optional): Reverses position of maximum and minimum values in key
		Returns:
			None: 
		"""
		pass


	def setShowLabels(self, showLabels, interval=None, fontDesc=None, setNumber=None) -> None:
		r"""
		Show labels on contour lines 
		Params:
			showLabels (bool): 
			interval (float, optional): 
			fontDesc (object, optional): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setShowShaded(self, isShow, penWidth=None, setNumber=None) -> None:
		r"""
		 
		Params:
			isShow (bool): 
			penWidth (int, optional): pen width
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setShowLines(self, isShow, autoColour=None, pen=None, setNumber=None) -> None:
		r"""
		Shows contour lines 
		Params:
			isShow (bool): 
			autoColour (bool, optional): 
			pen (object, optional): pen number
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setShowOnSlice(self, isOnSlice) -> None:
		r"""
		Shows contours on slice 
		Params:
			isOnSlice (bool): 
		Returns:
			None: 
		"""
		pass


	def setDisplayType(self, type) -> None:
		r"""
		A string that indicates the type of contours to be drawn. "internal" is used for beam elements. "Nodal" is used for continuous quantities such as displacement, and also "Nodal" and "ElementNodal" are respectively smoothed and unsmoothed contours of surface or volume elements. Other legal inputs are more advanced, and match the possible inputs shown on the contour dialog 
		Params:
			type (str): "Internal", "Nodal", "ElementNodal", "FeatureMax", "FeatureMin", "FeatureAbs", "FeatureExt", or "InspLocn"
		Returns:
			None: 
		"""
		pass


	def setSliceLocal(self, isLocal) -> None:
		r"""
		Sets contours to display in local slice direction 
		Params:
			isLocal (bool): 
		Returns:
			None: 
		"""
		pass


	def setRangeManual(self, valuesArray, setNumber=None) -> None:
		r"""
		Set contour range 
		Params:
			valuesArray (array): Array of contour values
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setRangeAutoNumber(self, value, setNumber=None) -> None:
		r"""
		Computes contour range automatically using specified number of contours 
		Params:
			value (int): number of contours
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setRangeAutoInterval(self, value, setNumber=None) -> None:
		r"""
		Computes contour range using specified contour interval 
		Params:
			value (float): contour interval
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setRangeSymmetrical(self, isSymm, setNumber=None) -> None:
		r"""
		Makes the range symmetrical about zero (i.e. extend the range to use the absolute maximum value on both sides of zero). Note this setting is ignored when used with IFContoursLayer.setRangeManual, but works with both IFContoursLayer.setRangeAutoNumber and IFContoursLayer.setRangeAutoInterval 
		Params:
			isSymm (bool): new value
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setSpecifyPassThrough(self, isSpecify, value=None, setNumber=None) -> None:
		r"""
		Sets a value through which one contour value will pass 
		Params:
			isSpecify (bool): 
			value (float, optional): contour value
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setSpecifyMaximum(self, isSpecify, value=None, setNumber=None) -> None:
		r"""
		Sets the maximum contour to display 
		Params:
			isSpecify (bool): 
			value (float, optional): maximum contour value
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setSpecifyMinimum(self, isSpecify, value=None, setNumber=None) -> None:
		r"""
		Sets the minimum contour to display 
		Params:
			isSpecify (bool): 
			value (float, optional): minimum contour value
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setAttributeType(self, type, param) -> None:
		r"""
		 
		Params:
			type (str): 
			param (str): 
		Returns:
			None: 
		"""
		pass


	def addAttribute(self, attr) -> None:
		r"""
		 
		Params:
			attr (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object.
		Returns:
			None: 
		"""
		pass


	def setDefaultSeedColours(self, setNumber=None) -> None:
		r"""
		Return to the default number and settings of seed colours 
		Params:
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setSeedColours(self, pColours, setNumber=None) -> None:
		r"""
		Seed colours determine the colour appearance of a contour plot. The default contour seeds are red->orange->yellow->green->cyan->blue, but these can be changed as desired. Ideally there should be one more seed colour than the number of contours chosen, but LUSAS Modeller will blend between colours if there are less seeds than contours. Having less contours than seeds is a bad idea, as some colours will be skipped The input is an array of colours. Each colour is a packed integer, following the Microsoft convention of rrggbb where rr is two hex bytes representing red, and so on. Black is 0, White is 0xFFFFFF, Red is 0xFF0000 
		Params:
			pColours (array of ints): 
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setMaxShade(self, maxShade, setNumber=None) -> None:
		r"""
		now set on the view 
		Params:
			maxShade (float): 
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def setGhostFleshing(self, isDraw) -> None:
		r"""
		switch on/off the ghost outline of geometric fleshing, seen when drawing (for example) top stress for shells 
		Params:
			isDraw (bool): 
		Returns:
			None: 
		"""
		pass


	def showExtreme(self, isExtreme) -> None:
		r"""
		A value of true, when the active loadcase is an envelope or a smart combination, will show the extreme contour results. 
		Params:
			isExtreme (bool): 
		Returns:
			None: 
		"""
		pass


	def setSettingsName(self, name, setNumber=None) -> None:
		r"""
		Allows user to specify a short name for a collection of settings as an aide-memoire 
		Params:
			name (str): 
			setNumber (int, optional): 0 to change the contours being seen. 1..5 to change the "stored" contour settings
		Returns:
			None: 
		"""
		pass


	def chooseSettings(self, setNumber) -> None:
		r"""
		Choose the numbered set (1..5) of settings that can be seen on the contour dialog. 
		Params:
			setNumber (int): 
		Returns:
			None: 
		"""
		pass


	def displayAsComponent(self) -> None:
		r"""
		Set this contour layer to follow the display settings dictated by the chosen results component. This option is only available for a few components that have a predetermined set of settings 
		Returns:
			None: 
		"""
		pass


	def displayAsView(self, view) -> None:
		r"""
		Set this contour layer to follow all the display settings of the contour layer in the given view. This option is only available when the given view has a contours layer 
		Params:
			view (object): 
		Returns:
			None: 
		"""
		pass


class IFDiagramsLayer(IFResultsLayer):
	"""
	 
	"""

	def showOnlyIfSelected(self, isShow) -> None:
		r"""
		Displays diagram results only on selected elements 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def showInScreenPlane(self, isShow) -> None:
		r"""
		By default diagrams are shown in the local plane of the requested quantity, so for example force in y is shown in the element's local xy plane. This adds clarity, but means that as the model is rotated the amplitude of the diagram appears to change. Instead use this option to force all diagrams to be drawn in the screen xy plane, which makes all amplitudes consistent, but loses the direction distinction. 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setExplodedPercentage(self, explodedPercentage) -> None:
		r"""
		Displays diagrams on exploded elements 
		Params:
			explodedPercentage (float): % remaining of element size
		Returns:
			None: 
		"""
		pass


	def setPen(self, pen) -> None:
		r"""
		Sets pen for displaying diagram results 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setShowLabels(self, showLabels, sigFig=None, fontDesc=None, peaksOnly=None, labelInPlane=None) -> None:
		r"""
		Sets diagram labels 
		Params:
			showLabels (bool): 
			sigFig (int, optional): Number of significant figures to be used to display diagram values
			fontDesc (object, optional): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
			peaksOnly (bool, optional): if true, only peaks will be labelled. If false, each end of every element will be labelled
			labelInPlane (bool, optional): if true, labels will display in the plane of the diagram. If false, they will be flat to the screen.
		Returns:
			None: 
		"""
		pass


	def setLabelSigFig(self, sigFig, trailingZeros=None) -> None:
		r"""
		Sets the number of significant figures in diagram labels 
		Params:
			sigFig (int): 
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			None: 
		"""
		pass


	def setLabelDecimalPlaces(self, nDP) -> None:
		r"""
		Sets the number of decimal places in diagram labels 
		Params:
			nDP (int): 
		Returns:
			None: 
		"""
		pass


	def setGlobalScale(self) -> None:
		r"""
		Sets global diagram scale 
		Returns:
			None: 
		"""
		pass


	def useGlobalScale(self, isFollow) -> None:
		r"""
		Use global diagram scale 
		Params:
			isFollow (bool): 
		Returns:
			None: 
		"""
		pass


	def setScaleMagnitude(self, mmMagnitude) -> None:
		r"""
		Set diagram scale by magnitude 
		Params:
			mmMagnitude (float): Maximum height of diagram in mm
		Returns:
			None: 
		"""
		pass


	def setScaleFactor(self, factor) -> None:
		r"""
		Set diagram scale by factor 
		Params:
			factor (float): Scale factor to be used to display diagram
		Returns:
			None: 
		"""
		pass


	def setPenForMax(self, pen) -> None:
		r"""
		Sets pen for displaying maximum diagram results when the active loadcase is an envelope or a smart combination. 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setPenForMin(self, pen) -> None:
		r"""
		Sets pen for displaying minimum diagram results when the active loadcase is an envelope or a smart combination. 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setAssocOption(self, assocOption) -> None:
		r"""
		Sets an additional option which is only need when the active loadcase is an envelope or a smart combination. This option determines if the displayed values  will be from the current active loadcase, both maximum and minimum values or the extreme values. 
		Params:
			assocOption (str): "Single", "Both", "Extreme"
		Returns:
			None: 
		"""
		pass


	def setShowElementBoundaries(self, hasLines) -> None:
		r"""
		If true (the default) a line is drawn perpendicular to the elements at each element boundary. If false, these lines are omitted. 
		Params:
			hasLines (bool): New value
		Returns:
			None: 
		"""
		pass


	def getShowElementBoundaries(self) -> bool:
		r"""
		If true (the default) a line is drawn perpendicular to the elements at each element boundary. If false, these lines are omitted. 
		Returns:
			bool: returned value
		"""
		pass


	def setLocation(self, location) -> None:
		r"""
		Sets the location ("inspection location" / "internal") from where the results are to be obtained 
		Params:
			location (str): 
		Returns:
			None: 
		"""
		pass


class IFValuesLayer(IFResultsLayer):
	"""
	Set Values layer properties 
	"""

	def setShowAtGauss(self) -> None:
		r"""
		Shows values at Gauss Points (solid / surface elements only) 
		Returns:
			None: 
		"""
		pass


	def setShowAtInternal(self) -> None:
		r"""
		Shows values at beam internal points (beam elements only) 
		Returns:
			None: 
		"""
		pass


	def setShowAtInspectionPoints(self) -> None:
		r"""
		Shows values at inspection point assignments 
		Returns:
			None: 
		"""
		pass


	def setShowAtGraphLines(self) -> None:
		r"""
		Shows values along the locations of existing graphs 
		Returns:
			None: 
		"""
		pass


	def setShowAtBeamShellSlices(self) -> None:
		r"""
		Shows values at the locations of existing beam/shell slices 
		Returns:
			None: 
		"""
		pass


	def setShowAtNodes(self) -> None:
		r"""
		Shows values at nodes 
		Returns:
			None: 
		"""
		pass


	def setShowOnSlice(self, isOnSlice) -> None:
		r"""
		Shows values on slice elements (false for normal elements) 
		Params:
			isOnSlice (bool): 
		Returns:
			None: 
		"""
		pass


	def setShowAtElementNodes(self) -> None:
		r"""
		Shows values at Element nodes 
		Returns:
			None: 
		"""
		pass


	def showOnlyIfSelected(self, isShow) -> None:
		r"""
		Shows values only on selected nodes/elements 
		Params:
			isShow (bool): 
		Returns:
			None: 
		"""
		pass


	def setPen(self, pen) -> None:
		r"""
		Sets pen to use to display values 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setShowLabels(self, showLabels, sigFig=None, fontDesc=None) -> None:
		r"""
		Sets values to be drawn 
		Params:
			showLabels (bool): Show values
			sigFig (int, optional): Number of significant figures to be used to display values
			fontDesc (object, optional): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
		Returns:
			None: 
		"""
		pass


	def setSigFig(self, sigFig, trailingZeros=None) -> None:
		r"""
		Sets the number of significant figures in labels 
		Params:
			sigFig (int): 
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			None: 
		"""
		pass


	def setDecimalPlaces(self, nDP) -> None:
		r"""
		Sets the number of decimal places in labels 
		Params:
			nDP (int): 
		Returns:
			None: 
		"""
		pass


	def setShowSymbols(self, showSymbols, symbolType=None, symbolSize=None, symbolAngle=None) -> None:
		r"""
		Sets symbol to be drawn 
		Params:
			showSymbols (bool): Show symbols
			symbolType (str, optional): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
			symbolSize (float, optional): Symbol size in mm
			symbolAngle (float, optional): Angle of symbol in degrees
		Returns:
			None: 
		"""
		pass


	def setShowPercentage(self, showMin, showMax, value=None) -> None:
		r"""
		Sets %range of maximum and minimum values to be displayed 
		Params:
			showMin (bool): Show minimum values within specified percentage
			showMax (bool): Show maximum values within specified percentage
			value (float, optional): percentage to show (e.g. within 5% of max)
		Returns:
			None: 
		"""
		pass


	def setShowLimits(self, showMin, showMax, minValue, maxValue) -> None:
		r"""
		Sets maximum and minimum values to be displayed 
		Params:
			showMin (bool): Show values smaller than given value
			showMax (bool): Show values greater than given value
			minValue (float): show values smaller than this value
			maxValue (float): show values greater than this value
		Returns:
			None: 
		"""
		pass


	def setYieldOptions(self, pen, zone, mode, crackSize=None) -> None:
		r"""
		Sets display options for yield / crack / crush results 
		Params:
			pen (int): pen number to use for displaying yield
			zone (int): interface zone
			mode (int): delamination mode
			crackSize (float, optional): crack size (used by cracking concrete model only)
		Returns:
			None: 
		"""
		pass


	def setPenForMax(self, pen) -> None:
		r"""
		Sets pen for displaying maximum value results when the active loadcase is an envelope or a smart combination. 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setPenForMin(self, pen) -> None:
		r"""
		Sets pen for displaying minimum value results when the active loadcase is an envelope or a smart combination. 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setAssocOption(self, assocOption) -> None:
		r"""
		Sets an additional option which is only need when the active loadcase is an envelope or a smart combination. This option determines if the displayed values  will be from the current active loadcase, both maximum and minimum values or the extreme values. 
		Params:
			assocOption (str): "Single", "Both", "Extreme"
		Returns:
			None: 
		"""
		pass


class IFSliceGroup(IFGroup):
	"""
	a group which represents a 2d planar slice taken through a 3d model 
	"""

	def reverseAxes(self, isReverse) -> IFSliceGroup:
		r"""
		Specify whether or not to swap the local X and Y directions of the slice Multiple calls are not cumulative - 'isReverse' is relative to the original definition of the slice, not the previous call to reverseAxes 
		Params:
			isReverse (bool): if true, X and Y are swapped from the original definition. Otherwise the original definition is used
		Returns:
			IFSliceGroup: 
		"""
		pass


	def drawAxes(self, isDraw) -> IFSliceGroup:
		r"""
		Specify whether or not draw axes for this slice (requires a mesh drawing layer to be present) 
		Params:
			isDraw (bool): if true, the plot is annotated with the local axis of the slice
		Returns:
			IFSliceGroup: 
		"""
		pass


	def rotateAxes(self, angle) -> IFSliceGroup:
		r"""
		Rotates the local axes of the slice Multiple calls are not cumulative - each rotation is relative to the original definition of the slice, not the previous rotation (note, angle is applied before x/y offsets) 
		Params:
			angle (float): angle (in plane of slice) through which to rotate local axis Otherwise the original definition is used
		Returns:
			IFSliceGroup: 
		"""
		pass


	def offsetAxes(self, x, y) -> IFSliceGroup:
		r"""
		Offsets the local axes of the slice, Multiple calls are not cumulative - each offset is relative to the original definition of the slice, not the previous offset (note, angle is applied before x/y offsets) 
		Params:
			x (float): distance (in model units) to move the axes origin in X
			y (float): distance (in model units) to move the axes origin in Y Otherwise the original definition is used
		Returns:
			IFSliceGroup: 
		"""
		pass


	def getProperties(self) -> list:
		r"""
		Return numerical properties of the slice For details of what is returned, use the 'print properties' context menu entry in Modeller's user interface 
		Returns:
			array: an array of numbers
		"""
		pass


	def getForces(self) -> list:
		r"""
		Return forces of the slice For details of what is returned, use the 'print forces' context menu entry in Modeller's user interface 
		Returns:
			array: an array of numbers
		"""
		pass


	def globalToLocal(self, X, Y=None, Z=None) -> None:
		r"""
		Converts the given global coordinates into the local coordinate space of this slice 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def localToGlobal(self, X, Y=None, Z=None) -> None:
		r"""
		Converts the given coordinates from the local coordinate space of this slice into global coordinates 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


class IFStoreyGroup(IFGroup):
	"""
	a group which represents a storey of a building 
	"""

	def setRigidity(self, type) -> IFStoreyGroup:
		r"""
		define the building storey rigidity type 
		Params:
			type (str): rigidity type
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setConstraintMode(self, mode) -> IFStoreyGroup:
		r"""
		define the building storey constraint equation type 
		Params:
			mode (int): constraint equation type
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setPrimaryPosition(self, x, y, z) -> IFStoreyGroup:
		r"""
		define the building storey primary location 
		Params:
			x (float): }
			y (float): } coordinates of the primary location
			z (float): }
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setMass(self, mx, my, mz, mmix, mmiy, mmiz) -> IFStoreyGroup:
		r"""
		define the building storey primary location masses 
		Params:
			mx (float): }
			my (float): } mass in the axes
			mz (float): }
			mmix (float): }
			mmiy (float): } max moment of iniertia about the axes
			mmiz (float): }
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setStiffness(self, kx, ky, kz, kthx, kthy, kthz) -> IFStoreyGroup:
		r"""
		define the building storey primary location stiffnesses 
		Params:
			kx (float): }
			ky (float): } linear stiffnesses
			kz (float): }
			kthx (float): }
			kthy (float): } rotational stiffnesses
			kthz (float): }
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def removeStiffness(self) -> IFStoreyGroup:
		r"""
		remove the building storey primary location stiffnesses 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def addLoading(self, px, py, pz, mx, my, mz, loadcase) -> IFStoreyGroup:
		r"""
		define the building storey primary location loads for a loadcase 
		Params:
			px (float): }
			py (float): } loads in the axes
			pz (float): }
			mx (float): }
			my (float): } moments about the axes
			mz (float): }
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. loadcase
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def removeLoading(self, loadcase) -> IFStoreyGroup:
		r"""
		remove the building storey primary location loads for the given loadcase 
		Params:
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. loadcase
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def removeAllLoading(self) -> IFStoreyGroup:
		r"""
		remove the building storey primary location loads for all loadcases 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def addSymbol(self, x, y, z, symbolName, symbolSize, symbolAngle, pen, symbolId=None) -> int:
		r"""
		add a symbol for visualisation to the storey 
		Params:
			x (float): }
			y (float): } coordinates of the symbol
			z (float): }
			symbolName (str): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
			symbolSize (float): symbol size
			symbolAngle (float): symbol rotation
			pen (int): pen number symbol pen
			symbolId (int, optional): symbol Id
		Returns:
			int: ID of the symbol created
		"""
		pass


	def removeSymbol(self, symbolId) -> IFStoreyGroup:
		r"""
		remove a storey symbol 
		Params:
			symbolId (int): symbol Id
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def removeSymbols(self) -> IFStoreyGroup:
		r"""
		remove all stored symbols 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def countSymbols(self) -> int:
		r"""
		return the number of symbols in the storey 
		Returns:
			int: 
		"""
		pass


	def getSymbolID(self, index) -> int:
		r"""
		return the symbol ID given the array index 
		Params:
			index (int): index in the range 0 - > number symbols -1
		Returns:
			int: 
		"""
		pass


	def setSymbolCoords(self, symbolId, x, y, z) -> IFStoreyGroup:
		r"""
		set the symbol location for the given symbol ID 
		Params:
			symbolId (int): symbol Id
			x (float): }
			y (float): } coordinates of the symbol
			z (float): }
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setSymbolName(self, symbolId, symbolName) -> IFStoreyGroup:
		r"""
		set the symbol name for the given symbol ID 
		Params:
			symbolId (int): symbol Id
			symbolName (str): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setSymbolSize(self, symbolId, symbolSize) -> IFStoreyGroup:
		r"""
		set the symbol size for the given symbol ID 
		Params:
			symbolId (int): symbol Id
			symbolSize (float): symbol size
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setSymbolAngle(self, symbolId, symbolAngle) -> IFStoreyGroup:
		r"""
		set the symbol angle for the given symbol ID 
		Params:
			symbolId (int): symbol Id
			symbolAngle (float): symbol rotation
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setSymbolPen(self, symbolId, pen) -> IFStoreyGroup:
		r"""
		set the symbol pen for the given symbol ID 
		Params:
			symbolId (int): symbol Id
			pen (int): symbol pen
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def getSymbolCoords(self, symbolId) -> list[float]:
		r"""
		return the symbol location from the symbol ID 
		Params:
			symbolId (int): symbol Id
		Returns:
			array of float: An array of 3 real numbers, representing 3d coordinates symbol location
		"""
		pass


	def getSymbolName(self, symbolId) -> str:
		r"""
		return the symbol name from the symbol ID 
		Params:
			symbolId (int): symbol Id
		Returns:
			str: 
		"""
		pass


	def getSymbolSize(self, symbolId) -> float:
		r"""
		return the symbol size from the symbol ID 
		Params:
			symbolId (int): symbol Id
		Returns:
			float: 
		"""
		pass


	def getSymbolAngle(self, symbolId) -> float:
		r"""
		return the symbol angle from the symbol ID 
		Params:
			symbolId (int): symbol Id
		Returns:
			float: 
		"""
		pass


	def getSymbolPen(self, symbolId) -> int:
		r"""
		return the symbol pen from the symbol ID 
		Params:
			symbolId (int): symbol Id
		Returns:
			int: 
		"""
		pass


	def setVisualiseRidigityOff(self) -> IFStoreyGroup:
		r"""
		switch off constraint equation visualisation 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setVisualiseRidigityOn(self) -> IFStoreyGroup:
		r"""
		switch on constraint equation visualisation 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setVisualiseLoadingOff(self) -> IFStoreyGroup:
		r"""
		switch off loading visualisation 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setVisualiseLoadingOn(self) -> IFStoreyGroup:
		r"""
		switch on loading visualisation 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setVisualiseSymbolsOff(self) -> IFStoreyGroup:
		r"""
		switch off symbol visualisation 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def setVisualiseSymbolsOn(self) -> IFStoreyGroup:
		r"""
		switch on symbol visualisation 
		Returns:
			IFStoreyGroup: 
		"""
		pass


	def havePrimaryPosition(self) -> bool:
		r"""
		return true if the storey has a primary location 
		Returns:
			bool: 
		"""
		pass


	def havePrimaryNode(self) -> bool:
		r"""
		return true if the storey has a valid node object at the primary location 
		Returns:
			bool: 
		"""
		pass


	def getPrimaryNode(self) -> IFNode:
		r"""
		return the node object at the primary location 
		Returns:
			IFNode: 
		"""
		pass


	def getMass(self) -> list:
		r"""
		return the building storey primary location mass 
		Returns:
			array: 
		"""
		pass


	def getLoading(self, loadcase) -> list:
		r"""
		return the building storey primary location loads for a loadcase 
		Params:
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. loadcase
		Returns:
			array: 
		"""
		pass


class IFRailTrackDefinition(IFDatabaseMember):
	"""
	Used for railway loading, formed by two rails; Defined by a path representing the centrline and a width, which specifies how far apart the two rails are 
	"""

	def getCentrelinePath(self) -> IFReferencePath:
		r"""
		Returns the centreline for the track 
		Returns:
			IFReferencePath: path representing the centreline
		"""
		pass


	def setWidth(self, width) -> None:
		r"""
		Sets the width of the track 
		Params:
			width (float): width of the track
		Returns:
			None: 
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Sets object name 
		Params:
			newName (str): the new name
		Returns:
			None: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns the name of this track 
		Returns:
			str: name of this rail track)
		"""
		pass


	def writeGeometryXMLFile(self, fileName) -> None:
		r"""
		Write the definition of the centreline path to the geomerty.xml file used by TLO 
		Params:
			fileName (str): name of the file
		Returns:
			None: 
		"""
		pass


	def closeEnd(self, doClose) -> None:
		r"""
		Specify if the loading can go past the end of the track 
		Params:
			doClose (bool): true if the loading can go past the end of the track, false otherwise
		Returns:
			None: 
		"""
		pass


	def closeStart(self, doClose) -> None:
		r"""
		Specify if the loading can go before the start of the track 
		Params:
			doClose (bool): true if the loading can go before the start of the track, false otherwise
		Returns:
			None: 
		"""
		pass


	def setVisible(self, isVisible) -> None:
		r"""
		Shows or hides the rail track definition. Applies to curent view only 
		Params:
			isVisible (bool): True for visible
		Returns:
			None: 
		"""
		pass


class IFRailTrackLayout(IFDatabaseMember):
	"""
	Used for railway loading, formed by one or more rail track definitions 
	"""

	def addTrackDefinition(self, trackDefVar) -> None:
		r"""
		Add a track definition to the rail layout 
		Params:
			trackDefVar (name/IFRailTrackDefinition): 
		Returns:
			None: 
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Sets object name 
		Params:
			newName (str): the new name
		Returns:
			None: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Returns the name of this track layout 
		Returns:
			str: name of this rail track layout)
		"""
		pass


	def getTracks(self) -> list:
		r"""
		Return an array of the tracks in this railway layout 
		Returns:
			array of tracks: Returned array
		"""
		pass


	def writeGeometryXMLFile(self, fileName) -> None:
		r"""
		Write the definitions of the rail tracks to the geomerty.xml file used by TLO 
		Params:
			fileName (str): name of the file
		Returns:
			None: 
		"""
		pass


	def setVisible(self, isVisible) -> None:
		r"""
		Shows or hides the rail track layout. Applies to curent view only 
		Params:
			isVisible (bool): True for visible
		Returns:
			None: 
		"""
		pass


class IFAnnotation(IFDatabaseMember):
	"""
	Base class for all annotation 
	"""

	def getTypeCode(self) -> int:
		r"""
		Returns the type code of this object, taken from the following table: 12: Text Annotation 13: Line Annotation 14: Polygon Annotation 15: Arrow Annotation 16: Bitmap Annotation 17: Symbol Annotation 18: Annotation Group 
		Returns:
			int: 
		"""
		pass


	def setPosition(self, X, Y=None, Z=None) -> None:
		r"""
		Move the annotation to the position specified For annotations with size (bitmaps, polygons, arrows etc) this function sets the anchor or start position, and the rest of the object is moved accordingly without distortion 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def fixToFrame(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def fixToModel(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def showInAllViews(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def showInCurrentView(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def setPen(self, pen) -> None:
		r"""
		 
		Params:
			pen (int): pen number
		Returns:
			None: 
		"""
		pass


	def setName(self, newName) -> None:
		r"""
		Sets object name 
		Params:
			newName (str): 
		Returns:
			None: 
		"""
		pass


	def getName(self) -> str:
		r"""
		Retrieves object name 
		Returns:
			str: 
		"""
		pass


class IFAnnotationBlock(IFAnnotation):
	"""
	A block of annotation, such as a window summary, view border or contour key. See derived classes. 
	"""

	def setFont(self, font) -> None:
		r"""
		Sets the font that will be used in this block. 
		Params:
			font (str): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
		Returns:
			None: 
		"""
		pass


	def setLineSpacingFactor(self, factor) -> None:
		r"""
		Sets the factor that will be multiplied by the text height to define the spacing between lines. 
		Params:
			factor (float): 
		Returns:
			None: 
		"""
		pass


class IFKeyAnnotation(IFAnnotationBlock):
	"""
	A block of annotation used for a colour-coded key, for example the contour key 
	"""

	def setSymbolsAndValues(self, symbols, values) -> None:
		r"""
		Sets up a key as a column of symbols, with a textual value for each symbol. 
		Params:
			symbols (array of symbols): 
			values (array of strs): 
		Returns:
			None: 
		"""
		pass


	def setSymbolPens(self, pens) -> None:
		r"""
		Sets an array of pens to be used for the drawing of the symbols defined using IFKeyAnnotation.setSymbolsAndValues. If not called, the symbols will be drawn using the same pen as used for the text, which can be changed using IFAnnotation.setPen 
		Params:
			pens (array of pens): 
		Returns:
			None: 
		"""
		pass


class IFBorderAnnotation(IFAnnotationBlock):
	"""
	Border annotation. Shows LUSAS version, model title, date and units. Create and destroy a border using IFView.showViewBorder 
	"""

	def setBorders(self, top, left, bottom, right) -> None:
		r"""
		By default the border is drawn 6mm in from each side, but this may be changed using this function. 
		Params:
			top (float): margins in mm
			left (float): 
			bottom (float): 
			right (float): 
		Returns:
			None: 
		"""
		pass


	def setClipping(self, isClip) -> None:
		r"""
		Determines whether or not the model shows 'through' and outside the border. With the flag set true (the default) the model is clipped so that the border is shown on a plain background. With the flag set false, the model shows through, and the border is drawn on top. 
		Params:
			isClip (bool): true to clip model to be within this border
		Returns:
			None: 
		"""
		pass


class IFTextAnnotation(IFAnnotation):
	"""
	Annotation text 
	"""

	def setColour(self, r, g, b) -> None:
		r"""
		Sets annotation text colour 
		Params:
			r (float): amount of red   0...255
			g (float): amount of green   0...255
			b (float): amount of blue   0...255
		Returns:
			None: 
		"""
		pass


	def setTextType(self, type) -> None:
		r"""
		Sets annotation text type 
		Params:
			type (str): "User defined", "Model file name", "Model title", "Model creation date", "Model saved date", "Current date", "Model creation version", "Model saved version", "Current version"
		Returns:
			None: 
		"""
		pass


	def setFont(self, font) -> None:
		r"""
		Sets annotation font 
		Params:
			font (str): font i.e. "Arial;120;Normal;NoItalic;NoUnderline;NoStrikeOut;0;"
		Returns:
			None: 
		"""
		pass


	def setRotation(self, angle) -> None:
		r"""
		Sets annotation text rotation 
		Params:
			angle (float): Angle of text in degrees
		Returns:
			None: 
		"""
		pass


	def setText(self, text) -> None:
		r"""
		Sets annotation text 
		Params:
			text (str): User defined text
		Returns:
			None: 
		"""
		pass


	def addLine(self, text) -> None:
		r"""
		Adds additional lines of annotation text 
		Params:
			text (str): User defined text
		Returns:
			None: 
		"""
		pass


	def setAlignTop(self) -> None:
		r"""
		Sets annotation text alignment 
		Returns:
			None: 
		"""
		pass


	def setAlignBottom(self) -> None:
		r"""
		Sets annotation text alignment 
		Returns:
			None: 
		"""
		pass


	def setAlignVCentre(self) -> None:
		r"""
		Sets annotation text alignment 
		Returns:
			None: 
		"""
		pass


	def setAlignLeft(self) -> None:
		r"""
		Sets annotation text alignment 
		Returns:
			None: 
		"""
		pass


	def setAlignRight(self) -> None:
		r"""
		Sets annotation text alignment 
		Returns:
			None: 
		"""
		pass


	def setAlignHCentre(self) -> None:
		r"""
		Sets annotation text alignment 
		Returns:
			None: 
		"""
		pass


class IFLineAnnotation(IFAnnotation):
	"""
	Annotation line 
	"""

	def setStartPos(self, X, Y=None, Z=None) -> None:
		r"""
		Sets start position of annotation line 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def setEndPos(self, X, Y=None, Z=None) -> None:
		r"""
		Sets end position of annotation line 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


class IFPolygonAnnotation(IFAnnotation):
	"""
	Annotation polygon 
	"""

	def wipeCoords(self) -> None:
		r"""
		Removes current polygon points from existing object 
		Returns:
			None: 
		"""
		pass


	def addCoord(self, X, Y=None, Z=None) -> None:
		r"""
		Adds a new polygon point 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def setFill(self, isFill) -> None:
		r"""
		Sets polygon fill option 
		Params:
			isFill (bool): 
		Returns:
			None: 
		"""
		pass


class IFArrowAnnotation(IFAnnotation):
	"""
	Annotation arrow 
	"""

	def setStartPos(self, X, Y=None, Z=None) -> None:
		r"""
		Sets arrow start position 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def setEndPos(self, X, Y=None, Z=None) -> None:
		r"""
		Sets arrow end position 
		Params:
			X (object): Array of 3 real numbers representing a coordinate axis in 3D space.
			Y (object, optional): 
			Z (object, optional): 
		Returns:
			None: 
		"""
		pass


	def setArrowAngle(self, angle) -> None:
		r"""
		Sets arrow head angle 
		Params:
			angle (float): Angle of arrow head in degrees
		Returns:
			None: 
		"""
		pass


	def setArrowHeadRadius(self, headRadius) -> None:
		r"""
		Sets arrow head radius 
		Params:
			headRadius (float): radius of circle in mm of enclosing arrow head when point of arrow at centre of circle
		Returns:
			None: 
		"""
		pass


class IFSymbolAnnotation(IFAnnotation):
	"""
	Annotation symbol 
	"""

	def setSymbol(self, symbol) -> None:
		r"""
		Sets annotation symbol 
		Params:
			symbol (str): name of symbol - one of "Asterisk", "Barred X", "Boxed cross", "Circle", "Cross", "Diamond", "Double triangle", "Horizontal Arrow", "Letter X", "Letter Y", "Letter Z", "Reverse arrow", "Square", "Triangle", "Vertical Arrow", "Vertical line"
		Returns:
			None: 
		"""
		pass


	def setSize(self, size) -> None:
		r"""
		Sets annotation symbol size in mm 
		Params:
			size (float): size of symbol
		Returns:
			None: 
		"""
		pass


	def setAngle(self, angle) -> None:
		r"""
		Sets angle of annotation symbol 
		Params:
			angle (float): angle to rotate symbol (degrees anticlockwise)
		Returns:
			None: 
		"""
		pass


class IFBitmapAnnotation(IFAnnotation):
	"""
	Annotation bitmap 
	"""

	def setHeight(self, heightMM) -> None:
		r"""
		Sets bitmap height 
		Params:
			heightMM (float): height in mm
		Returns:
			None: 
		"""
		pass


	def setFilename(self, filename) -> None:
		r"""
		Sets bitmap filename 
		Params:
			filename (str): bitmap filename
		Returns:
			None: 
		"""
		pass


class IFTabulateDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFTabulateDataObj:
		r"""
		Sets all default values 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setPlotFileOn(self) -> IFTabulateDataObj:
		r"""
		Adds the plot file datachapter to the export files 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setPlotFileOff(self) -> IFTabulateDataObj:
		r"""
		Excludes the plot file datachapter from the export files 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setRestartFileOn(self) -> IFTabulateDataObj:
		r"""
		Adds the restart file datachapter to the export files 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setRestartFileOff(self) -> IFTabulateDataObj:
		r"""
		Excludes the restart file datachapter from the export files 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setSearchAreaFileOn(self) -> IFTabulateDataObj:
		r"""
		Exports the search area topology in an influence line analysis 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setSearchAreaFileOff(self) -> IFTabulateDataObj:
		r"""
		Do not export the search area topology in an influence line analysis 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setRealsPerLine(self, perLine) -> IFTabulateDataObj:
		r"""
		Sets up the number of real numbers to be output on a single line of data 
		Params:
			perLine (int): 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setIntsPerLine(self, perLine) -> IFTabulateDataObj:
		r"""
		Sets up the number of integer numbers to be output on a single line of data 
		Params:
			perLine (int): 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setInfluenceLine(self, influenceLine) -> IFTabulateDataObj:
		r"""
		Sets up the influence line attribute to be used, therefore specifying an influence line analysis 
		Params:
			influenceLine (IFInfluence): The name or ID of a influenceline, or a pointer to a IFInfluence object.
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setAnalysis(self, analysis) -> IFTabulateDataObj:
		r"""
		Sets up which analysis is to be tabulated 
		Params:
			analysis (str): Name of analysis
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setInfluenceLineAssignment(self, influenceLine, assignment) -> IFTabulateDataObj:
		r"""
		Sets up the influence line assignment to be used, therefore specifying an influence line analysis 
		Params:
			influenceLine (IFInfluence): The name or ID of a influenceline, or a pointer to a IFInfluence object.
			assignment (IFAssignment): The name or ID of a assignment, or a pointer to a IFAssignment object.
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setInfluenceLineOff(self) -> IFTabulateDataObj:
		r"""
		Removes the influence line attribute previously used to specify an influence line analysis, therefore returning to a normal analysis 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setInfluenceLineAssignmentOff(self) -> IFTabulateDataObj:
		r"""
		Removes the influence line assignment previously used to specify an influence line analysis, therefore returning to a normal analysis 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setSearchAreaFilename(self, filename) -> IFTabulateDataObj:
		r"""
		Sets up the filename for the search area topology in an influence line analysis 
		Params:
			filename (str): 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setInfluenceSearchArea(self, searchArea) -> IFTabulateDataObj:
		r"""
		Sets up the search area attribute to be used in an influence line analysis 
		Params:
			searchArea (IFSearchArea): The name or ID of a searcharea, or a pointer to a IFSearchArea object.
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setInfluenceSearchAreaOff(self) -> IFTabulateDataObj:
		r"""
		Removes the search area attribute to be used in an influence line analysis 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setSolveAllLoadcases(self, all) -> IFTabulateDataObj:
		r"""
		Overrides (without modifying) the boolean stored by each loadcase that dictates whether or not it will take part in an analysis. Thus, this is the difference between 'solve all' and 'solve selected'. Default TRUE. 
		Params:
			all (bool): else follow each loadcase's own setting
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setAlwaysTabDeactivateOn(self) -> IFTabulateDataObj:
		r"""
		Always tabulate deactivated elements irrespective of the element status 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setAlwaysTabDeactivateOff(self) -> IFTabulateDataObj:
		r"""
		Only tabulate deactivated elements if not previously deactivated 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setAlwaysTabActivateOn(self) -> IFTabulateDataObj:
		r"""
		Always tabulate activated elements irrespective of the element status 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setAlwaysTabActivateOff(self) -> IFTabulateDataObj:
		r"""
		Only tabulate activated elements if not previously activated 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def setWithoutPrestress(self, without) -> IFTabulateDataObj:
		r"""
		Request a datafile that omits all tendon loading 
		Params:
			without (bool): T: Tabulate without prestress tendon loading. F: Tabulate as normal
		Returns:
			IFTabulateDataObj: 
		"""
		pass


class IFExportNasDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportNasDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportNasDataObj: 
		"""
		pass


class IFExportAnsysDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportAnsysDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportAnsysDataObj: 
		"""
		pass


class IFExportAbaqusDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportAbaqusDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportAbaqusDataObj: 
		"""
		pass


	def setUsePartInstance(self, flag) -> IFExportAbaqusDataObj:
		r"""
		Set Abaqus .inp export format 
		Params:
			flag (bool): if true export in part/instance/assembly format
		Returns:
			IFExportAbaqusDataObj: 
		"""
		pass


class IFExportIgesDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportIgesDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportIgesDataObj: 
		"""
		pass


class IFExportStepDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportStepDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportStepDataObj: 
		"""
		pass


class IFExportBimDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportBimDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportBimDataObj: 
		"""
		pass


	def setDomainType(self, domainType) -> IFExportBimDataObj:
		r"""
		Sets the BIM export domain type 
		Params:
			domainType (str): domain name
		Returns:
			IFExportBimDataObj: 
		"""
		pass


class IFExportDxfDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportDxfDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportDxfDataObj: 
		"""
		pass


class IFExportMidasDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportMidasDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportMidasDataObj: 
		"""
		pass


class IFExportSap2kDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportSap2kDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportSap2kDataObj: 
		"""
		pass


class IFExportScriptDataObj(IFExportDataObj):
	"""
	options object for export(vbs) command 
	"""

	def setAllDefaults(self) -> IFExportScriptDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportScriptDataObj: 
		"""
		pass


	def setLanguage(self, language) -> IFExportScriptDataObj:
		r"""
		Sets the scripting language used to export the model 
		Params:
			language (str): 
		Returns:
			IFExportScriptDataObj: 
		"""
		pass


class IFExportCmdDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportCmdDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportCmdDataObj: 
		"""
		pass


class IFExportStlDataObj(IFExportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFExportStlDataObj:
		r"""
		Sets all default values 
		Returns:
			IFExportStlDataObj: 
		"""
		pass


class IFImportIgesDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportIgesDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def setTranslateAnnotationOn(self) -> IFImportIgesDataObj:
		r"""
		Creates geometry from entities marked in the IGES file as annotation 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def setTranslateAnnotationOff(self) -> IFImportIgesDataObj:
		r"""
		Ignores entities marked in the IGES file as annotation 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def setTranslateBlankedOn(self) -> IFImportIgesDataObj:
		r"""
		Creates geometry from entities marked in the IGES file as blank 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def setTranslateBlankedOff(self) -> IFImportIgesDataObj:
		r"""
		Ignores entities marked in the IGES file as blank 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def setMergeTrimmingLinesOn(self) -> IFImportIgesDataObj:
		r"""
		Merges continuous trimming lines into a single trimming line 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def setMergeTrimmingLinesOff(self) -> IFImportIgesDataObj:
		r"""
		Do not merge trimming lines 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


class IFImportDxfDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportDxfDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportDxfDataObj: 
		"""
		pass


class IFImportCmdDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportCmdDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportCmdDataObj: 
		"""
		pass


class IFImportPatranDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportPatranDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportPatranDataObj: 
		"""
		pass


class IFImportStlDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportStlDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportStlDataObj: 
		"""
		pass


	def setCoalesceFacetsOn(self) -> IFImportStlDataObj:
		r"""
		Coalesces facets 
		Returns:
			IFImportStlDataObj: 
		"""
		pass


	def setCoalesceFacetsOff(self) -> IFImportStlDataObj:
		r"""
		Do not coalesce facets 
		Returns:
			IFImportStlDataObj: 
		"""
		pass


class IFImportDatFileDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportDatFileDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportDatFileDataObj: 
		"""
		pass


	def setCoalesceSurfacesOn(self) -> IFImportDatFileDataObj:
		r"""
		Coalesces element faces 
		Returns:
			IFImportDatFileDataObj: 
		"""
		pass


	def setCoalesceSurfacesOff(self) -> IFImportDatFileDataObj:
		r"""
		Do not coalesce element faces 
		Returns:
			IFImportDatFileDataObj: 
		"""
		pass


	def setCoalesceVolumesOn(self) -> IFImportDatFileDataObj:
		r"""
		Coalesces solid elements 
		Returns:
			IFImportDatFileDataObj: 
		"""
		pass


	def setCoalesceVolumesOff(self) -> IFImportDatFileDataObj:
		r"""
		Do not coalesce solid elements 
		Returns:
			IFImportDatFileDataObj: 
		"""
		pass


	def setFileType(self, fileType) -> IFImportDatFileDataObj:
		r"""
		set the file type either Lusas solver data file or Nastran bulk data file 
		Params:
			fileType (str): 
		Returns:
			IFImportDatFileDataObj: 
		"""
		pass


	def setMaxNumberMatlGroups(self, numberGroups) -> IFImportDatFileDataObj:
		r"""
		set the maximum number of groups to be created from element material or composite properties 
		Params:
			numberGroups (int): 
		Returns:
			IFImportDatFileDataObj: 
		"""
		pass


class IFImportStepFileDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportStepFileDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportStepFileDataObj: 
		"""
		pass


class IFImportBimFileDataObj(IFImportDataObj):
	"""
	 
	"""

	def setAllDefaults(self) -> IFImportBimFileDataObj:
		r"""
		Sets all default values 
		Returns:
			IFImportBimFileDataObj: 
		"""
		pass


class IFImportInfFileDataObj(IFImportDataObj):
	"""
	 
	"""

class IFImportFiberSimDataObj(IFImportDataObj):
	"""
	 
	"""

class IFPrintResultsWindow(IFGridWindow):
	"""
	Interface to the output windows of Modeller's Print Results Wizard 
	"""

	def getData(self, tabName) -> list:
		r"""
		Retrieve the contents of the  grid. The output will be a 2d array of double precision values, even if the cell contents are actually integers. 
		Params:
			tabName (str): The name of the tab to access
		Returns:
			array of variants: The values of the cells
		"""
		pass


	def getColHeaders(self, tabName) -> list[str]:
		r"""
		Retrieve the header strings, to assist with interpreting the values retrieved by IFPrintResultsWindow.getData 
		Params:
			tabName (str): The name of the tab to access
		Returns:
			array of strs: The text of the headers
		"""
		pass


class IFLPIGridWindow(IFGridWindow):
	"""
	A generic tabbed grid output window that can be created and filled with any data 
	"""

	def createTab(self, tabName, title=None) -> None:
		r"""
		Create a new tab in the grid view. A frame title may be given, which will be shown as the title of the window when the new tab is made active. If not given, the tab name will be used for this purpose too. 
		Params:
			tabName (str): The name of the tab to create
			title (str, optional): The frame title to be shown when the tab is active
		Returns:
			None: 
		"""
		pass


	def createLoadsetTab(self, primaryComponent, ID, resFile=None, eigen=None, harm=None) -> str:
		r"""
		Create a new tab in the grid view, which will represent the given loadset. This is equivalent to IFLPIGridWindow.createTab(loadset.getName() & "(" & primaryComponent & ")") except that modeller will also attach the correct icon to the tab. For loadsets that do not support primary components, the primary component will be ignored and will not appear in brackets. Returns the generated name of the new tab, suitable for passing to IFLPIGridWindow.setRowHeaders and IFLPIGridWindow.setData 
		Params:
			primaryComponent (str): Primary component (if any)
			ID (object): IFLoadset object, loadset ID or loadset name. // -1 means 'all loadcases'
			resFile (int, optional): default = 0   //
			eigen (int, optional): default = -1  // -1 means 'not an eigenvalue'
			harm (int, optional): default = -1  // -1 means 'not a harmonic'
		Returns:
			str: The name of the tab
		"""
		pass


	def setRowHeaders(self, tabName, headers) -> None:
		r"""
		Specify the headers of the rows of the grid. If IFLPIGridWindow.setData() has already been called, it is an error for the size of the given array to not match the size specified in IFLPIGridWindow.setData(). If this function is not called, the row headers will be "1", "2", "3", etc 
		Params:
			tabName (str): The name of the tab to modify
			headers (array of strs): The text of the headers
		Returns:
			None: 
		"""
		pass


	def setColHeaders(self, tabName, headers) -> None:
		r"""
		Specify the headers of the columns of the grid. If IFLPIGridWindow.setData() has already been called, it is an error for the size of the given array to not match the size specified in IFLPIGridWindow.setData(). If this function is not called, the column headers will be "A", "B", "C", etc 
		Params:
			tabName (str): The name of the tab to modify
			headers (array of strs): The text of the headers
		Returns:
			None: 
		"""
		pass


	def setData(self, tabName, data, doColHeaders=None, doRowHeaders=None, allowSort=None) -> None:
		r"""
		Set the contents of each cell in the grid. It is an error to call either IFLPIGridWindow.setColHeaders() or IFLPIGridWindow.setRowHeaders() with different sizes than those in the given array. Optionally, LUSAS can automatically duplicate the first row (or the first column, or both) of the given data into the grid header cells. This is consistent with the LUSAS Print Results Wizard and allows the user to conveniently copy and paste the data with the header information. It is an error to choose to do this, and also to specify the header information using IFLPIGridWindow.setColHeaders() (or IFLPIGridWindow.setRowHeaders(), as appropriate) 
		Params:
			tabName (str): The name of the tab to modify
			data (array of variants): The contents of the cells
			doColHeaders (bool, optional): If true (the default), the first row of data will be copied into the column headers. If false, the headers must be separately specified
			doRowHeaders (bool, optional): If true (the default), the first column of data will be copied into the row headers. If false, the headers must be separately specified
			allowSort (bool, optional): If true (the default), the end user is allowed to sort the data using a context menu. If false, the sort UI is disabled
		Returns:
			None: 
		"""
		pass


	def getRowHeaders(self, tabName) -> list[str]:
		r"""
		Retrieve the header strings previously set with IFLPIGridWindow.setRowHeaders() 
		Params:
			tabName (str): The name of the tab to access
		Returns:
			array of strs: The text of the headers
		"""
		pass


	def getColHeaders(self, tabName) -> list[str]:
		r"""
		Retrieve the header strings previously set with IFLPIGridWindow.setColHeaders() 
		Params:
			tabName (str): The name of the tab to access
		Returns:
			array of strs: The text of the headers
		"""
		pass


	def getData(self, tabName) -> list:
		r"""
		Retrieve the contents of the grid previously set with IFLPIGridWindow.setData() 
		Params:
			tabName (str): The name of the tab to access
		Returns:
			array of variants: The values of the cells
		"""
		pass


class IFVLOGridWindow(IFGridWindow):
	"""
	A tabbed grid output window that shows results computed by VLO 
	"""

	pass


class IFAnalysis(IFAnalysisBaseClass):
	"""
	Analysis interface 
	"""

	def setAsBase(self) -> IFAnalysis:
		r"""
		Set this analysis as the base analysis 
		Returns:
			IFAnalysis: 
		"""
		pass


	def setInheritFromBase(self, attributeType) -> IFAnalysis:
		r"""
		Specify an attribute type that can be inherited from base analysis 
		Params:
			attributeType (str): Attribute type
		Returns:
			IFAnalysis: Return this object
		"""
		pass


	def isAllowedToOverrideAssignments(self) -> bool:
		r"""
		Determine whether the assignments from base analysis may be overridden 
		Returns:
			bool: Return TRUE if the assignments may be overridden from base analysis
		"""
		pass


	def isStartWithUndeformedMesh(self) -> bool:
		r"""
		Determine whether the analysis will start with a deformed or undeformed mesh 
		Returns:
			bool: Return TRUE if the analysis will start with undeformed mesh
		"""
		pass


	def setUndeformedMeshStart(self) -> IFAnalysis:
		r"""
		Indicates that this analysis should start with an undeformed mesh Calling this function clears any settings previously set using IFAnalysisBaseClass.setRestartFromDump or IFAnalysisBaseClass.setRestartFromLoadcase 
		Returns:
			IFAnalysis: Return this object
		"""
		pass


	def setDeformedMeshStart(self, loadcase, timestep, factor) -> IFAnalysis:
		r"""
		Sets up the loadset from which the starting deformations for this analysis will be taken, and the factor that will be applied to those deformations. Calling this function clears any settings previously set using IFAnalysisBaseClass.setRestartFromDump or IFAnalysisBaseClass.setRestartFromLoadcase 
		Params:
			loadcase (IFLoadcase): The name or ID of a loadcase, or a pointer to a IFLoadcase object. Model loadcase from which results should be taken
			timestep (int): Index of time step, increment or eigenvalue within the results of given loadcase (-1 means "last")
			factor (float): factor
		Returns:
			IFAnalysis: Return this object
		"""
		pass


	def getDeformationsScaleFactor(self) -> float:
		r"""
		Get the deformations scale factor 
		Returns:
			float: 
		"""
		pass


	def setCoupled(self, analysis) -> IFAnalysis:
		r"""
		Sets up the coupling relationship between two analyses. Note - coupled analyses in LUSAS are currently limited to just one structural analysis and just one thermal analysis. Pass in false to indicate that this analysis is not coupled with any other. 
		Params:
			analysis (IFAnalysis): The name or ID of a analysis, or a pointer to a IFAnalysis object. the analysis to couple with
		Returns:
			IFAnalysis: Return this object
		"""
		pass


	def createCopyForPrestress(self, name, attributes) -> IFAnalysis:
		r"""
		Creates a new analysis with the name given. All loadcases in "this" analysis will be replicated in the new analysis. Additionally, discrete load attributes and search area attributes will be created and assigned as necessary to mimic all the prestress �internal workings� for the specified tendon load attributes. Any other assignments that may exist (material, geometric, etc) will also be duplicated into the new analysis � but no other loading. Any tendon loads not explicitly specified will also be excluded. 
		Params:
			name (str): name of the new analysis
			attributes (array): Names and/or numbers of IFLoadingTendon attributes. If empty, all tendon load attributes will be used.
		Returns:
			IFAnalysis: the new analysis that has been created
		"""
		pass


	def setAnalysisType(self, type) -> None:
		r"""
		Changes this analysis between "Nonlinear and transient", "linear", "eigen", or "phi-c". Note - It is your responsibility to modify or remove any inappropriate controls, assignments or settings 
		Params:
			type (str or int): new type
		Returns:
			None: 
		"""
		pass


	def getAnalysisType(self) -> str:
		r"""
		Returns whether this analysis is "Nonlinear and transient", "linear", "eigen", or "phi-c" 
		Returns:
			str: 
		"""
		pass


	def renumberLoadsets(self, startingValue, branchesToo) -> None:
		r"""
		Renumbers the loadcases and load curves within this analysis to start with the given ID number, optionally descending into any branches that may be defined. Note that the given ID is updated such that on return it is suitable for passing to another call to renumber another group or analysis Note that other analyses will not be disturbed, so IDs will not necessarily be contiguous (See IFDatabase.renumberLoadsets) 
		Params:
			startingValue (int): first new ID to use, reset on exit
			branchesToo (bool): 
		Returns:
			None: 
		"""
		pass


	def setPrestressOptions(self, primarySecondary, excluding, primaryLosses, nSolves, percent) -> None:
		r"""
		Set the prestress options for this analysis 
		Params:
			primarySecondary (bool): Provide primary and secondary prestress effects
			excluding (bool): Provide results excluding prestress effects
			primaryLosses (bool): Provide primary effects associated with tendon losses
			nSolves (int): Number of solves to determine post-installation losses
			percent (float): Percentage reduction of length for end load placement
		Returns:
			None: 
		"""
		pass


	def getPrestressOptions(self, primarySecondary, excluding, primaryLosses, nSolves, percent) -> None:
		r"""
		Retrieve the prestress options for this analysis, previously set by IFAnalysis.setPrestressOptions 
		Params:
			primarySecondary (bool): Provide primary and secondary prestress effects
			excluding (bool): Provide results excluding prestress effects
			primaryLosses (bool): Provide primary effects associated with tendon losses
			nSolves (int): Number of solves to determine post-installation losses
			percent (float): Percentage reduction of length for end load placement
		Returns:
			None: 
		"""
		pass


class IFTLOEnvelopeRun(IFTLORunBase):
	"""
	TLO (Trafic Loading Optimization) envelope run interface 
	"""

	def addInfluenceToAnalyse(self, infEnvelopeAttr) -> None:
		r"""
		Adds an influence assignment to be analysed by this VLO run 
		Params:
			infEnvelopeAttr (IFInfluenceEnvelope): influence envelope attribute to analyse
		Returns:
			None: 
		"""
		pass


	def getInfluenceEnvelopes(self) -> list:
		r"""
		Returns all influence assignments to be analysed by this VLO run 
		Returns:
			array of FInfluenceEnvelope objects: The returned array
		"""
		pass


	def removeAllInfs(self) -> None:
		r"""
		Remove all influence envelopes to analyse 
		Returns:
			None: 
		"""
		pass


	def createInfDesignLoadset(self, name, infAttrName, infDir) -> IFTLOEnvelope:
		r"""
		Create a TLO envelope in this TLO envelope run Note: signature needed to avoid type checking in .NET (VLOInputData); see function with the same name in IFVLORun 
		Params:
			name (str): 
			infAttrName (str): influence attribute name
			infDir (int): Influence direction (1 for positive, -1 for negative)
		Returns:
			IFTLOEnvelope: 
		"""
		pass


	def getTLOEnvelope(self, name) -> IFLoadset:
		r"""
		Return the TLO Envelope with this name 
		Params:
			name (str): name of the TLO Envelope to get
		Returns:
			IFLoadset: TLO Envelope
		"""
		pass


	def getActiveTLOEnvelope(self) -> IFLoadset:
		r"""
		Return the active TLO Envelope or null if none is set active 
		Returns:
			IFLoadset: TLO Envelope
		"""
		pass


	def getEnvelopeMode(self) -> int:
		r"""
		Not relevant in this derived interface - this will always return 0 (will not create 'normal' envelopes) 
		Returns:
			int: 
		"""
		pass


	def TLOHasFinished(self) -> None:
		r"""
		Used by TLO informs this run that the analysis has finished 
		Returns:
			None: 
		"""
		pass


	def openResults(self) -> None:
		r"""
		For each TLO Envelope, open available TLO results 
		Returns:
			None: 
		"""
		pass


	def hasResultsLoaded(self) -> bool:
		r"""
		Does this have any results loaded 
		Returns:
			bool: 
		"""
		pass


	def createCopy(self) -> IFTLOEnvelopeRun:
		r"""
		Create a copy of this 
		Returns:
			IFTLOEnvelopeRun: 
		"""
		pass


class IFVLOEnvelopeRun(IFTLOEnvelopeRun):
	"""
	VLO (Vehicle Loading Optimization) envelope run interface 
	"""

	pass


class IFRLOEnvelopeRun(IFTLOEnvelopeRun):
	"""
	RLO (Railway Loading Optimization) envelope run interface 
	"""

	def setRailTrackLayout(self, trackLayout) -> None:
		r"""
		Set the railway layout used for this RLO 
		Params:
			trackLayout (IFRailTrackDefinition): The name or ID of a "trackdefinition", or a pointer to a IFRailTrackDefinition object. railway track layout
		Returns:
			None: 
		"""
		pass


	def getRailTrackLayout(self) -> IFRailTrackLayout:
		r"""
		Get the railway layout used for this RLO 
		Returns:
			IFRailTrackLayout: 
		"""
		pass


	def writeGeometryXMLFile(self, fileName) -> None:
		r"""
		Write the definition of the rail track layout to the geomerty.xml file used by TLO 
		Params:
			fileName (str): name of the file
		Returns:
			None: 
		"""
		pass


class IFVLORun(IFTLORunBase):
	"""
	VLO (Vehicle Loading Optimization) run interface 
	"""

	def setName(self, name) -> None:
		r"""
		Sets the name of this run 
		Params:
			name (str): the new name
		Returns:
			None: 
		"""
		pass


	def deleteLoadcases(self) -> None:
		r"""
		Delete all the loadcases in this VLO run, including any attribute assignments therein 
		Returns:
			None: 
		"""
		pass


	def addInfluenceAssignToAnalyse(self, infObj, loadPositive, loadNegative, includeAditionalPatterns, determinantLength, influencefactor) -> None:
		r"""
		Adds an influence assignment to be analysed by this VLO run 
		Params:
			infObj (IFInfluence): The name or ID of a influence, or a pointer to a IFInfluence object.
			loadPositive (bool): true if positive area should be loaded by TLO
			loadNegative (bool): false if positive area should be loaded by TLO
			includeAditionalPatterns (bool): AASHTO codes only
			determinantLength (float): determinant length (dimension of length)
			influencefactor (float): influence factor (unitless)
		Returns:
			None: 
		"""
		pass


	def getAllInfluenceAssignsToAnalyse(self) -> list[IFVLOInfluenceAssignEntry]:
		r"""
		Returns all influence assignments to be analysed by this VLO run 
		Returns:
			array of IFVLOInfluenceAssignEntry objects: The returned array
		"""
		pass


	def removeAllInfluenceAssignsToAnalyse(self) -> None:
		r"""
		Removes all influence assignments to be analysed by this VLO run 
		Returns:
			None: 
		"""
		pass


	def getInfIncrement(self) -> float:
		r"""
		Get the increment for influence surfaces (used only for Autoloader) 
		Returns:
			float: 
		"""
		pass


	def setInfIncrement(self, value) -> None:
		r"""
		Set the increment for influence surfaces (used only for Autoloader) 
		Params:
			value (float): 
		Returns:
			None: 
		"""
		pass


	def setVLOEngine(self, vloEngine) -> None:
		r"""
		Set VLO engine (0 for Pell F. (autoloader) engine, 1 for FEA engine) 
		Params:
			vloEngine (int): 
		Returns:
			None: 
		"""
		pass


	def getAnalysis(self) -> IFVLOAnalysis:
		r"""
		Return parent analysis 
		Returns:
			IFVLOAnalysis: Returned analysis
		"""
		pass


	def createCopy(self, analysis) -> IFVLORun:
		r"""
		Creates a clone VLO Run 
		Params:
			analysis (IFVLOAnalysis): The name or ID of a "VLOanalysis", or a pointer to a IFVLOAnalysis object. VLO analysis in which to create copy
		Returns:
			IFVLORun: the new VLO run that has been created
		"""
		pass


	def createInfDesignLoadset(self, name, infAttrName, infDir) -> IFVLOInfDesignLoadcase:
		r"""
		Create a influence design loadcase in this VLO run 
		Params:
			name (str): 
			infAttrName (str): influence attribute name
			infDir (int): Influence direction (1 for positive, -1 for negative)
		Returns:
			IFVLOInfDesignLoadcase: 
		"""
		pass


	def createLoadcase(self, name, infDesignLoadcaseName) -> IFLoadcase:
		r"""
		Creates a loadcase inside a influence design loadcase 
		Params:
			name (str): Loadcase name
			infDesignLoadcaseName (str): Name of influence design loadcase in which to create the new loadcase
		Returns:
			IFLoadcase: 
		"""
		pass


	def TLOHasFinished(self) -> None:
		r"""
		TLO informs this run that the analysis has finished 
		Returns:
			None: 
		"""
		pass


	def setOutputMode(self, mode) -> None:
		r"""
		Set how to view the results 
		Params:
			mode (int): solution mode: 0 for "All assignments", 1 for "Most onerous"
		Returns:
			None: 
		"""
		pass


	def getOutputMode(self) -> int:
		r"""
		Get how to view the results 
		Returns:
			int: solution mode: 0 for "All assignments", 1 for "Most onerous"
		"""
		pass


	def setEnvelopeMode(self, mode) -> None:
		r"""
		Set how to create the envelopes 
		Params:
			mode (int): envelope mode: 1 for "Influence and design case", 2 for "Design case"; 0 will not create envelopes
		Returns:
			None: 
		"""
		pass


	def getEnvelopeMode(self) -> int:
		r"""
		Get how to create the envelopes 
		Returns:
			int: envelope mode: 1 for "Influence and design case", 2 for "Design case"; 0 will not create envelopes
		"""
		pass


	def setViewResultsTbl(self, val) -> None:
		r"""
		set flag to view the results table after the VLO analysis completed 
		Params:
			val (bool): boolean
		Returns:
			None: 
		"""
		pass


	def getViewResultsTbl(self) -> bool:
		r"""
		get flag to view the results table after the VLO analysis completed 
		Returns:
			bool: boolean
		"""
		pass


	def includeHorizontalCmpForLoading(self) -> bool:
		r"""
		return true if the TLO results are meaningful so that the table can be shown 
		Returns:
			bool: boolean
		"""
		pass


	def setIncludeHorizontalCmpForLoading(self, val) -> None:
		r"""
		set flag for whether the results table can be shown 
		Params:
			val (bool): boolean
		Returns:
			None: 
		"""
		pass


	def setCreateLoading(self, val) -> None:
		r"""
		set flag to create loading patterns after the VLO analysis completed 
		Params:
			val (bool): boolean
		Returns:
			None: 
		"""
		pass


	def getCreateLoading(self) -> bool:
		r"""
		get flag to create loading after the VLO analysis completed 
		Returns:
			bool: boolean
		"""
		pass


	def removeInfluenceDesignLoadcase(self, inflDesignLoadcaseName) -> None:
		r"""
		Remove the given influence design loadcase from this VLO run 
		Params:
			inflDesignLoadcaseName (str): name of the influence design loadcase to be removed
		Returns:
			None: 
		"""
		pass


class IFRLORun(IFVLORun):
	"""
	RLO (Railway Loading Optimization) run interface 
	"""

	def setRailTrackLayout(self, trackLayout) -> None:
		r"""
		Set the railway layout used for this RLO 
		Params:
			trackLayout (IFRailTrackDefinition): The name or ID of a "trackdefinition", or a pointer to a IFRailTrackDefinition object. railway track layout
		Returns:
			None: 
		"""
		pass


	def getRailTrackLayout(self) -> IFRailTrackLayout:
		r"""
		Get the railway layout used for this RLO 
		Returns:
			IFRailTrackLayout: 
		"""
		pass


	def writeGeometryXMLFile(self, fileName) -> None:
		r"""
		Write the definition of the rail track layout to the geomerty.xml file used by TLO 
		Params:
			fileName (str): name of the file
		Returns:
			None: 
		"""
		pass


class IFVLOAnalysis(IFAnalysisBaseClass):
	"""
	VLO (Vehicle Loading Optimization) analysis interface 
	"""

	def renumberLoadsets(self, startingValue) -> None:
		r"""
		Renumbers the loadcases and load curves within this analysis to start with the given ID number, Note that the given ID is updated such that on return it is suitable for passing to another call to renumber another group or analysis Note that other analyses will not be disturbed, so IDs will not necessarily be contiguous (See IFDatabase.renumberLoadsets) 
		Params:
			startingValue (int): first new ID to use, reset on exit
		Returns:
			None: 
		"""
		pass


	def isTempAnalysis(self) -> bool:
		r"""
		Is this a temporary analysis? 
		Returns:
			bool: 
		"""
		pass


class IFReciprocalMethodInfAnalysis(IFAnalysisBaseClass):
	"""
	Reciprocal Method Influence Analysis interface 
	"""

	def solveInfluence(self, influenceLine, ignoreModified=None) -> int:
		r"""
		Follows the internal knowledge of "this" to tabulate and solve the given influence. If you set ignoreModified to be true, then LUSAS's internal knowledge is ignored, and the analysis will be solved whether LUSAS thinks it necessary or not. To solve all influences, use IFAnalysisBaseClass.solve. Returns 0 for success, or a failure code from LUSAS solver. 
		Params:
			influenceLine (IFInfluence): The name or ID of a influenceline, or a pointer to a IFInfluence object.
			ignoreModified (bool, optional): default false. Can be set true to ignore the modification state of this and its prerequisites
		Returns:
			int: 
		"""
		pass


	def solveInfluenceAssign(self, influenceLine, assignment, ignoreModified=None) -> int:
		r"""
		Follows the internal knowledge of "this" to tabulate and solve the given influence assignment. If you set ignoreModified to be true, then LUSAS's internal knowledge is ignored, and the analysis will be solved whether LUSAS thinks it necessary or not. To solve all influences, use IFAnalysisBaseClass.solve. Returns 0 for success, or a failure code from LUSAS solver. 
		Params:
			influenceLine (IFInfluence): The name or ID of a influenceline, or a pointer to a IFInfluence object.
			assignment (IFAssignment): The name or ID of a assignment, or a pointer to a IFAssignment object.
			ignoreModified (bool, optional): default false. Can be set true to ignore the modification state of this and its prerequisites
		Returns:
			int: 
		"""
		pass


	def openInfluenceResults(self, influence, scanOutputFiles=None, skipOutOfDate=None) -> None:
		r"""
		Open results for the given influence for this analysis. Note - there is no error for any results which are missing, or need to be solved, or need updating from a previous version. Nonetheless, such files will not be loaded. Optionally (default true) skip any results that LUSAS considers to be out of date. To open results for all influences, use IFAnalysisBaseClass.openResults. 
		Params:
			influence (IFInfluence): The name or ID of a influenceline, or a pointer to a IFInfluence object.
			scanOutputFiles (bool, optional): default true. Can be set false to skip parsing output files and repeating errors and warnings into the text output window
			skipOutOfDate (bool, optional): default true. Can be set false to force LUSAS to load results files it believes to be out of date
		Returns:
			None: 
		"""
		pass


	def openInfluenceAssignResults(self, influenceLine, assignment, scanOutputFiles=None, skipOutOfDate=None) -> None:
		r"""
		Open results for the given influence assignment for this analysis. Note - there is no error for any results which are missing, or need to be solved, or need updating from a previous version. Nonetheless, such files will not be loaded. Optionally (default true) skip any results that LUSAS considers to be out of date. To open results for all influences, use IFAnalysisBaseClass.openResults. 
		Params:
			influenceLine (IFInfluence): The name or ID of a influenceline, or a pointer to a IFInfluence object.
			assignment (IFAssignment): The name or ID of a assignment, or a pointer to a IFAssignment object.
			scanOutputFiles (bool, optional): default true. Can be set false to skip parsing output files and repeating errors and warnings into the text output window
			skipOutOfDate (bool, optional): default true. Can be set false to force LUSAS to load results files it believes to be out of date
		Returns:
			None: 
		"""
		pass


class IFDirectMethodInfAnalysisBase(IFAnalysisBaseClass):
	"""
	Direct Method Influence Analysis Base interface 
	"""

	def setLoadMagnitude(self, magnitude) -> None:
		r"""
		magnitude of the unit load 
		Params:
			magnitude (float): 
		Returns:
			None: 
		"""
		pass


	def setLoadDirection(self, loadDirStr) -> None:
		r"""
		set the direction of the unit load 
		Params:
			loadDirStr (str): 
		Returns:
			None: 
		"""
		pass


	def setSearchArea(self, searchAreaName) -> None:
		r"""
		set the search area 
		Params:
			searchAreaName (str): 
		Returns:
			None: 
		"""
		pass


	def setSearchAssignType(self, type) -> None:
		r"""
		controls the manner in which the loading is applied to the lines in the search area 
		Params:
			type (str): "area","line"
		Returns:
			None: 
		"""
		pass


	def setIsGrillageType(self, type) -> None:
		r"""
		Set if the search area is a grillage type 
		Params:
			type (int): 0 for yes, 1 for no, 2 for unknown
		Returns:
			None: 
		"""
		pass


	def reset(self) -> None:
		r"""
		removes the influence elements created for the grid 
		Returns:
			None: 
		"""
		pass


	def usesSearchArea(self) -> bool:
		r"""
		return true if a search area was specified 
		Returns:
			bool: 
		"""
		pass


	def getSearchArea(self) -> IFSearchArea:
		r"""
		return the search area used 
		Returns:
			IFSearchArea: 
		"""
		pass


class IFDirectMethodInfAnalysis(IFDirectMethodInfAnalysisBase):
	"""
	Direct Method Influence Analysis interface 
	"""

	def setGridCentreline(self, centreline) -> None:
		r"""
		set the path for the grid 
		Params:
			centreline (str): name of the path; if empty, denotes 'nodes in search area' option
		Returns:
			None: 
		"""
		pass


	def setGridWidth(self, width) -> None:
		r"""
		Set the width of the grid 
		Params:
			width (float): 
		Returns:
			None: 
		"""
		pass


	def setDoMatchNodes(self, val) -> None:
		r"""
		Set if the grid should match the nodes in search area (use for line beams models only) 
		Params:
			val (bool): 
		Returns:
			None: 
		"""
		pass


	def setGridLongMinNo(self, longMinNo) -> None:
		r"""
		Set the minimum nr of increments in longitudinal direction 
		Params:
			longMinNo (int): 
		Returns:
			None: 
		"""
		pass


	def setGridLongMaxSpace(self, longMaxSpace) -> None:
		r"""
		Set the maximum longitudinal increment 
		Params:
			longMaxSpace (float): 
		Returns:
			None: 
		"""
		pass


	def setGridTransMinNo(self, transMinNo) -> None:
		r"""
		Set the minimum nr of increments in transverse direction 
		Params:
			transMinNo (int): 
		Returns:
			None: 
		"""
		pass


	def setGridTransMaxSpace(self, transMaxSpace) -> None:
		r"""
		Set the maximum transverse increment 
		Params:
			transMaxSpace (float): 
		Returns:
			None: 
		"""
		pass


	def createElements(self) -> None:
		r"""
		Creates the influence elements; Applicable only when is grid type 
		Returns:
			None: 
		"""
		pass


	def usesGrid(self) -> bool:
		r"""
		return true if the grid option is used, false for 'nodes in search area' 
		Returns:
			bool: 
		"""
		pass


	def showGrid(self, doShowGrid=None) -> None:
		r"""
		switches current grid visibility 
		Params:
			doShowGrid (bool, optional): true/false to show/not show the grid; nothing to switch it to the opposite of the current state
		Returns:
			None: 
		"""
		pass


	def setIncludeMidSideNodes(self, val) -> None:
		r"""
		Set if the midside nodes of quadratic elements should be loaded with the unit load 
		Params:
			val (bool): 
		Returns:
			None: 
		"""
		pass


class IFRailDMIAnalysis(IFDirectMethodInfAnalysisBase):
	"""
	Rail Direct Method Influence Analysis interface 
	"""

	def setRailTrackLayouts(self, trackLayouts) -> None:
		r"""
		Set the track layouts 
		Params:
			trackLayouts (array): array with the names or the rail track layouts
		Returns:
			None: 
		"""
		pass


	def getRailTrackLayoutNames(self) -> list:
		r"""
		return the names of the track layouts used 
		Returns:
			array: array with the names or the rail track layouts
		"""
		pass


class IFReinforcementSection(IFAttribute):
	"""
	Representation of the reinforcement of one cross section 
	"""

	def setGeometricAttribute(self, attribute) -> IFReinforcementSection:
		r"""
		Set the geometric attribute used in the dialog to visualise and validate the reinforcement properties 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. geometric attribute
		Returns:
			IFReinforcementSection: 
		"""
		pass


	def getGeometricAttribute(self) -> IFGeometric:
		r"""
		Get the geometric attribute used in the dialog to visualise and validate the reinforcement properties 
		Returns:
			IFGeometric: 
		"""
		pass


	def setReinforcementValue(self, type, index, varName, value) -> IFReinforcementSection:
		r"""
		Sets the value of a named variable within this object The types correspond directly to the dialog tabs. The named variables correspond directly to the dialog inputs on that tab. For type = "face", the following variables are available: "faceIndex", "actualCover", "linkAllowance", "allowableCrackWidth", "nominalCover". For type = "rebar", the following variables are available: "faceIndex", "layerIndex", "materialRef", "barsCount", "start", "end", "gap", "barsDiameter", "altBarsDiameter", "endBarsDiameter". For type = "additional bar", the following variables are available: "materialRef", "y", "z", "diameter", "allowableCrackWidth", "spacingCrackWidth", "nominalCover". 
		Params:
			type (str): "face", "rebar", "additional bar"
			index (int): row index (in dialog)
			varName (str): name of the value (e.g. "actualCover")
			value (object): The type given will depend on the value specified
		Returns:
			IFReinforcementSection: 
		"""
		pass


	def getReinforcementValue(self, type, index, varName, units=None) -> object:
		r"""
		Returns the value of a named variable within this object If an IFUnitSet object (or its name) is given, the value will be returned in those units. Otherwise it will be returned in the database's current unit system. 
		Params:
			type (str): "face", "rebar", "additional bar"
			index (int): row index
			varName (str): name of the value (e.g. "actualCover")
			units (IFUnitSet, optional): 
		Returns:
			object: The type returned will depend on the value requested
		"""
		pass


	def getFacesCount(self) -> int:
		r"""
		Returns the number of faces (comes from the geometric attribute used for visualisation and validation) 
		Returns:
			int: 
		"""
		pass


	def getLayersCount(self, face) -> int:
		r"""
		Returns the number of reinforcement layers in the given face 
		Params:
			face (int): 
		Returns:
			int: 
		"""
		pass


	def getAdditionalBarsCount(self) -> int:
		r"""
		Returns the number of the additional bars 
		Returns:
			int: 
		"""
		pass


	def getRebar(self, geometricAttr=None) -> list:
		r"""
		Create an array of IFReinforcementSectionBar objects which represents the information in this attribute, applied onto the given section 
		Params:
			geometricAttr (name, id, IFAttribute, optional): ,  the geometric attribute that will be used for calculations.
		Returns:
			array: of IFReinforcementSectionBar objects
		"""
		pass


class IFReinforcementLine(IFAttribute):
	"""
	Representation of the reinforcement of a line, being (essentially) an array of IFReinforcementSection objects, spaced along a line 
	"""

	def setSegmentValue(self, type, index, varName, value) -> IFReinforcementLine:
		r"""
		Sets the named value for the given index segment. Available names are "length" (real), "stretch" (boolean), "reinforcementSection" (IFReinforcementSection) 
		Params:
			type (object): 0 = "longitudinal", 1 = "z shear", 2 = "y shear", 3 = "torsion"
			index (int): segment's index starting from 0
			varName (str): name of the value (e.g. "length")
			value (object): The type given will depend on the value specified
		Returns:
			IFReinforcementLine: 
		"""
		pass


	def getSegmentValue(self, type, index, varName) -> object:
		r"""
		Gets the value for the given index segment 
		Params:
			type (object): 0 = "longitudinal", 1 = "z shear", 2 = "y shear", 3 = "torsion"
			index (int): segment's index starting from 0
			varName (str): name of the value (e.g. "length")
		Returns:
			object: The type given will depend on the value specified
		"""
		pass


	def getSegmentCount(self, type) -> int:
		r"""
		Return the number of reinforcement segments 
		Params:
			type (object): 0 = "longitudinal", 1 = "z shear", 2 = "y shear", 3 = "torsion"
		Returns:
			int: 
		"""
		pass


	def setAdvShearTorsionProps(self, attribute) -> IFReinforcementLine:
		r"""
		Set the attribute that describes the advanced shear and torsion properites of this attribute 
		Params:
			attribute (IFAttribute): The name or ID of a attribute, or a pointer to a IFAttribute object. advanced shear and torsion properties of this attribute
		Returns:
			IFReinforcementLine: 
		"""
		pass


	def getAdvShearTorsionProps(self) -> IFShearTorsionAdvPropsDefinition:
		r"""
		Get the attribute that describes the advanced shear and torsion properites of this attribute 
		Returns:
			IFShearTorsionAdvPropsDefinition: 
		"""
		pass


	def isAdvShearTorsionPropsAuto(self) -> bool:
		r"""
		Are the shear and torsion properties of the section auto calculated ? 
		Returns:
			bool: 
		"""
		pass


class IFCableShape(IFAttribute):
	"""
	Cable Shape attribute 
	"""

	def setCableShape(self, t, v) -> IFCableShape:
		r"""
		Sets the parameters. 
		Params:
			t (int): cable type
			v (float): cable value
		Returns:
			IFCableShape: 
		"""
		pass


class IFStaticMovingLoadAnalysis(IFAnalysis):
	"""
	Implementation of the static moving load analysis wizard 
	"""

	def setStaticMovingLoadAnalysis(self, loadAttr, refPath, searchArea, projectionType, includeProjectionMoments, pathPatchTransform, pathLoadTransform, optionForLoadsOutsideSearchArea, divisionType, nDivisions, distance, direction, createEnvelope) -> IFStaticMovingLoadAnalysis:
		r"""
		Conveniently set all inputs 
		Params:
			loadAttr (IFLoadingDiscreteBase): The name or ID of a load, or a pointer to a IFLoadingDiscreteBase object. Any kind of discrete loading: point, patch or compound loading
			refPath (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object. The reference path along which the load moves
			searchArea (IFSearchArea): The name or ID of a searcharea, or a pointer to a IFSearchArea object. The features that will receive the loading
			projectionType (str): "area" or "line"
			includeProjectionMoments (int or str): "none" (0), "all" (1), "Except those caused by projection" (2), "About X" (3), "About Y" (4), "About Z" (5), "About X and Y" (6), "About X and Z" (7), or "About Y and Z" (8)
			pathPatchTransform (int or str): "none" (0), "horizontal" (1), or "3D" (2)
			pathLoadTransform (int or str): "none" (0), "horizontal" (1), or "3D" (2)
			optionForLoadsOutsideSearchArea (int or str): "Exclude All Load" (0) or "Include Full Load" (1)
			divisionType (str): "Division number" or "Incremental distance"
			nDivisions (int): number of path divisions
			distance (float): distance between two consecutive positions along the path
			direction (str): "Forward" or "Reverse"
			createEnvelope (bool): If true, a loadcase envelope will be created for the generated loadcases
		Returns:
			IFStaticMovingLoadAnalysis: 
		"""
		pass


	def getLoadAttr(self) -> IFLoadingDiscreteBase:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			IFLoadingDiscreteBase: 
		"""
		pass


	def getPathPatchTransform(self) -> str:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getPathLoadTransform(self) -> str:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getSearchArea(self) -> IFSearchArea:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			IFSearchArea: 
		"""
		pass


	def getProjectionType(self) -> str:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getIncludedMoments(self) -> str:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getReferencePath(self) -> IFReferencePath:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			IFReferencePath: 
		"""
		pass


	def getOptionForLoadsOutsideSearchArea(self) -> str:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getDivisionType(self) -> str:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getDivisions(self) -> int:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			int: 
		"""
		pass


	def getDistance(self) -> float:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			float: 
		"""
		pass


	def getDirection(self) -> str:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def isCreateEnvelope(self) -> bool:
		r"""
		return the option set in setStaticMovingLoadAnalysis() 
		Returns:
			bool: 
		"""
		pass


class IFPedestrianMovingLoadAnalysis(IFAnalysis):
	"""
	Implementation of the pedestrian moving load analysis wizard 
	"""

	def setPedestrianMovingLoadAnalysis(self, defn, refPath, searchArea, projectionType, includeProjectionMoments, timeStep, direction) -> IFPedestrianMovingLoadAnalysis:
		r"""
		Conveniently set all inputs 
		Params:
			defn (IFPedestrianLoadDefinition): The name or ID of a loaddefinition, or a pointer to a IFPedestrianLoadDefinition object. COMMENTS NEEDED
			refPath (IFReferencePath): The name or ID of a referencepath, or a pointer to a IFReferencePath object. The reference path along which the load moves
			searchArea (IFSearchArea): The name or ID of a searcharea, or a pointer to a IFSearchArea object. The features that will receive the loading
			projectionType (str): "area" or "line"
			includeProjectionMoments (int or str): "none" (0), "all" (1), "Except those caused by projection" (2), "About X" (3), "About Y" (4), "About Z" (5), "About X and Y" (6), "About X and Z" (7), or "About Y and Z" (8)
			timeStep (float): The analysis' timestep in seconds
			direction (str): "Forward" or "Reverse"
		Returns:
			IFPedestrianMovingLoadAnalysis: 
		"""
		pass


	def getLoadDefinition(self) -> IFPedestrianLoadDefinition:
		r"""
		return the option set in setPedestrianMovingLoadAnalysis() 
		Returns:
			IFPedestrianLoadDefinition: 
		"""
		pass


	def getReferencePath(self) -> IFReferencePath:
		r"""
		return the option set in setPedestrianMovingLoadAnalysis() 
		Returns:
			IFReferencePath: 
		"""
		pass


	def getSearchArea(self) -> IFSearchArea:
		r"""
		return the option set in setPedestrianMovingLoadAnalysis() 
		Returns:
			IFSearchArea: 
		"""
		pass


	def getProjectionType(self) -> str:
		r"""
		return the option set in setPedestrianMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getIncludedMoments(self) -> str:
		r"""
		return the option set in setPedestrianMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


	def getTimeStep(self) -> float:
		r"""
		return the option set in setPedestrianMovingLoadAnalysis() 
		Returns:
			float: 
		"""
		pass


	def getDirection(self) -> str:
		r"""
		return the option set in setPedestrianMovingLoadAnalysis() 
		Returns:
			str: 
		"""
		pass


class IFModeller(IFDispatch):
	"""
	All the functions described here are available as global functions in VBScript. This means that unlike all the other LUSAS Modeller LPI functions, you do not need to prepend calls to them with an object. 
Note that when programming in a higher language, like VBA or C++, these variables and functions appear as members of the LUSAS Modeller application object 
All other objects in the LPI are accessed through these global variables and functions - for example the variable IFModeller.database allows access to the current model database, and IFModeller.view allows access to the current drawing window. In turn, the points, lines elements, nodes and so on that make up the model can be accessed through the variables and functions of IFModeller.database, and the drawing layers which handle all the drawing options can be accessed via variables and functions of IFModeller.view. 
	"""

	def getCWD(self) -> str:
		r"""
		Returns the current working directory of LUSAS Modeller. The working directory is the location where LUSAS Modeller will expect input files to be found, and where it will create output files such as LUSAS Solver datafiles and picture files 
		Returns:
			str: Current working directory
		"""
		pass


	def setCWD(self, directory) -> None:
		r"""
		Modifies the working directory of LUSAS Modeller. The working directory is the location where LUSAS Modeller will expect input files to be found, and where it will create output files such as LUSAS Solver datafiles and picture files 
		Params:
			directory (str): Directory to use as new working directory
		Returns:
			None: 
		"""
		pass


	def fileOpen(self, filename) -> None:
		r"""
		Runs the named script file, executing the commands therein. If the filename given is not a fully qualified absolute path name (i.e. it does not begin with a network path or drive letter), LUSAS Modeller will assume that it is a relative path name with respect to the current working directory 
		Params:
			filename (str): Absolute or relative pathname of the script
		Returns:
			None: 
		"""
		pass


	def newASPCDatabase(self, filename=None) -> IFDatabase:
		r"""
		Creates a new, blank, model database within an ASPC window 
		Params:
			filename (str, optional): Filename to be created, e.g. "C:\temp\myModel.mdl". If not given, the database will not be associated with any file until IFProject.saveAs is called
		Returns:
			IFDatabase: The new database
		"""
		pass


	def solve(self, filename, options=None) -> int:
		r"""
		Invokes LUSAS Solver to analyse the given datafile. If the filename given is not a fully qualified absolute path name (i.e. it does not begin with a network path or drive letter), LUSAS Modeller will assume that it is a relative path name with respect to the current working directory The LUSAS Solver executable returns: 0 for success, 1 for failed to solve, and 2 for failed to converge (partial results) 
		Params:
			filename (str): Absolute or relative pathname of the data file
			options (IFLusasRunOptionsObj, optional): 
		Returns:
			int: Return code from LUSAS Solver
		"""
		pass


	def scanout(self, filename) -> None:
		r"""
		Scan the given file, assuming that it is a LUSAS solver output file. Any errors and warnings in the file will be presented in the text output window 
		Params:
			filename (str): 
		Returns:
			None: 
		"""
		pass


	def getLPIversion(self) -> int:
		r"""
		Returns an integer which indicates the build number of the LPI. This number will not necessarily be consecutive between consecutive releases of LUSAS, but it will always be unique, and will always rise, never fall. This code can be used to ensure that scripts and programs calling LPI functions are synchronised with the right version 
		Returns:
			int: LPI version
		"""
		pass


	def fileUtils(self) -> IFFileUtils:
		r"""
		Return a link to a collection of useful file utility methods 
		Returns:
			IFFileUtils: 
		"""
		pass


	def openPrintFile(self, filename, suppressScreenOutput=None) -> None:
		r"""
		Creates a new print file, and opens it for writing. The print file can subsequently be filled using calls to printWizard. The print file can subsequently be closed using a call to IFModeller.closePrintFile. Any previous contents of the file will be removed If the filename given is not a fully qualified absolute path name (i.e. it does not begin with a network path or drive letter), LUSAS Modeller will assume that it is a relative path name with respect to the current working directory 
		Params:
			filename (str): Absolute or relative pathname to be created
			suppressScreenOutput (bool, optional): If True then the printWizard output window will not be visible
		Returns:
			None: 
		"""
		pass


	def closePrintFile(self) -> None:
		r"""
		Closes the print file previously opened using. IFModeller.openPrintFile 
		Returns:
			None: 
		"""
		pass


	def createUndoableEvent(self, command, undoCommand, description) -> None:
		r"""
		To be used by user dialogs to create named events which are repetitively undoable and redoable. E.g. a dialog might create two discrete loads to represent a pedestrian. The dialog would probably issue two commands of the form "db.createLoadingDiscretePoint(...)". Calling these commands directly from VBS will create the loads, the two loading definitions will appear in the session file, and the two events will be separately undoable, however there will be nothing to tie these events to the pedestrian load dialog. Additionally the session file created will be an automatically generated one, and although it will contain the same information, it will not be precisely what was entered. It would also probably be desirable to have undo remove both loads, rather than one at a time. If instead, the dialog calls <code> IFModeller.createUndoableEvent("db.IFDatabase.createLoadingConcentrated(...):db.IFDatabase.createLoadingConcentrated(...), "db.IFDatabase.deleteAttribute(...):db.IFDatabase.deleteAttribute(...)", "Create Pedestrian Load") </code> this gives LUSAS Modeller all the information necessary to create an undo-able event. Not only will it create the loads, but the creations will appear in the session file using precisely the given commands, and using the label "Create Pedestrian Load". The events will be undo-able and redo-able together, again, using the label "Create Pedestrian Load"
 Note that this system is similar to that described in IFDatabase.beginCommandBatch. The advantage of IFDatabase.beginCommandBatch is that the necessary commands are captured automatically by Modeller. The advantage of IFModeller.createUndoableEvent is that cosmetic events such as rotations, selections, and colour changes can also be specified. 
		Params:
			command (str): Snippet of VBScript to execute to do and redo the event
			undoCommand (str): Snippet of VBScript to execute to undo the event
			description (str): text to appear in undo and redo button descriptions
		Returns:
			None: 
		"""
		pass


	def openOutputFile(self, filename) -> None:
		r"""
		 
		Params:
			filename (str): 
		Returns:
			None: 
		"""
		pass


	def system(self, pCommand) -> int:
		r"""
		Pass the given string to Windows to action as a command line instruction 
		Params:
			pCommand (str): 
		Returns:
			int: 
		"""
		pass


	def stopScript(self, message=None) -> None:
		r"""
		Abandon processing of the current script 
		Params:
			message (str, optional): Error message that will pop up to the user
		Returns:
			None: 
		"""
		pass


	def createAutomationObject(self, bstrProgID, error=None) -> IDispatch:
		r"""
		 
		Params:
			bstrProgID (str): 
			error (str, optional): 
		Returns:
			IDispatch: 
		"""
		pass


	def resetMainMenu(self) -> None:
		r"""
		Return the menu to its factory default state, removing any menus (and menu items) adding during customisation, adding any menus (and menu items) that were removed during customisation. 
		Returns:
			None: 
		"""
		pass


	def getMainMenu(self) -> IFMenu:
		r"""
		 
		Returns:
			IFMenu: 
		"""
		pass


	def menu(self) -> IFMenu:
		r"""
		 
		Returns:
			IFMenu: 
		"""
		pass


	def getSystemString(self, stringName) -> str:
		r"""
		Returns the value of the named token, reports an error if not found. To modify system strings, use IFDatabase.overrideSystemString or IFModeller.getSystemString. 
		Params:
			stringName (str): 
		Returns:
			str: 
		"""
		pass


	def setSystemString(self, stringName, value) -> None:
		r"""
		Allows you to override a standard LUSAS system string for all models. The values of system strings should never be changed without instruction from LUSAS technical support. To obtain the current value of a system string, use IFModeller.getSystemString. To override a standard LUSAS system string for only the current model, use IFDatabase.overrideSystemString 
		Params:
			stringName (str): 
			value (str): 
		Returns:
			None: 
		"""
		pass


	def getUserString(self, stringName) -> str:
		r"""
		Return the value of the named token, or an empty string if not found. Used to store settings that may be overridden by the end user, such as the locations of libraries. The values of user strings may be modified at any time using IFModeller.setUserString 
		Params:
			stringName (str): 
		Returns:
			str: 
		"""
		pass


	def setUserString(self, stringName, value) -> None:
		r"""
		Create/modify a string for later return using IFModeller.getUserString 
		Params:
			stringName (str): 
			value (str): 
		Returns:
			None: 
		"""
		pass


	def expandPath(self, path) -> str:
		r"""
		Expands tokens present in the path returns the full path with tokens expanded 
		Params:
			path (str): 
		Returns:
			str: 
		"""
		pass


	def getSolvingAnalysis(self) -> IFAnalysisBaseClass:
		r"""
		Can be used by a script to determine which analysis is currently solving 
		Returns:
			IFAnalysisBaseClass: 
		"""
		pass


	def newGraph(self, graphID=None) -> IFGraph:
		r"""
		 
		Params:
			graphID (int, optional): 
		Returns:
			IFGraph: 
		"""
		pass


	def countGraphs(self) -> int:
		r"""
		Returns the number of graph windows currently open in the application 
		Returns:
			int: 
		"""
		pass


	def getGraph(self, i) -> IFGraph:
		r"""
		Returns the graph window with the given index. Note that the index is not necessarily the same as the ID. If there are 3 graphs open, their indices will be 0, 1 and 2. However their IDs will depend on how many other graphs have been created and subsequently closed - e.g. they may have IDs 1, 3 and 6 if graphs 2, 4 and 5 have been deleted. 
		Params:
			i (int): index of the desired graph (0..IFModeller.countGraphs()-1)
		Returns:
			IFGraph: 
		"""
		pass


	def getGraphByID(self, graphID) -> IFGraph:
		r"""
		Fetch a named graph. The graph can then be manipulated as desired 
		Params:
			graphID (int): 
		Returns:
			IFGraph: 
		"""
		pass


	def existsGraphByID(self, graphID) -> bool:
		r"""
		Return whether or not a named graph exists. If true, it is safe to call IFModeller.getGraphByID 
		Params:
			graphID (int): 
		Returns:
			bool: 
		"""
		pass


	def setVisible(self, bVisible) -> None:
		r"""
		Can be used to set the Modeller application invisible. This may be necessary if Modeller is created from the scripting. A visible application will always have a reference count of at least one, and therefore will not close. By using this function, a programmer can guarantee that Modeller will die when the last reference is released. The option to set visible again is just included for completeness. 
		Params:
			bVisible (bool): 
		Returns:
			None: 
		"""
		pass


	def assign(self) -> IFAssignment:
		r"""
		This is the object that LUSAS Modeller uses in the session file to store assignment data and options. You are welcome to use the same object in your scripts, or to use IFModeller.newAssignment to create a new assignment object each time. If you reuse existing objects, make sure that you call IFAssignment.setAllDefaults to clear up the options from the previous usage 
		Synonyms:
			getSessionFileAssignment
		Returns:
			IFAssignment: 
		"""
		pass


	def assignment(self) -> IFAssignment:
		r"""
		This is the object that LUSAS Modeller uses in the session file to store assignment data and options. You are welcome to use the same object in your scripts, or to use IFModeller.newAssignment to create a new assignment object each time. If you reuse existing objects, make sure that you call IFAssignment.setAllDefaults to clear up the options from the previous usage 
		Synonyms:
			getSessionFileAssignment
		Returns:
			IFAssignment: 
		"""
		pass


	def getSessionFileAssignment(self) -> IFAssignment:
		r"""
		This is the object that LUSAS Modeller uses in the session file to store assignment data and options. You are welcome to use the same object in your scripts, or to use IFModeller.newAssignment to create a new assignment object each time. If you reuse existing objects, make sure that you call IFAssignment.setAllDefaults to clear up the options from the previous usage 
		Returns:
			IFAssignment: 
		"""
		pass


	def newAssignment(self) -> IFAssignment:
		r"""
		Creates a new object in which you can store assignment data and options. This object will automatically be deleted when you set its pointer to 'nothing' 
		Returns:
			IFAssignment: 
		"""
		pass


	def returnObjects(self) -> IFObjectSet:
		r"""
		This is the object that LUSAS Modeller uses in the session file to list objects which have been modified in geometry creation and attribute assignment operations. You are welcome to use the same object in your scripts, or to use IFModeller.newObjectSet to create a new set object each time. 
		Synonyms:
			getSessionFileReturnObjects
		Returns:
			IFObjectSet: 
		"""
		pass


	def getSessionFileReturnObjects(self) -> IFObjectSet:
		r"""
		This is the object that LUSAS Modeller uses in the session file to list objects which have been modified in geometry creation and attribute assignment operations. You are welcome to use the same object in your scripts, or to use IFModeller.newObjectSet to create a new set object each time. 
		Returns:
			IFObjectSet: 
		"""
		pass


	def geometryData(self) -> IFGeometryData:
		r"""
		 
		Synonyms:
			getSessionFileGeometryData
		Returns:
			IFGeometryData: 
		"""
		pass


	def getSessionFileGeometryData(self) -> IFGeometryData:
		r"""
		 
		Returns:
			IFGeometryData: 
		"""
		pass


	def newGeometryData(self) -> IFGeometryData:
		r"""
		 
		Returns:
			IFGeometryData: 
		"""
		pass


	def newPolylineDefn(self) -> IFPolylineDefn:
		r"""
		Create a new, unconnected, instance of a polyline definition 
		Returns:
			IFPolylineDefn: 
		"""
		pass


	def newObjectSet(self) -> IFObjectSet:
		r"""
		Creates and returns a new empty IFObjectSet that can be used for the script programmer's own purposes. The set will automatically be deleted when no variable points to it. 
		Returns:
			IFObjectSet: 
		"""
		pass


	def solverOptions(self) -> IFLusasRunOptionsObj:
		r"""
		 
		Synonyms:
			getSolverRunOptions
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def getSolverRunOptions(self) -> IFLusasRunOptionsObj:
		r"""
		 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def newSolverRunOptions(self) -> IFLusasRunOptionsObj:
		r"""
		 
		Returns:
			IFLusasRunOptionsObj: 
		"""
		pass


	def solverExport(self) -> IFTabulateDataObj:
		r"""
		 
		Synonyms:
			getSolverExportData
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def getSolverExportData(self) -> IFTabulateDataObj:
		r"""
		 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def newSolverExportData(self) -> IFTabulateDataObj:
		r"""
		 
		Returns:
			IFTabulateDataObj: 
		"""
		pass


	def nastranExport(self) -> IFExportNasDataObj:
		r"""
		 
		Synonyms:
			getNastranExportData
		Returns:
			IFExportNasDataObj: 
		"""
		pass


	def getNastranExportData(self) -> IFExportNasDataObj:
		r"""
		 
		Returns:
			IFExportNasDataObj: 
		"""
		pass


	def ansysExport(self) -> IFExportAnsysDataObj:
		r"""
		 
		Returns:
			IFExportAnsysDataObj: 
		"""
		pass


	def abaqusExport(self) -> IFExportAbaqusDataObj:
		r"""
		 
		Returns:
			IFExportAbaqusDataObj: 
		"""
		pass


	def igesImport(self) -> IFImportIgesDataObj:
		r"""
		 
		Synonyms:
			getIgesImportData
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def getIgesImportData(self) -> IFImportIgesDataObj:
		r"""
		 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def newIgesImportData(self) -> IFImportIgesDataObj:
		r"""
		 
		Returns:
			IFImportIgesDataObj: 
		"""
		pass


	def igesExport(self) -> IFExportIgesDataObj:
		r"""
		 
		Synonyms:
			getIgesExportData
		Returns:
			IFExportIgesDataObj: 
		"""
		pass


	def getIgesExportData(self) -> IFExportIgesDataObj:
		r"""
		 
		Returns:
			IFExportIgesDataObj: 
		"""
		pass


	def newIgesExportData(self) -> IFExportIgesDataObj:
		r"""
		 
		Returns:
			IFExportIgesDataObj: 
		"""
		pass


	def dxfImport(self) -> IFImportDxfDataObj:
		r"""
		 
		Synonyms:
			getDxfImportData
		Returns:
			IFImportDxfDataObj: 
		"""
		pass


	def getDxfImportData(self) -> IFImportDxfDataObj:
		r"""
		 
		Returns:
			IFImportDxfDataObj: 
		"""
		pass


	def newDxfImportData(self) -> IFImportDxfDataObj:
		r"""
		 
		Returns:
			IFImportDxfDataObj: 
		"""
		pass


	def dxfExport(self) -> IFExportDxfDataObj:
		r"""
		 
		Synonyms:
			getDxfExportData
		Returns:
			IFExportDxfDataObj: 
		"""
		pass


	def getDxfExportData(self) -> IFExportDxfDataObj:
		r"""
		 
		Returns:
			IFExportDxfDataObj: 
		"""
		pass


	def newDxfExportData(self) -> IFExportDxfDataObj:
		r"""
		 
		Returns:
			IFExportDxfDataObj: 
		"""
		pass


	def cmdImport(self) -> IFImportCmdDataObj:
		r"""
		 
		Synonyms:
			getCmdFileImportData
		Returns:
			IFImportCmdDataObj: 
		"""
		pass


	def getCmdFileImportData(self) -> IFImportCmdDataObj:
		r"""
		 
		Returns:
			IFImportCmdDataObj: 
		"""
		pass


	def newCmdFileImportData(self) -> IFImportCmdDataObj:
		r"""
		 
		Returns:
			IFImportCmdDataObj: 
		"""
		pass


	def cmdExport(self) -> IFExportCmdDataObj:
		r"""
		 
		Synonyms:
			getCmdFileExportData
		Returns:
			IFExportCmdDataObj: 
		"""
		pass


	def getCmdFileExportData(self) -> IFExportCmdDataObj:
		r"""
		 
		Returns:
			IFExportCmdDataObj: 
		"""
		pass


	def newCmdFileExportData(self) -> IFExportCmdDataObj:
		r"""
		 
		Returns:
			IFExportCmdDataObj: 
		"""
		pass


	def patranImport(self) -> IFImportPatranDataObj:
		r"""
		 
		Synonyms:
			getPatranImportData
		Returns:
			IFImportPatranDataObj: 
		"""
		pass


	def getPatranImportData(self) -> IFImportPatranDataObj:
		r"""
		 
		Returns:
			IFImportPatranDataObj: 
		"""
		pass


	def newPatranImportData(self) -> IFImportPatranDataObj:
		r"""
		 
		Returns:
			IFImportPatranDataObj: 
		"""
		pass


	def stlImport(self) -> IFImportStlDataObj:
		r"""
		 
		Synonyms:
			getStlImportData
		Returns:
			IFImportStlDataObj: 
		"""
		pass


	def getStlImportData(self) -> IFImportStlDataObj:
		r"""
		 
		Returns:
			IFImportStlDataObj: 
		"""
		pass


	def newStlImportData(self) -> IFImportStlDataObj:
		r"""
		 
		Returns:
			IFImportStlDataObj: 
		"""
		pass


	def stlExport(self) -> IFExportStlDataObj:
		r"""
		 
		Synonyms:
			getStlExportData
		Returns:
			IFExportStlDataObj: 
		"""
		pass


	def getStlExportData(self) -> IFExportStlDataObj:
		r"""
		 
		Returns:
			IFExportStlDataObj: 
		"""
		pass


	def stepFileImport(self) -> IFImportStepFileDataObj:
		r"""
		 
		Synonyms:
			getStepFileImportData
		Returns:
			IFImportStepFileDataObj: 
		"""
		pass


	def getStepFileImportData(self) -> IFImportStepFileDataObj:
		r"""
		 
		Returns:
			IFImportStepFileDataObj: 
		"""
		pass


	def newStepFileImportData(self) -> IFImportStepFileDataObj:
		r"""
		 
		Returns:
			IFImportStepFileDataObj: 
		"""
		pass


	def bimFileImport(self) -> IFImportBimFileDataObj:
		r"""
		 
		Synonyms:
			getBimFileImportData
		Returns:
			IFImportBimFileDataObj: 
		"""
		pass


	def getBimFileImportData(self) -> IFImportBimFileDataObj:
		r"""
		 
		Returns:
			IFImportBimFileDataObj: 
		"""
		pass


	def newBimFileImportData(self) -> IFImportBimFileDataObj:
		r"""
		 
		Returns:
			IFImportBimFileDataObj: 
		"""
		pass


	def stepExport(self) -> IFExportStepDataObj:
		r"""
		 
		Synonyms:
			getStepExportData
		Returns:
			IFExportStepDataObj: 
		"""
		pass


	def getStepExportData(self) -> IFExportStepDataObj:
		r"""
		 
		Returns:
			IFExportStepDataObj: 
		"""
		pass


	def newStepExportData(self) -> IFExportStepDataObj:
		r"""
		 
		Returns:
			IFExportStepDataObj: 
		"""
		pass


	def elementData(self) -> IFElementDataObj:
		r"""
		 
		Synonyms:
			getElementData
		Returns:
			IFElementDataObj: 
		"""
		pass


	def getElementData(self) -> IFElementDataObj:
		r"""
		 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def newElementData(self) -> IFElementDataObj:
		r"""
		 
		Returns:
			IFElementDataObj: 
		"""
		pass


	def newScriptExportData(self) -> IFExportScriptDataObj:
		r"""
		
		Returns:
			IFExportScriptDataObj: 
		"""
		pass


	def scriptExport(self) -> IFExportScriptDataObj:
		r"""
		
		Synonyms:
			getScriptExportData
		Returns:
			IFExportScriptDataObj: 
		"""
		pass


	def getScriptExportData(self) -> IFExportScriptDataObj:
		r"""
		
		Returns:
			IFExportScriptDataObj: 
		"""
		pass


	def midasExport(self) -> IFExportMidasDataObj:
		r"""
		return the MIDAS export data object 
		Returns:
			IFExportMidasDataObj: 
		"""
		pass


	def sap2kExport(self) -> IFExportSap2kDataObj:
		r"""
		return the SAP2000 export data object 
		Returns:
			IFExportSap2kDataObj: 
		"""
		pass


	def database(self) -> IFDatabase:
		r"""
		Gets the current database object 
		Synonyms:
			getDatabase
		Returns:
			IFDatabase: 
		"""
		pass


	def db(self) -> IFDatabase:
		r"""
		Gets the current database object 
		Synonyms:
			getDatabase
		Returns:
			IFDatabase: 
		"""
		pass


	def getDatabase(self) -> IFDatabase:
		r"""
		Gets the current database object 
		Returns:
			IFDatabase: 
		"""
		pass


	def existsDatabase(self) -> bool:
		r"""
		Returns true if a database exists. false if all databases are closed 
		Returns:
			bool: 
		"""
		pass


	def openASPCDatabase(self, filename, readOnly=None) -> IFDatabase:
		r"""
		Opens an existing model file from disk into the ASPC window 
		Params:
			filename (str): Name and location of model file to open
			readOnly (bool, optional): Open the database read-only. If the file on disk is read-only, and this flag is given false, the function will fail with an error message. If the flag is given true, temporary changes are allowed, but it will not be possible to press the 'save' button ('save as' is allowed).
		Returns:
			IFDatabase: The open model
		"""
		pass


	def openConvertDatabase(self, filename, dbVersion, textoutput=None) -> IFDatabase:
		r"""
		Opens an existing V13->V20 model file from disk without saving changes in the previous model, if any, and convert to the given format (Use IFModeller.project.IFProject.save first.) In normal use, omit the optional "textoutput" argument. In the 32bit exe, this optional argument is ignored. To check the conversion mechanism of the 64bit program, you may pass in the name of a file. If given, it will be filled with the contents of the text output window from the 32 bit modeller used to do the conversion. 
		Params:
			filename (str): Name and location of model file to open
			dbVersion (int): Permitted values: 2 = V19.1 64bit smdl files. Other formats may be supported in future
			textoutput (str, optional): name of a file to recieve the contents of the 32bit text output window (which must not exist)
		Returns:
			IFDatabase: The open model
		"""
		pass


	def canConvertToDatabase(self, dbVersion) -> bool:
		r"""
		return true if we can convert V13->V20 model file to the given format 
		Params:
			dbVersion (int): Permitted values: 2 = V19.1 64bit smdl files. Other formats may be supported in future
		Returns:
			bool: T if can convert, F if not
		"""
		pass


	def isNumericalErrorValue(self, value) -> bool:
		r"""
		return true if the given value is equal to Modeller's rogue value used to mean "no results" 
		Params:
			value (float): 
		Returns:
			bool: 
		"""
		pass


	def createSimpleDialog(self, title, rowLabels, columnLabels, data, sizeByContent=None, growGrid=None, readOnly=None) -> bool:
		r"""
		Creates and shows a simple dialog that can be used to either input or output a grid of generic data. All data is in string form - it is up to the programmer to convert to/from integers and reals. The dialog is of fixed size, but the data grid will scroll if necessary 
		Params:
			title (str): Title for the dialog
			rowLabels (array of strs): Array of row headers for grid
			columnLabels (array of strs): Array of column headers for grid
			data (array of strs): Initial data for grid (two dimensional array, first dimension number of columns, second dimension number of rows) If OK is pressed, and dialog is not read only, filled with user's input data
			sizeByContent (bool, optional): Default false. True to size cells by header contents. False for default sizes
			growGrid (bool, optional): Default false. True to allow user to add rows using the tab key. False to deny.
			readOnly (bool, optional): Default false. False to allow user to edit cell contents. True to deny.
		Returns:
			bool: Returns non-zero if user pressed OK, 0 if user pressed Cancel
		"""
		pass


	def createOpenDialog(self) -> IFFileDialog:
		r"""
		Create an instance of the standard 'file open' dialog of modeller The dialog will not be shown until IFDialog.showDialog is called 
		Returns:
			IFFileDialog: 
		"""
		pass


	def createSaveDialog(self) -> IFFileDialog:
		r"""
		Create an instance of the standard 'file save as' dialog of modeller The dialog will not be shown until IFDialog.showDialog is called 
		Returns:
			IFFileDialog: 
		"""
		pass


	def selection(self) -> IFSelection:
		r"""
		Returns current selection object 
		Synonyms:
			getSelection
		Returns:
			IFSelection: 
		"""
		pass


	def getSelection(self) -> IFSelection:
		r"""
		Returns current selection object 
		Returns:
			IFSelection: 
		"""
		pass


	def selectionMemory(self) -> IFSelection:
		r"""
		Returns selection memory object 
		Synonyms:
			getSelectionMemory
		Returns:
			IFSelection: 
		"""
		pass


	def getSelectionMemory(self) -> IFSelection:
		r"""
		Returns selection memory object 
		Returns:
			IFSelection: 
		"""
		pass


	def visible(self) -> IFObjectSet:
		r"""
		Returns the set of currently visible objects 
		Synonyms:
			getVisibleSet
		Returns:
			IFObjectSet: 
		"""
		pass


	def getVisibleSet(self) -> IFObjectSet:
		r"""
		Returns the set of currently visible objects 
		Returns:
			IFObjectSet: 
		"""
		pass


	def treeSelection(self) -> IFDispatch:
		r"""
		Returns the currently selected item from the currently active tree view - e.g. a group or a drawing layer. 
		Synonyms:
			getTreeSelection
		Returns:
			IFDispatch: 
		"""
		pass


	def getTreeSelection(self) -> IFDispatch:
		r"""
		Returns the currently selected item from the currently active tree view - e.g. a group or a drawing layer. 
		Returns:
			IFDispatch: 
		"""
		pass


	def textWin(self) -> IFTextWindow:
		r"""
		 
		Synonyms:
			getTextWindow
		Returns:
			IFTextWindow: 
		"""
		pass


	def getTextWindow(self) -> IFTextWindow:
		r"""
		 
		Returns:
			IFTextWindow: 
		"""
		pass


	def setCreationVersion(self, versionStr, buildInfoStr=None) -> None:
		r"""
		Allows LUSAS to know which version of Modeller created a particular session or recovery file. Please do not use, remove or modify! 
		Params:
			versionStr (str): e.g. "14.2-5"
			buildInfoStr (str, optional): e.g. "25/12/03(NAME 12:48:57)"
		Returns:
			None: 
		"""
		pass


	def getMajorVersionNumber(self) -> int:
		r"""
		Returns major version number of Modeller. i.e. if version is 14.1 function will return 14 
		Returns:
			int: 
		"""
		pass


	def getMinorVersionNumber(self) -> int:
		r"""
		Returns minor version number of Modeller. i.e. if version is 14.1 function will return 1 
		Returns:
			int: 
		"""
		pass


	def getBuildID(self) -> int:
		r"""
		Returns buildID (bug fix dash version) of Modeller. Note that alpha version numbers start at 51 (i.e. A1 = 51) and beta version numbers start at 75 (i.e. B2 = 76). 
		Returns:
			int: 
		"""
		pass


	def getRegistryAppName(self) -> str:
		r"""
		Returns the name that Modeller uses to store values in the registry. Includes major and minor version numbers, e.g. "Lusas Modeller 14.0". 
		Returns:
			str: 
		"""
		pass


	def getVersionStr(self) -> str:
		r"""
		Returns a nicely formatted version string, equivalent to major.minor-buildID. Note that this function will correctly handle Alpha and Beta releases, unlike getBuildID() which may return a misleading number for Alpha and Beta releases. 
		Returns:
			str: 
		"""
		pass


	def getReleaseDate(self) -> str:
		r"""
		Returns Modeller's release date as a nicely formatted string 
		Returns:
			str: 
		"""
		pass


	def updateAllViews(self) -> None:
		r"""
		 
		Returns:
			None: 
		"""
		pass


	def newView(self, x=None, y=None, width=None, height=None) -> IFView:
		r"""
		Creates and returns a new view window. If position of the left side of the window is given, then top position, width and height needs to be given as well 
		Params:
			x (int, optional): position of the left side of the window, in client coordinates.
			y (int, optional): position of the top of the window, in client coordinates.
			width (int, optional): width of the window, in pixels.
			height (int, optional): height of the window, in pixels.
		Returns:
			IFView: 
		"""
		pass


	def getView(self, viewName) -> IFView:
		r"""
		Returns the named view window 
		Params:
			viewName (str): 
		Returns:
			IFView: 
		"""
		pass


	def view(self) -> IFView:
		r"""
		Returns the view window which currently has the user's attention 
		Synonyms:
			getCurrentView
		Returns:
			IFView: 
		"""
		pass


	def getCurrentView(self) -> IFView:
		r"""
		Returns the view window which currently has the user's attention 
		Returns:
			IFView: 
		"""
		pass


	def toolbars(self) -> IFToolbarManager:
		r"""
		Returns the toolbar object 
		Synonyms:
			getToolbars
		Returns:
			IFToolbarManager: 
		"""
		pass


	def getToolbars(self) -> IFToolbarManager:
		r"""
		Returns the toolbar object 
		Returns:
			IFToolbarManager: 
		"""
		pass


	def animation(self) -> IFAnimationManager:
		r"""
		Returns the animation object 
		Synonyms:
			getAnimationManager
		Returns:
			IFAnimationManager: 
		"""
		pass


	def getAnimationManager(self) -> IFAnimationManager:
		r"""
		Returns the animation object 
		Returns:
			IFAnimationManager: 
		"""
		pass


	def getCurrentAnimation(self) -> IFAnimationView:
		r"""
		Returns the current animation object 
		Returns:
			IFAnimationView: 
		"""
		pass


	def readInteger(self, variable, defaultValue) -> int:
		r"""
		 
		Params:
			variable (str): 
			defaultValue (int): 
		Returns:
			int: 
		"""
		pass


	def writeInteger(self, variable, value) -> None:
		r"""
		 
		Params:
			variable (str): 
			value (int): 
		Returns:
			None: 
		"""
		pass


	def readString(self, variable, defaultValue) -> str:
		r"""
		 
		Params:
			variable (str): 
			defaultValue (str): 
		Returns:
			str: 
		"""
		pass


	def writeString(self, variable, value) -> None:
		r"""
		 
		Params:
			variable (str): 
			value (str): 
		Returns:
			None: 
		"""
		pass


	def readDouble(self, variable, defaultValue) -> float:
		r"""
		 
		Params:
			variable (str): 
			defaultValue (float): 
		Returns:
			float: 
		"""
		pass


	def writeDouble(self, variable, value) -> None:
		r"""
		 
		Params:
			variable (str): 
			value (float): 
		Returns:
			None: 
		"""
		pass


	def readBoolean(self, variable, defaultValue) -> bool:
		r"""
		 
		Params:
			variable (str): 
			defaultValue (bool): 
		Returns:
			bool: 
		"""
		pass


	def writeBoolean(self, variable, value) -> None:
		r"""
		 
		Params:
			variable (str): 
			value (bool): 
		Returns:
			None: 
		"""
		pass


	def convertFromString(self, expr, output, showErrors=None, error=None, locale=None, variablesIn=None, variablesNeeded=None, dimensionality=None, unitSet=None) -> int:
		r"""
		Attempts to convert the given string into a numerical value. Any expressions in the string (e.g. "3+4") are evaluated. 
		Params:
			expr (str): The input expression
			output (float): The output numeric value (if the function succeeds)
			showErrors (bool, optional): If true, LUSAS Modeller will generate pop-up dialogs to inform the user why the string could not be evaluated into a number
			error (str, optional): If given, this string will be filled in with the reason why the string could not be evaluated into a number
			locale (str, optional): If given, the locale in which to make the conversion, examples are similar to those shown in the Windows international settings dialog: "English", "English_United Kingdom", "French", "French_Monaco" etc. The special value of "C" may be used to represent standard US English number formating If not given, the Windows locale at the time Modeller was launched will be used
			variablesIn (2d array, optional): If given, an array of variables and values that may appear in the expression. For example, if the array contains just one pair of items, the string "x" and the value 4, then x may be used in the expression, and will be assumed to have the value 4. If the array has two pairs of items "x", 3 and "y","x*2", x and y may both be used in the expression. x will have the value 3 and y the value 6.
			variablesNeeded (array of strs, optional): If the return code is 2, this argument will be set to be array of the names of the variables that were needed
			dimensionality (int, optional): Defines the dimensionality of the input string.
			unitSet (str, optional): The unit set that we need to convert to (e.g "N,mm,t,s,C"). If it is not given (unitSet = ""), no conversion will occur.
		Returns:
			int: Zero if the string could be evaluated to a number. 2 if the string depends on variables that were not given. Other non-zero values are errors.
		"""
		pass


	def convertToString(self, input, showAllDigits=None, locale=None, dimensionality=None, unitSet=None, zero=None) -> str:
		r"""
		Converts the input number into a string, ready formatted for display The string is presented in engineering format, with the exponent, if any, as a multiple of 3. 
		Params:
			input (float or int): The input number
			showAllDigits (bool, optional): If true (the default), show all available precision. If false, round to the significant figures set using IFModeller.setDisplaySigFig, or to the decimal places set using IFModeller.setDisplayDecimalPlaces
			locale (str, optional): If given the locale in which to make the conversion, examples are similar to those shown in the Windows international settings dialog: "English", "English_United Kingdom", "French", "French_Monaco" etc. The special value of "C" may be used to represent standard US English number formating If not given, the Windows locale at the time Modeller was launched will be used
			dimensionality (int, optional): Defines the dimensionality of the input string. Need only when feet-inches format should be taken into account and the input is length.
			unitSet (str, optional): The unit set should be given if feet-inches format needs to be taken into account.
			zero (float, optional): This function returns 0.0 for any number whose absolute value is smaller than the given value
		Returns:
			str: The output string
		"""
		pass


	def getDisplayPrecision(self, isDecimalPlaces, precision) -> None:
		r"""
		Returns both the mode and precision used to display real numbers in dialogs etc Real numbers can either be displayed in a fixed number of decimal places or a fixed number of significant figures. 
		Params:
			isDecimalPlaces (bool): Returned TRUE for decimal places, FALSE for significant figures
			precision (int): Number of DP or SF as appropriate
		Returns:
			None: 
		"""
		pass


	def setDisplaySigFig(self, sigfig, trailingZeros=None) -> None:
		r"""
		Sets the number of significant figures used to display real numbers in dialogs etc 
		Params:
			sigfig (int): 
			trailingZeros (bool, optional): true for 1.200, false for 1.2
		Returns:
			None: 
		"""
		pass


	def setDisplayDecimalPlaces(self, nDP) -> None:
		r"""
		Sets the number of decimal places used to display real numbers in dialogs etc 
		Params:
			nDP (int): 
		Returns:
			None: 
		"""
		pass


	def setManualRefresh(self, isFreeze) -> None:
		r"""
		Switches on or off manual refresh of the screen. This function controls all Modeller views, not just the current one. The flag is preserved through model open and close, so you can set the refresh to manual before opening a big model. With manual refresh mode on, a redraw is only performed when the user hits the F5 key. If manual refresh is off, redraws are performed whenever LUSAS Modeller thinks them necessary 
		Params:
			isFreeze (bool): 
		Returns:
			None: 
		"""
		pass


	def isManualRefresh(self) -> bool:
		r"""
		Inquires the current state of manual redraws 
		Returns:
			bool: 
		"""
		pass


	def setReturnToScript(self, scriptName, buttonText) -> None:
		r"""
		Sets a button in Modeller that if clicked will run the passed script 
		Params:
			scriptName (str): 
			buttonText (str): 
		Returns:
			None: 
		"""
		pass


	def setReturnToModule(self, moduleName, buttonText, clientData=None) -> None:
		r"""
		Sets a button in Modeller that if clicked will run a callback method from the extension module specified by 'moduleName'; 'clientData' can specify an additional parameter that will be passed back in to the call back method 
		Params:
			moduleName (str): 
			buttonText (str): 
			clientData (object, optional): Data that will be passed, unmodified, to the module
		Returns:
			None: 
		"""
		pass


	def setReturnToDialog(self, dialogName, buttonText, runModal=None) -> None:
		r"""
		Sets a button in Modeller that if clicked will run the passed dialog 
		Params:
			dialogName (str): 
			buttonText (str): 
			runModal (bool, optional): See IFModeller.StartDialog
		Returns:
			None: 
		"""
		pass


	def hideReturnToButton(self) -> None:
		r"""
		Hides the button and toolbar previously added using IFModeller.setReturnToScript or IFModeller.setReturnToDialog 
		Returns:
			None: 
		"""
		pass


	def clockStart(self) -> None:
		r"""
		Marks the beginning of a timing step 
		Returns:
			None: 
		"""
		pass


	def clockEnd(self, label, filename=None) -> int:
		r"""
		Marks the end of a timing step in "clock ticks". Clock ticks measure only CPU time and ignore time taken by other processes, interaction with disk, etc. The number of clock ticks taken by an opeartion should be relatively consistent between runs, regardless of what else the PC is doing. However, since it ignores interaction with the disk, it can be misleading. Conversely "wall clock time" counts minutes and seconds as seen by a clock on the wall, and times will be slower if the PC has many other tasks running. Unfortunately, Windows does not provide a mechanism to measure how long an application took, including disk access but excluding other applications. Can be called repeatedly (in other words, calling clockEnd() resets the start time). If �filename� parameter is not given: times are written only to the text output window and log file. If �filename� parameter is given:     a tmg file is created (unless exists) and is opened for writing. 
		Params:
			label (str): label to identify the task
			filename (str, optional): filename of tmg file.
		Returns:
			int: how long the task took, in milliseconds.
		"""
		pass


	def clockCheckTime(self, label, minClock, maxClock, filename=None) -> None:
		r"""
		As clockEnd, but does not usually report the actual time taken. Instead, it writes only "too quick", "too slow", or "time check passed". This is useful for tasks that involve disk access, as Windows disk access can be quite varied in its performance from one run to the next. 
		Params:
			label (str): label to identify the task
			minClock (int): minimum expected time in clock ticks (approximately milliseconds)
			maxClock (int): minimum expected time in clock ticks (approximately milliseconds)
			filename (str, optional): filename of tmg file.
		Returns:
			None: 
		"""
		pass


	def wallClockEnd(self, label, filename=None) -> None:
		r"""
		Marks the end of a timing step in "wall clock time". "Wall clock time" counts minutes and seconds as seen by a clock on the wall,  and times will therefore be slower if the PC has many other tasks running. Conversely, clock ticks measure only CPU time and ignore time taken by other processes, interaction with disk, etc. The number of clock ticks taken by an operation should be relatively consistent between runs, regardless of what else the PC is doing. However, since it ignores interaction with the disk, it can be misleading. Unfortunately, Windows does not provide a mechanism to measure how long an application took, including disk access but excluding other applications. Can be called repeatedly (in other words, calling wallClockEnd() resets the start time). If �filename� parameter is not given: times are written only to the text output window. If �filename� parameter is given:     a tmg file is created (unless it already exists) and is opened for writing. In all situations, a new line of text in the following format will be created and added to the text output window (and optionally to the given file): <S> seconds of elapsed time, to 3 decimal places 
		Params:
			label (str): label to identify the task
			filename (str, optional): filename of tmg file.
		Returns:
			None: 
		"""
		pass


	def wallClockCheckTime(self, label, minMS, maxMS, filename=None) -> None:
		r"""
		As wallClockEnd, but does not usually report the actual time taken. Instead, it writes only "too quick", "too slow", or "time check passed". This is useful for tasks that involve disk access, as Windows disk access can be quite varied in its performance from one run to the next. 
		Params:
			label (str): label to identify the task
			minMS (float): minimum expected time in seconds
			maxMS (float): minimum expected time in seconds
			filename (str, optional): filename of tmg file.
		Returns:
			None: 
		"""
		pass


	def bringToFront(self) -> None:
		r"""
		Brings the main LUSAS Modeller to the front of the Windows Z order. This is useful for applications that wish to treat Modeller as an OLE server 
		Returns:
			None: 
		"""
		pass


	def sendToBack(self) -> None:
		r"""
		Sends the main LUSAS Modeller to the back of the Windows Z order. This is useful for applications that wish to treat Modeller as an OLE server 
		Returns:
			None: 
		"""
		pass


	def getMessageSuppression(self) -> int:
		r"""
		Gets suppression level of Modeller messages 
		Returns:
			int: 0 (default) - show all messages. 1 - show no messages at all. 2 - show all messages (including popups) only in text output window.
		"""
		pass


	def suppressMessages(self, iSupress) -> None:
		r"""
		Sets suppression level of Modeller messages 
		Params:
			iSupress (int): 0 (default) - show all messages. 1 - show no messages at all. 2 - show all messages (including popups) only in text output window.
		Returns:
			None: 
		"""
		pass


	def browseDir(self, title) -> str:
		r"""
		Displays a 'browse for directory' dialog. 
		Params:
			title (str): Title of dialog.
		Returns:
			str: Selected directory.
		"""
		pass


	def isWarningRemoved(self, text) -> bool:
		r"""
		Asks whether a particualr 'removeable warning' message has been removed by the user using "Don't show this message again" 
		Params:
			text (str or int): Text to be displayed.
		Returns:
			bool: true if the warning has been removed
		"""
		pass


	def reinstateWarning(self, text) -> None:
		r"""
		Resets the status of a particualr 'removeable warning' message so that it will be seen next time the problem occurs 
		Params:
			text (str or int): Text to be displayed.
		Returns:
			None: 
		"""
		pass


	def removeWarning(self, text) -> None:
		r"""
		Resets the status of a particualr 'removeable warning' message so that it will be seen next time the problem occurs 
		Params:
			text (str or int): Text to be displayed.
		Returns:
			None: 
		"""
		pass


	def removeableWarning(self, text, buttonMode=None, textRef=None) -> int:
		r"""
		Displays a 'warning' message that has the option of "Don't show this message again" If the text is given as a string, that is used as the message and no help button will be seen. If the text is given as an integer, that integer is used to look up a string from modeller's internal string table, and is also used as the trigger for the help button If both text and textRef are given, text is used as the message on the dialog, and textRef is used to control the visibility of the dialog, and also as the help trigger Three button modes are available to control whether the dialog has "OK", "OK/cancel" or "yes/no" behaviour 
		Params:
			text (str or int): Text to be displayed.
			buttonMode (int, optional): Available button modes: 0 = OK only. Mode 1 = OK + cancel. Mode 2 = Yes + No
			textRef (str or int, optional): Default empty. If not empty, this is string (or ID of a string) which will be used as the control variable to pass to IFModeller.isWarningRemoved and IFModeller.reinstateWarning. This is useful if the displayed text needs to contain format specifiers such as %1 from IFModeller.localFormat. The format specifiers are not expanded, and thus control is based on "My string %1", rather than "My string " + the value of %1
		Returns:
			int: Return codes: 0 = cancel, 1 = OK, 6 = Yes, 7 = No, anything else = error
		"""
		pass


	def enableTrees(self, isEnable) -> None:
		r"""
		Switches on/off the auto-update of all trees within Modeller This is useful when creating large numbers of attributes, loadcases or groups, which would otherwise be very slow. Modeller automatically calls enableTrees(0) just before running a command script, and enableTrees(1) just after it has finished. This function is therefore only needed in scriptable dialogs which create large numbers of objects. Each call to enableTrees(0) must be matched with a call to enableTrees(1) to reenable it, otherwise if enableTrees(0) is called twice and enableTrees(1) only once, the auto-update of the trees will stay switched off. 
		Params:
			isEnable (bool): 1 to enable, 0 to disable
		Returns:
			None: 
		"""
		pass


	def enableUI(self, isEnable) -> None:
		r"""
		Switches on/off user interaction with the Modeller user interface This is useful for making scriptable dialogs modal, or blocking. call enableUI(0) as the dialog loads, and enableUI(1) as the dialog closes 
		Params:
			isEnable (bool): 1 to enable, 0 to disable
		Returns:
			None: 
		"""
		pass


	def isUIEnabled(self) -> bool:
		r"""
		Returns the current state, modifiable via IFModeller.enableUI 
		Returns:
			bool: 1 if enabled, 0 if disabled
		"""
		pass


	def isTreesEnabled(self) -> bool:
		r"""
		Returns the current state, modifiable via IFModeller.enableTrees 
		Returns:
			bool: 1 if enabled, 0 if disabled
		"""
		pass


	def startDialog(self, fileName, runModal=None, commandStrings=None, wait=None) -> None:
		r"""
		Executes the dialog found at the pathname given The first optional argument passed is used to control whether or not the new dialog runs in modal (blocking) mode.  If the file given is an executable, this function passes the given array of named values direct to the dialog as it starts up, in the form of a command line. It will also pass through the HWND of Modeller in the form "hwnd=1234", such that the dialog can be created as a child of Modeller. It will also pass through the modal flag in the form "modal=TRUE" or "modal=FALSE" to the new process. The new process is responsible for handling this flag by calling "modeller.enableUI(true/false)" during its startup.  If the file given is a tfm file, modeller creates a window in which the tfm file is created, and modeller is responsible for handling the runModal flag. The array of command strings is ignored. 
		Params:
			fileName (str): Full pathname of the executable (or script or scriptable dialog) to run
			runModal (bool, optional): TRUE to run in modal or 'blocking' mode
			commandStrings (array of strs, optional): These strings will be passed direct to the new process. Each string is of the form "name=value"
			wait (bool, optional): TRUE to wait until the dialog is closed
		Returns:
			None: 
		"""
		pass


	def registerDialog(self, pDlg) -> None:
		r"""
		Call as your activeX compliant dialog starts up. Modeller adds it to the list of registered dialogs. Such dialogs will be notified of events (such as Modeller exit) as they occur. 
		Params:
			pDlg (IFModellerDlg): Dialog to register
		Returns:
			None: 
		"""
		pass


	def unregisterDialog(self, pDlg) -> None:
		r"""
		Call as your activeX compliant dialog closes down. Modeller removes it from the list of registered dialogs. 
		Params:
			pDlg (IFModellerDlg): Dialog to unregister
		Returns:
			None: 
		"""
		pass


	def createStringFromArray(self, pVariant, stringFormat=None, stringFormatNoIncrement=None, stringSeperator=None, stringSingleVal=None) -> str:
		r"""
		Packs the given integers into a string which attempts to represent them in an efficient manner. E.g. The integers 1;2;3,4,5, 10 would become "1T5;10" 
		Params:
			pVariant (array of ints): Array of integers to be set as string list
			stringFormat (str, optional): C-style string format to be used for list, for example "%d to %d in increments of %d". The default is "%dT%dI%d"
			stringFormatNoIncrement (str, optional): C-style string format to be used for list when no increment is given for example "1 to 5"("in increments of 1" is assumed), The default is "%dT%d"
			stringSeperator (str, optional): List separator character to be used when more than one expression is needed, e.g.1T5;10T15. Default is ";"
			stringSingleVal (str, optional): C-style string format to be used when a single value is outputted, for example "line %d". Default is "%d".
		Returns:
			str: Returned in the chosen format
		"""
		pass


	def createEnergyUnit(self, longName, shortName, factor) -> IFUnit:
		r"""
		Creates or modifies a unit of energy. The factor describes the number of the new units in 1 Joule. For example, mJ = 1000 
		Params:
			longName (str): Long name for unit
			shortName (str): Short name for unit
			factor (float): conversion factor (from SI).
		Returns:
			IFUnit: the returned object
		"""
		pass


	def createForceUnit(self, longName, shortName, factor) -> IFUnit:
		r"""
		Creates or modifies a unit of force. The factor describes the number of the new units in 1 Newton. For example, kN = 0.001 
		Params:
			longName (str): Long name for unit
			shortName (str): Short name for unit
			factor (float): conversion factor (from SI).
		Returns:
			IFUnit: the returned object
		"""
		pass


	def createLengthUnit(self, longName, shortName, factor) -> IFUnit:
		r"""
		Creates or modifies a unit of length. The factor describes the number of the new units in 1 metre. For example, mm = 1000, feet = 3.28 
		Params:
			longName (str): Long name for unit
			shortName (str): Short name for unit
			factor (float): conversion factor (from SI).
		Returns:
			IFUnit: the returned object
		"""
		pass


	def createMassUnit(self, longName, shortName, factor) -> IFUnit:
		r"""
		Creates or modifies a unit of mass. The factor describes the number of the new units in 1 kilogram. For example, t = 1000 
		Params:
			longName (str): Long name for unit
			shortName (str): Short name for unit
			factor (float): conversion factor (from SI).
		Returns:
			IFUnit: the returned object
		"""
		pass


	def createTimeUnit(self, longName, shortName, factor) -> IFUnit:
		r"""
		Creates or modifies a unit of length. The factor describes the number of the new units in 1 second. For example, mins = 1/60 
		Params:
			longName (str): Long name for unit
			shortName (str): Short name for unit
			factor (float): conversion factor (from SI).
		Returns:
			IFUnit: the returned object
		"""
		pass


	def createTemperatureUnit(self, longName, shortName, factor, offset) -> IFUnit:
		r"""
		Creates or modifies a unit of length. The factor describes the number of the new units in 1 degree Celcius, and the offset describes the relative position of 0. For example, Farenheit = 9/5 +32 
		Params:
			longName (str): Long name for unit
			shortName (str): Short name for unit
			factor (float): conversion factor (from SI).
			offset (float): offset (from 0C).
		Returns:
			IFUnit: the returned object
		"""
		pass


	def createUnitSet(self, setName, length, mass, time, temperature) -> IFUnitSet:
		r"""
		Creates or modifies a set of named units and (if not already present) add them to the list of available units. Also returns the created or modified set for use in the script Note that neither force nor energy are required, as these can be found from the other factors, assuming that energy = force * distance and force = mass * acceleration. It is an error to attempt to create a set of units for which matching energy and force have not previously been defined 
		Params:
			setName (str): Name for this set of units
			length (IFUnit): Length unit
			mass (IFUnit): Mass unit
			time (IFUnit): Time unit
			temperature (IFUnit): Temperature unit
		Returns:
			IFUnitSet: the returned object
		"""
		pass


	def getUnitSet(self, name) -> IFUnitSet:
		r"""
		Returns a set of units previously created using IFModeller.createUnitSet A search is carried out to find a set of units with the given name. Note that model units should be got using IFDatabase.getModelUnits. 
		Params:
			name (str): name of unit set to search for
		Returns:
			IFUnitSet: the returned object
		"""
		pass


	def getUnitSets(self) -> list[IFUnitSet]:
		r"""
		Returns a set of units previously created using IFModeller.createUnitSet If a name is given, a search is carried out to find a set of units with that name. If an integer is given, it is assumed to be the index of a set of units. The index represents the order in which IFModeller.createUnitSet was originally called, so the first set of units created has the index 0 and so on. 
		Returns:
			array of IFUnitSet objects: the returned array
		"""
		pass


	def getTimescales(self) -> list[str]:
		r"""
		Returns an array of the timescales that are supported by Modeller ("Seconds", "Minutes", "Hours", etc) 
		Returns:
			array of strs: The returned array of timescales
		"""
		pass


	def getTimescaleFrequencies(self) -> list[str]:
		r"""
		Returns an array of the timescale frequnecies that are supported by Modeller ("/Second", "/Minute", "/Hour", etc) 
		Returns:
			array of strs: The returned array of timescales
		"""
		pass


	def WinHelp(self, dwData, nCmd=None) -> None:
		r"""
		Displays the help file 
		Params:
			dwData (float): ID of the dialog/button
			nCmd (int, optional): style with which to open help
		Returns:
			None: 
		"""
		pass


	def getIntegerSystemVariable(self, stringName) -> int:
		r"""
		Gets the integer system variable of the given name 
		Params:
			stringName (str): 
		Returns:
			int: 
		"""
		pass


	def setIntegerSystemVariable(self, stringName, value) -> None:
		r"""
		Sets the integer system variable of the given name to the given value 
		Params:
			stringName (str): 
			value (int): 
		Returns:
			None: 
		"""
		pass


	def getRealSystemVariable(self, stringName) -> float:
		r"""
		Gets the real system variable of the given name 
		Params:
			stringName (str): 
		Returns:
			float: 
		"""
		pass


	def setRealSystemVariable(self, stringName, value) -> None:
		r"""
		Sets the real system variable of the given name to the given value 
		Params:
			stringName (str): 
			value (float): 
		Returns:
			None: 
		"""
		pass


	def localFormat(self, format, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None, arg6=None, arg7=None, arg8=None, arg9=None, arg10=None, arg11=None, arg12=None, arg13=None, arg14=None, arg15=None, arg16=None, arg17=None, arg18=None, arg19=None, arg20=None) -> str:
		r"""
		Builds compound text from a number of variables placed in a format string. The format string contains plain text and a number of numbered place holders in that text of the form %n, where n is in the range 1..20 and represents the corresponding subsequent arguments. Use %% to indicate the % character. Identifying arguments numerically is useful when multiple user interface languages must be considered, as shown in the example. The format string can also be given as a numerical string ID, in which case it will be substituted by the equivalent string loaded from Modeller's resources. 
		Params:
			format (str): 
			arg1 (str, optional): 
			arg2 (str, optional): 
			arg3 (str, optional): 
			arg4 (str, optional): 
			arg5 (str, optional): 
			arg6 (str, optional): 
			arg7 (str, optional): 
			arg8 (str, optional): 
			arg9 (str, optional): 
			arg10 (str, optional): 
			arg11 (str, optional): 
			arg12 (str, optional): 
			arg13 (str, optional): 
			arg14 (str, optional): 
			arg15 (str, optional): 
			arg16 (str, optional): 
			arg17 (str, optional): 
			arg18 (str, optional): 
			arg19 (str, optional): 
			arg20 (str, optional): 
		Returns:
			str: 
		"""
		pass


	def localCompare(self, searchBstr, resVar) -> bool:
		r"""
		For comparing a string with string a containing local place holders, this function takes a string usually created by localFormat and compares to a format string usually used by with localFormat 
		Params:
			searchBstr (str): string to compare
			resVar (str): format string to compare with
		Returns:
			bool: true if the strings match
		"""
		pass


	def AfxMsgBox(self, message, nType=None, caption=None, nIDPrompt=None) -> int:
		r"""
		Exports standard Microsoft AfxMsgBox functionality 
		Params:
			message (str): 
			nType (int, optional): message box options
			caption (str, optional): 
			nIDPrompt (int, optional): help trigger
		Returns:
			int: result error code
		"""
		pass


	def insertAttributeContextMenuItem(self, attributeType, beforeItem, itemText, command, helpString=None, sessionFile=None) -> None:
		r"""
		Inserts a new menu item before the specified item in the context (right click) menu for all attributes of the given type. Note that that attribute type can be either "all", or a whole type (e.g. "Geometric") or a sub type (e.g. "Line Geometric") The specified item can be represented as either text or ID and could refer to either a sub menu or a menu item 
		Params:
			attributeType (str): "Loading", "Support", "Material", etc
			beforeItem (str or int): menu item before which new item is to be placed
			itemText (str): text of new item
			command (str): command to execute when menu item selected
			helpString (str, optional): help string to be displayed in status bar when cursor hovers over menu item
			sessionFile (bool, optional): Default true. Should commands appear in session file when item selected?
		Returns:
			None: 
		"""
		pass


	def runCmdLine(self, pCommandLine, wait=1) -> int:
		r"""
		Run the given command line with cmd /C command line args should be quoted if they contain spaces 
		Params:
			pCommandLine (str): command line to run
			wait (bool): wait for the spawned process to return
		Returns:
			int: 
		"""
		pass


	def getSectionLibrary(self, isLocalLibrary) -> str:
		r"""
		Get the file name of either in the local section library or server section library 
		Params:
			isLocalLibrary (bool): whether the library file is from the local or server
		Returns:
			str: file name of the section library
		"""
		pass


	def initStatusBarProgressCtrl(self, msg, nrOfTasks) -> None:
		r"""
		Initializes and shows the progress indicator on Modeller's status bar 
		Params:
			msg (str): message that is displayed on the status bar at the same time
			nrOfTasks (int): number of progress bar steps
		Returns:
			None: 
		"""
		pass


	def statusBarProgressCtrlStep(self) -> None:
		r"""
		Increments the progress indicator on the status bar 
		Returns:
			None: 
		"""
		pass


	def unInitStatusBarProgressCtrl(self) -> None:
		r"""
		Deletes the progress indicator and restores the status bar to its original content 
		Returns:
			None: 
		"""
		pass


	def getCurrentLicenceLine(self) -> str:
		r"""
		returns the licence line which modeller is running with from the key file 
		Returns:
			str: key file license line
		"""
		pass


	def getModellerUILocale(self) -> int:
		r"""
		returns modellers UI LCID 
		Returns:
			int: modellers UI locale
		"""
		pass


	def getModellerCurrentLocale(self) -> int:
		r"""
		returns modellers numeric LCID 
		Returns:
			int: modellers numeric locale
		"""
		pass


	def getModule(self, moduleName, className=None, reloadModule=True) -> IDispatch:
		r"""
		returns the IDispatch of the requested module loaded by modeller 
		Params:
			moduleName (str): Name of the module to load
			className (str, optional): Fully qualified name of the class required
			reloadModule (bool): set to false to use an existing module already loaded if one is present by default this value is true
		Returns:
			IDispatch: IDispatch of the requested module loaded by modeller
		"""
		pass


	def getExtModule(self, moduleName) -> IDispatch:
		r"""
		returns the IDispatch of the requested module loaded by modeller 
		Params:
			moduleName (str): Name of the module to load
		Returns:
			IDispatch: IDispatch of the requested module loaded by modeller
		"""
		pass


	def sleep(self, ms) -> None:
		r"""
		Sleep, or wait, for the given number of milliseconds 
		Params:
			ms (int): 
		Returns:
			None: 
		"""
		pass


	def addLibrarySection(self, isLocalLibrary, sectionName, shapeCode, dimArray, confirmOverwrite, sectionPropertiesInLine=None) -> bool:
		r"""
		Add a section to the given local section library or server section library. Optionally allows specific properties to be specified in the library rather than using internal calculators 
		Params:
			isLocalLibrary (bool): whether the library file is from the local or server
			sectionName (str): name of the section
			shapeCode (int): Shape code of section
			dimArray (array): array of section dimensions
			confirmOverwrite (bool): first confirm whether or not it is OK to overwrite existing section details
			sectionPropertiesInLine (str, optional): section properties in line eg "Iyy=1.23, Izz=2.34" using y,z axes.
		Returns:
			bool: true if written, false if cancelled
		"""
		pass


	def createSupportZipFile(self, modelFile, VLO, model, results) -> str:
		r"""
		Creates a zip file that contains the specified problem's files 
		Params:
			modelFile (str): filename of model to be considered
			VLO (bool): true if VLO files should be included
			model (bool): true if model files should be included
			results (bool): true if results files should be included
		Returns:
			str: path of generated zip file
		"""
		pass


	def setKeyboardMap(self, intersect, set, add, remove, toggle, rightToLeftMeansIntersect=None) -> None:
		r"""
		Sets the key combinations controlling selection. Codes are a combination of the values: 1=alt 2=ctrl 4=shift 
		Params:
			intersect (int): key code (must be 1,2 or 4)
			set (int): key code (must not include the intersect key)
			add (int): key code (must not include the intersect key)
			remove (int): key code (must not include the intersect key)
			toggle (int): key code (must not include the intersect key)
			rightToLeftMeansIntersect (bool, optional): If true, a right-to-left mouse drag acts as an intersect (if false, it doesn't).
		Returns:
			None: 
		"""
		pass


	def setCurrentTreeview(self, treename) -> None:
		r"""
		Brings the specified treeview to the front of any others in the same panel 
		Params:
			treename (str): "Layers", "Groups", "Attributes", "Analysis", "Utilities", or "Reports"
		Returns:
			None: 
		"""
		pass


	def getCurrentLicenseLimits(self, nPoints, nNodes, nElements, nLoadcases) -> None:
		r"""
		Obtain the limits (if any) of the current license. In each case, a returned value of 0 indicate unlimited. 
		Params:
			nPoints (int): Maximum permitted number of points
			nNodes (int): Maximum permitted number of nodes
			nElements (int): Maximum permitted number of elements
			nLoadcases (int): Maximum permitted number of loadcases
		Returns:
			None: 
		"""
		pass


	def createSelectLoadsetDialog(self, showEigenHarmCol) -> IFSelectLoadsetsDialog:
		r"""
		Create an instance of the standard 'select loadsets' dialog of modeller The dialog will not be shown until IFDialog.showDialog is called 
		Params:
			showEigenHarmCol (bool): show eigen and harmonic results as columns? (this is separate from 'are they in the list')
		Returns:
			IFSelectLoadsetsDialog: 
		"""
		pass


	def createGridWindow(self, nID) -> IFGridWindow:
		r"""
		Create and return a new IFGridWindow object The window ID allows subsequent retrieval using IFModeller.getGridWindowByID 
		Params:
			nID (int): grid window ID
		Returns:
			IFGridWindow: 
		"""
		pass


	def getGridWindowByID(self, nID) -> IFGridWindow:
		r"""
		Return IFGridWindow object previously created by IFModeller.createGridWindow The window ID is specified in IFModeller.createGridWindow 
		Params:
			nID (int): grid window ID
		Returns:
			IFGridWindow: 
		"""
		pass


	def nextGridWindowID(self) -> int:
		r"""
		Return the next unused grid window ID, suitable for passing to IFModeller.createGridWindow 
		Returns:
			int: 
		"""
		pass


	def processSolveErrors(self, exportErrors, solveErrors) -> int:
		r"""
		Based on the given two variables, report any errors that occurred during solution of several analyses 
		Params:
			exportErrors (bool): did any calls to IFDatabase.exportSolver fail?
			solveErrors (bool): did any calls to IFModeller.solve fail?
		Returns:
			int: true if a problem occurred
		"""
		pass


	def packDimensionality(self, energyDim, forceDim, lengthDim, massDim, timeDim, temperatureDim, perLengthDim=None) -> int:
		r"""
		Convert from separately specified dimensions into one convenient integer. This makes it easier to carry a dimensionality around as a single variable, and to pass that dimensionality to some other LPI functions. Please note that LUSAS expect to change the packing (and unpacking) algorithm for a future release, so this value should only ever be considered temporary, and never stored. 
		Params:
			energyDim (int): exponent of energy
			forceDim (int): exponent of force
			lengthDim (int): exponent of length
			massDim (int): exponent of mass
			timeDim (int): exponent of time
			temperatureDim (int): exponent of temperature
			perLengthDim (int, optional): 0 (the default) for most quantities. 1 for quantities that are 'per unit length' AND also have a non-zero exponent of length, such as "N.m/m". Similarly 2 and 3 for quantities that are per unit area or volume. It is possible to use a different IFUnitSet object to represent this 'extra' length/area/volume
		Returns:
			int: the returned packed value
		"""
		pass


	def unpackDimensionality(self, packed, energyDim, forceDim, lengthDim, massDim, timeDim, temperatureDim, perLengthDim=None) -> None:
		r"""
		Convert from a packed dimensionality back into its individual parts 
		Params:
			packed (int): the packed value
			energyDim (int): exponent of energy
			forceDim (int): exponent of force
			lengthDim (int): exponent of length
			massDim (int): exponent of mass
			timeDim (int): exponent of time
			temperatureDim (int): exponent of temperature
			perLengthDim (int, optional): 0 (the default) for most quantities. 1 for quantities that are 'per unit length' AND also have a non-zero exponent of length, such as "N.m/m". Similarly 2 and 3 for quantities that are per unit area or volume. It is possible to use a different IFUnitSet object to represent this 'extra' length/area/volume
		Returns:
			None: 
		"""
		pass


	def quit(self, force=None) -> None:
		r"""
		Quit the currently running instance of Modeller. 
		Params:
			force (bool, optional): If true Modeller will close regardless of whether there are unsaved changes (false by default).
		Returns:
			None: 
		"""
		pass


	def udrOptions(self) -> IFUserDefinedResultOptions:
		r"""
		Return data object that can be used for defining expressions in User Defined Results Attributes 
		Synonyms:
			getUDROptions
		Returns:
			IFUserDefinedResultOptions: 
		"""
		pass


	def getUDROptions(self) -> IFUserDefinedResultOptions:
		r"""
		Return data object that can be used for defining expressions in User Defined Results Attributes 
		Returns:
			IFUserDefinedResultOptions: 
		"""
		pass


	def newUDROptions(self) -> IFUserDefinedResultOptions:
		r"""
		Create new data object that can be used for defining expressions in User Defined Results Attributes 
		Returns:
			IFUserDefinedResultOptions: 
		"""
		pass


	def getSectionLibraries(self) -> list[str]:
		r"""
		Returns an array of available standard section libraries. The return value is an array of strings 
		Returns:
			array of strs: Returned array of names
		"""
		pass


	def getSectionTypes(self, libraryName, shapeFilter=None) -> list[str]:
		r"""
		Returns an array on available section types from the specified library. The return value is an array of strings 
		Params:
			libraryName (str): name of library eg 'UK Sections'
			shapeFilter (int or array of ints, optional): Section shape code to filter for; -1 (the default) to return all types
		Returns:
			array of strs: Returned array of names
		"""
		pass


	def getSectionNames(self, libraryName, libraryType, shapeFilter=None) -> list[str]:
		r"""
		Returns an array on available sections from the specified library. The return value is an array of strings 
		Params:
			libraryName (str): name of library eg 'UK Sections'
			libraryType (str): name of section type in library eg 'Universal Beams (BS4)'
			shapeFilter (int or array of ints, optional): Section shape code to filter for; -1 (the default) to return all types
		Returns:
			array of strs: Returned array of names
		"""
		pass


	def getSectionProperties(self, libraryName, libraryType, sectionName) -> list[float]:
		r"""
		Returns an array on property values from the specified section. The return value is an array of real values 
		Params:
			libraryName (str): name of library eg 'UK Sections'
			libraryType (str): name of section type in library eg 'Universal Beams (BS4)'
			sectionName (str): name of section
		Returns:
			array of float: Returned array of properties
		"""
		pass


	def getSectionPropertyNames(self, libraryName, libraryType, sectionName) -> list[str]:
		r"""
		Returns an array on property value names from the specified section. The return value is an array of strings 
		Params:
			libraryName (str): name of library eg 'UK Sections'
			libraryType (str): name of section type in library eg 'Universal Beams (BS4)'
			sectionName (str): name of section
		Returns:
			array of strs: Returned array of properties; eg A,Ixx,Iyy etc
		"""
		pass


	def newResultsContext(self, context) -> IFResultsContext:
		r"""
		Create a new instance of an object that can be used in place of the current view to hold results optins and settings such as active elements, transformations, etc. Typically, you would pass the current view in, to set up the default options. Alternatively, you may pass in 'nothing', in which case all such settings are left uninitialised - and you must manually specify them all. 
		Params:
			context (IFResultsContext): Object from which to copy settings such as active loadcase, and active elements
		Returns:
			IFResultsContext: 
		"""
		pass


	def bimExport(self) -> IFExportBimDataObj:
		r"""
		 
		Synonyms:
			getBimExportData
		Returns:
			IFExportBimDataObj: 
		"""
		pass


	def getBimExportData(self) -> IFExportBimDataObj:
		r"""
		 
		Returns:
			IFExportBimDataObj: 
		"""
		pass


	def newBimExportData(self) -> IFExportBimDataObj:
		r"""
		 
		Returns:
			IFExportBimDataObj: 
		"""
		pass


	def enableUndo(self, enable) -> None:
		r"""
		Switch Modeller's undo mechanism on or off. Switching undo off will make Modeller run faster and use less memory - but of course undo and redo won't work. 
		Params:
			enable (bool): 
		Returns:
			None: 
		"""
		pass


	def startMultiConfirmDialog(self) -> None:
		r"""
		adds an "ok all" button to any message boxes. Pressing "ok all" will suppress all messages until IFModeller.endMultiConfirmDialog() is called 
		Returns:
			None: 
		"""
		pass


	def endMultiConfirmDialog(self) -> None:
		r"""
		see IFModeller.startMultiConfirmDialog() 
		Returns:
			None: 
		"""
		pass


	def createPrestressSolver(self) -> IFPrestressSolver:
		r"""
		Create the prestress solver. This object can create the discrete loads required for tendon 
		Returns:
			IFPrestressSolver: 
		"""
		pass


	def beginModelessDialog(self) -> None:
		r"""
		Call this method before showing a modeless dialog to ensure that all the GUI but the view will be disabled.  See also IFModeller.endModelessDialog 
		Returns:
			None: 
		"""
		pass


	def endModelessDialog(self) -> None:
		r"""
		Call this method after showing a modeless dialog to reinstate the GUI. See also IFModeller.beginModelessDialog 
		Returns:
			None: 
		"""
		pass


	def derivedComponentCheck(self) -> bool:
		r"""
		Returns the value of the "unsafe derived components" checkbox that can be seen in several places in the UI. Note that the value of this checkbox is set for a modeller session, not for a particular model 
		Returns:
			bool: 
		"""
		pass


	def setDerivedComponentCheck(self, newVal) -> None:
		r"""
		Sets the value of the "unsafe derived components" checkbox that can be seen in several places in the UI. Note that the value of this checkbox is set for a modeller session, not for a particular model 
		Params:
			newVal (bool): 
		Returns:
			None: 
		"""
		pass


	def sineDegrees(self, angle) -> float:
		r"""
		returns the sine of the given angle, which is given in degrees 
		Params:
			angle (float): 
		Returns:
			float: 
		"""
		pass


	def sineRadians(self, angle) -> float:
		r"""
		returns the sine of the given angle, which is given in radians 
		Params:
			angle (float): 
		Returns:
			float: 
		"""
		pass


	def newProject(self, analysisType=None, filename=None) -> IFProject:
		r"""
		Creates a new, blank, model project without saving changes in the previous project, if any. (Use IFModeller.project.IFProject.save first.) 
		Params:
			analysisType (str, optional): Analysis type to create:. "Structural", "Thermal", or "Coupled"
			filename (str, optional): Filename to be created, e.g. "C:\temp\myModel.mdl". If not given, the database will not be associated with any file until IFProject.saveAs is called
		Returns:
			IFProject: The new project
		"""
		pass


	def project(self) -> IFProject:
		r"""
		Gets the current project object 
		Synonyms:
			getProject
		Returns:
			IFProject: 
		"""
		pass


	def getProject(self) -> IFProject:
		r"""
		Gets the current project object 
		Returns:
			IFProject: 
		"""
		pass


	def openProject(self, filename, readOnly=None, iArch=None, decoupleMaterials=None) -> IFProject:
		r"""
		Opens an existing model file from disk without saving changes in the previous model, if any. (Use IFModeller.project.IFProject.save first.) 
		Params:
			filename (str): Name and location of model file to open
			readOnly (bool, optional): Open the database read-only. If the file on disk is read-only, and this flag is given false, the function will fail with an error message. If the flag is given true, temporary changes are allowed, but it will not be possible to press the 'save' button ('save as' is allowed). For results files this flag is ignored, as it is never possible to modify results files on disk.
			iArch (int, optional): Only appropriate to mys files. The default 0 means 'auto-detect'. 32 means '32 bit file'. 64 means '64 bit file'. No other values are currently supported
			decoupleMaterials (bool, optional): Only appropriate to mdl file, default true means separate the structural part of a material set from the thermal part
		Returns:
			IFProject: The open model
		"""
		pass




def get_lusas_modeller() -> IFModeller:
	import win32com.client as win32
	return win32.dynamic.Dispatch('Lusas.Modeller.21.1')
